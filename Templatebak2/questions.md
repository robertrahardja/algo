# 1455_Check_If_a_Word_Occurs_As_a_Prefix_of_Any_Word_in_a_Sentence
# 1455. Check If a Word Occurs As a Prefix of Any Word in a Sentence


-----------------

# 1828_Queries_on_Number_of_Points_Inside_a_Circle
# 1828. Queries on Number of Points Inside a Circle


-----------------

# 367_Valid_Perfect_Square
# 367. Valid Perfect Square

Given a positive integer num, write a function which returns True if num is a
        perfect square else False.

    Note: Do not use any built-in library function such as sqrt.

    Example 1:
-----------------

# 274_H-Index
# 274. H-Index

Given an array of citations (each citation is a non-negative integer) of a researcher, write
        a function to compute the researcher's h-index.

    According to the definition
        of h-index on Wikipedia: "A scientist has index h if h of his/her N
        papers have at least h citations each, and the other N − h papers
        have no more than h citations each."

    Example:

    Input: citations = [3,0,6,1,5]
Output: 3
Explanation: [3,0,6,1,5] means the researcher has 5 papers in total and each of them had
             received 3, 0, 6, 1, 5 citations respectively.
             Since the researcher has 3 papers with at least 3 citations each and the remaining
             two with no more than 3 citations each, her h-index is 3.

    Note: If there are several possible values for h, the maximum
        one is taken as the h-index.
-----------------

# 641_Design_Circular_Deque
# 641. Design Circular Deque

Design your implementation of the circular double-ended queue (deque).

    Your implementation should support following operations:

    
        MyCircularDeque(k): Constructor, set the size of the deque to be k.
        insertFront(): Adds an item at the front of Deque. Return true if the
            operation is successful.
        
        insertLast(): Adds an item at the rear of Deque. Return true if the
            operation is successful.
        
        deleteFront(): Deletes an item from the front of Deque. Return true if the
            operation is successful.
        
        deleteLast(): Deletes an item from the rear of Deque. Return true if the
            operation is successful.
        
        getFront(): Gets the front item from the Deque. If the deque is empty,
            return -1.
        
        getRear(): Gets the last item from Deque. If the deque is empty, return -1.
        
        isEmpty(): Checks whether Deque is empty or not. 
        isFull(): Checks whether Deque is full or not.
    

     

    Example:

    MyCircularDeque circularDeque = new MycircularDeque(3); // set the size to be 3
circularDeque.insertLast(1);			// return true
circularDeque.insertLast(2);			// return true
circularDeque.insertFront(3);			// return true
circularDeque.insertFront(4);			// return false, the queue is full
circularDeque.getRear();  			// return 2
circularDeque.isFull();				// return true
circularDeque.deleteLast();			// return true
circularDeque.insertFront(4);			// return true
circularDeque.getFront();			// return 4

     

    Note:

    
        All values will be in the range of [0, 1000].
        The number of operations will be in the range of [1, 1000].
        Please do not use the built-in Deque library.
-----------------

# 254_Factor_Combinations
# 254. Factor Combinations

Numbers can be regarded as product of its factors. For example,

    8 = 2 x 2 x 2;
  = 2 x 4.

    Write a function that takes an integer n and return all possible combinations of its
        factors.

    Note:

    
        You may assume that n is always positive.
        Factors should be greater than 1 and less than n.
    

    Example 1: 

    Input: 1
Output: []

    Example 2: 

    Input: 37
Output:[]

    Example 3: 

    Input: 12
Output:
[
  [2, 6],
  [2, 2, 3],
  [3, 4]
]

    Example 4: 

    Input: 32
Output:
[
  [2, 16],
  [2, 2, 8],
  [2, 2, 2, 4],
  [2, 2, 2, 2, 2],
  [2, 4, 4],
  [4, 8]
]
-----------------

# 1670_Design_Front_Middle_Back_Queue
# 1670. Design Front Middle Back Queue


-----------------

# 942_DI_String_Match
# 942. DI String Match

Given a string S that only contains "I" (increase) or
        "D" (decrease), let N = S.length.

    Return any permutation A of [0, 1, ..., N] such
        that for all i = 0, ..., N-1:

    
        If S[i] == "I", then A[i] < A[i+1]
        If S[i] == "D", then A[i] > A[i+1]
    

     

    Example 1:

    Input: "IDID"
Output: [0,4,1,3,2]
-----------------

# 284_Peeking_Iterator
# 284. Peeking Iterator

Given an Iterator class interface with methods: next() and
        hasNext(), design and implement a PeekingIterator that support the
        peek() operation -- it essentially peek() at the element that will be returned
        by the next call to next().

    Example:

    Assume that the iterator is initialized to the beginning of the list: [1,2,3].

Call next() gets you 1, the first element in the list.
Now you call peek() and it returns 2, the next element. Calling next() after that still return 2.
You call next() the final time and it returns 3, the last element.
Calling hasNext() after that should return false.

    Follow up: How would you extend your design to be generic and work with all types, not
        just integer?
-----------------

# 949_Largest_Time_for_Given_Digits
# 949. Largest Time for Given Digits

Given an array of 4 digits, return the largest 24 hour time that can be made.

    The smallest 24 hour time is 00:00, and the largest is 23:59.  Starting from 00:00, a
        time is larger if more time has elapsed since midnight.

    Return the answer as a string of length 5.  If no valid time can be made, return an
        empty string.
-----------------

# 1661_Average_Time_of_Process_per_Machine
# 1661. Average Time of Process per Machine


-----------------

# 876_Middle_of_the_Linked_List
# 876. Middle of the Linked List

Given a non-empty, singly linked list with head node head, return a middle
        node of linked list.

    If there are two middle nodes, return the second middle node.
-----------------

# 1674_Minimum_Moves_to_Make_Array_Complementary
# 1674. Minimum Moves to Make Array Complementary


-----------------

# 140_Word_Break_II
# 140. Word Break II

Given a non-empty string s and a dictionary wordDict
        containing a list of non-empty words, add spaces in s to construct
        a sentence where each word is a valid dictionary word. Return all such possible
        sentences.

    Note:

    
        The same word in the dictionary may be reused multiple times in the segmentation.
        You may assume the dictionary does not contain duplicate words.
    

    Example 1:

    Input:
s = "catsanddog"
wordDict = ["cat", "cats", "and", "sand", "dog"]
Output:
[
  "cats and dog",
  "cat sand dog"
]

    Example 2:

    Input:
s = "pineapplepenapple"
wordDict = ["apple", "pen", "applepen", "pine", "pineapple"]
Output:
[
  "pine apple pen apple",
  "pineapple pen apple",
  "pine applepen apple"
]
Explanation: Note that you are allowed to reuse a dictionary word.

    Example 3:

    Input:
s = "catsandog"
wordDict = ["cats", "dog", "sand", "and", "cat"]
Output:
[]
-----------------

# 1283_Find_the_Smallest_Divisor_Given_a_Threshold
# 1283. Find the Smallest Divisor Given a Threshold


-----------------

# 333_Largest_BST_Subtree
# 333. Largest BST Subtree

Given a binary tree, find the largest subtree which is a Binary Search Tree (BST), where
        largest means subtree with largest number of nodes in it.

    Note:
        A subtree must include all of its descendants.

    Example:

    Input: [10,5,15,1,8,null,7]

   10
   / \
  5  15
 / \   \
1   8   7

Output: 3
Explanation: The Largest BST Subtree in this case is the highlighted one.
             The return value is the subtree's size, which is 3.

    Follow up:
        Can you figure out ways to solve it with O(n) time complexity?
-----------------

# 1699_Number_of_Calls_Between_Two_Persons
# 1699. Number of Calls Between Two Persons


-----------------

# 793_Preimage_Size_of_Factorial_Zeroes_Function
# 793. Preimage Size of Factorial Zeroes Function

Let f(x) be the number of zeroes at the end of x!. (Recall that
        x! = 1 * 2 * 3 * ... * x, and by convention, 0! = 1.)

    For example, f(3) = 0 because 3! = 6 has no zeroes at the end, while f(11)
        = 2 because 11! = 39916800 has 2 zeroes at the end. Given K, find how
        many non-negative integers x have the property that f(x) = K.

    Example 1:
Input: K = 0
Output: 5
Explanation: 0!, 1!, 2!, 3!, and 4! end with K = 0 zeroes.

Example 2:
Input: K = 5
Output: 0
Explanation: There is no x such that x! ends in K = 5 zeroes.

    Note:

    
        K will be an integer in the range [0, 10^9].
-----------------

# 1449_Form_Largest_Integer_With_Digits_That_Add_up_to_Target
# 1449. Form Largest Integer With Digits That Add up to Target


-----------------

# 198_House_Robber
# 198. House Robber

You are a professional robber planning to rob houses along a street. Each house has a certain
        amount of money stashed, the only constraint stopping you from robbing each of them is that
        adjacent houses have security system connected and it will automatically contact the
            police if two adjacent houses were broken into on the same night.

    Given a list of non-negative integers representing the amount of money of each house,
        determine the maximum amount of money you can rob tonight without alerting the police.
    

    Example 1:

    Input: [1,2,3,1]
Output: 4
Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).
             Total amount you can rob = 1 + 3 = 4.

    Example 2:

    Input: [2,7,9,3,1]
Output: 12
Explanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).
             Total amount you can rob = 2 + 9 + 1 = 12.
-----------------

# 1265_Print_Immutable_Linked_List_in_Reverse
# 1265. Print Immutable Linked List in Reverse


-----------------

# 224_Basic_Calculator
# 224. Basic Calculator

Implement a basic calculator to evaluate a simple expression string.

    The expression string may contain open ( and closing parentheses ),
        the plus + or minus sign -, non-negative integers and empty
        spaces  .

    Example 1:

    Input: "1 + 1"
Output: 2

    Example 2:

    Input: " 2-1 + 2 "
Output: 3

    Example 3:

    Input: "(1+(4+5+2)-3)+(6+8)"
Output: 23
    Note:

    
        You may assume that the given expression is always valid.
        Do not use the eval built-in library function.
-----------------

# 324_Wiggle_Sort_II
# 324. Wiggle Sort II

Given an unsorted array nums, reorder it such that nums[0] < nums[1]
        > nums[2] < nums[3]....

    Example 1:

    Input: nums = [1, 5, 1, 1, 6, 4]
Output: One possible answer is [1, 4, 1, 5, 1, 6].

    Example 2:

    Input: nums = [1, 3, 2, 2, 3, 1]
Output: One possible answer is [2, 3, 1, 3, 1, 2].

    Note:
        You may assume all input has valid answer.

    Follow Up:
        Can you do it in O(n) time and/or in-place with O(1) extra space?
-----------------

# 1052_Grumpy_Bookstore_Owner
# 1052. Grumpy Bookstore Owner

Today, the bookstore owner has a store open for customers.length minutes. 
        Every minute, some number of customers (customers[i]) enter the store, and all
        those customers leave after the end of that minute.

    On some minutes, the bookstore owner is grumpy.  If the bookstore owner is grumpy on the
        i-th minute, grumpy[i] = 1, otherwise grumpy[i] = 0.  When
        the bookstore owner is grumpy, the customers of that minute are not satisfied, otherwise
        they are satisfied.

    The bookstore owner knows a secret technique to keep themselves not grumpy for
        X minutes straight, but can only use it once.

    Return the maximum number of customers that can be satisfied throughout the day.

     

    Example 1:

    Input: customers = [1,0,1,2,1,1,7,5], grumpy = [0,1,0,1,0,1,0,1], X = 3
Output: 16
Explanation: The bookstore owner keeps themselves not grumpy for the last 3 minutes.
The maximum number of customers that can be satisfied = 1 + 1 + 1 + 1 + 7 + 5 = 16.

     

    Note:

    
        1 <= X <= customers.length == grumpy.length <= 20000
        
        0 <= customers[i] <= 1000
        0 <= grumpy[i] <= 1
-----------------

# 12_Integer_to_Roman
# 12. Integer to Roman

Roman numerals are represented by seven different symbols: I,
        V, X, L, C, D and
        M.

    Symbol       Value
I             1
V             5
X             10
L             50
C             100
D             500
M             1000

    For example, two is written as II in Roman numeral, just two one's
        added together. Twelve is written as, XII, which is simply X +
        II. The number twenty seven is written as XXVII, which is
        XX + V + II.

    Roman numerals are usually written largest to smallest from left to right. However, the
        numeral for four is not IIII. Instead, the number four is written as
        IV. Because the one is before the five we subtract it making four. The same
        principle applies to the number nine, which is written as IX. There are six
        instances where subtraction is used:

    
        I can be placed before V (5) and X (10) to make 4
            and 9. 
        
        X can be placed before L (50) and C (100) to make
            40 and 90. 
        
        C can be placed before D (500) and M (1000) to
            make 400 and 900.
        
    

    Given an integer, convert it to a roman numeral. Input is guaranteed to be within the range
        from 1 to 3999.

    Example 1:

    Input: 3
Output: "III"

    Example 2:

    Input: 4
Output: "IV"

    Example 3:

    Input: 9
Output: "IX"

    Example 4:

    Input: 58
Output: "LVIII"
Explanation: L = 50, V = 5, III = 3.

    Example 5:

    Input: 1994
Output: "MCMXCIV"
Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.
-----------------

# 1059_All_Paths_from_Source_Lead_to_Destination
# 1059. All Paths from Source Lead to Destination

Given the edges of a directed graph, and two nodes source and
        destination of this graph, determine whether or not all paths starting from
        source eventually end at destination, that is:

    
        At least one path exists from the source node to the
            destination node
        
        If a path exists from the source node to a node with no outgoing edges,
            then that node is equal to destination.
        
        The number of possible paths from source to destination is a
            finite number.
        
    

    Return true if and only if all roads from source lead to destination.
    

     

    Example 1:

    

    Input: n = 3, edges = [[0,1],[0,2]], source = 0, destination = 2
Output: false
Explanation: It is possible to reach and get stuck on both node 1 and node 2.

    Example 2:

    

    Input: n = 4, edges = [[0,1],[0,3],[1,2],[2,1]], source = 0, destination = 3
Output: false
Explanation: We have two possibilities: to end at node 3, or to loop over node 1 and node 2 indefinitely.

    Example 3:

    

    Input: n = 4, edges = [[0,1],[0,2],[1,3],[2,3]], source = 0, destination = 3
Output: true

    Example 4:

    

    Input: n = 3, edges = [[0,1],[1,1],[1,2]], source = 0, destination = 2
Output: false
Explanation: All paths from the source node end at the destination node, but there are an infinite number of paths, such as 0-1-2, 0-1-1-2, 0-1-1-1-2, 0-1-1-1-1-2, and so on.

    Example 5:

    

    Input: n = 2, edges = [[0,1],[1,1]], source = 0, destination = 1
Output: false
Explanation: There is infinite self-loop at destination node.

     

    Note:

    
        
            The given graph may have self loops and parallel edges.
        
        The number of nodes n in the graph is between 1 and 10000
        
        The number of edges in the graph is between 0 and 10000
        0 <= edges.length <= 10000
        edges[i].length == 2
        0 <= source <= n - 1
        0 <= destination <= n - 1
-----------------

# 609_Find_Duplicate_File_in_System
# 609. Find Duplicate File in System

Given a list of directory info including directory path, and all the files with contents in
        this directory, you need to find out all the groups of duplicate files in the file system in
        terms of their paths.

    A group of duplicate files consists of at least two files that have exactly the same
        content.

    A single directory info string in the input list has the following format:

    "root/d1/d2/.../dm f1.txt(f1_content) f2.txt(f2_content) ... fn.txt(fn_content)"
    

    It means there are n files (f1.txt, f2.txt ...
        fn.txt with content f1_content, f2_content ... fn_content,
        respectively) in directory root/d1/d2/.../dm. Note that n >= 1 and m >=
        0. If m = 0, it means the directory is just the root directory.

    The output is a list of group of duplicate file paths. For each group, it contains all
        the file paths of the files that have the same content. A file path is a string that has the
        following format:

    "directory_path/file_name.txt"

    Example 1:

    Input:
["root/a 1.txt(abcd) 2.txt(efgh)", "root/c 3.txt(abcd)", "root/c/d 4.txt(efgh)", "root 4.txt(efgh)"]
Output:
[["root/a/2.txt","root/c/d/4.txt","root/4.txt"],["root/a/1.txt","root/c/3.txt"]]

     

    Note:

    
        No order is required for the final output.
        You may assume the directory name, file name and file content only has letters and
            digits, and the length of file content is in the range of [1,50].
        
        The number of files given is in the range of [1,20000].
        You may assume no files or directories share the same name in the same directory.
        You may assume each given directory info represents a unique directory. Directory path
            and file info are separated by a single blank space.
        
    

     
    Follow-up beyond contest:

    
        Imagine you are given a real file system, how will you search files? DFS or BFS?
        If the file content is very large (GB level), how will you modify your solution?
        If you can only read the file by 1kb each time, how will you modify your solution?
        What is the time complexity of your modified solution? What is the most time-consuming
            part and memory consuming part of it? How to optimize?
        
        How to make sure the duplicated files you find are not false positive?
-----------------

# 300_Longest_Increasing_Subsequence
# 300. Longest Increasing Subsequence

Given an unsorted array of integers, find the length of longest increasing subsequence.

    Example:

    Input: [10,9,2,5,3,7,101,18]
Output: 4
Explanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4. 

    Note: 

    
        There may be more than one LIS combination, it is only necessary for you to return the
            length.
        
        Your algorithm should run in O(n2) complexity.
    

    Follow up: Could you improve it to O(n log n) time complexity?
-----------------

# 1350_Students_With_Invalid_Departments
# 1350. Students With Invalid Departments


-----------------

# 375_Guess_Number_Higher_or_Lower_II
# 375. Guess Number Higher or Lower II

We are playing the Guess Game. The game is as follows:

    I pick a number from 1 to n. You have to guess which number
        I picked.

    Every time you guess wrong, I'll tell you whether the number I picked is higher or
        lower.

    However, when you guess a particular number x, and you guess wrong, you pay $x. You
        win the game when you guess the number I picked.

    Example:

    n = 10, I pick 8.

First round:  You guess 5, I tell you that it's higher. You pay $5.
Second round: You guess 7, I tell you that it's higher. You pay $7.
Third round:  You guess 9, I tell you that it's lower. You pay $9.

Game over. 8 is the number I picked.

You end up paying $5 + $7 + $9 = $21.

    Given a particular n ≥ 1, find out how much money you need to have to
        guarantee a win.
-----------------

# 1309_Decrypt_String_from_Alphabet_to_Integer_Mapping
# 1309. Decrypt String from Alphabet to Integer Mapping


-----------------

# 130_Surrounded_Regions
# 130. Surrounded Regions

Given a 2D board containing 'X' and 'O' (the
        letter O), capture all regions surrounded by 'X'.

    A region is captured by flipping all 'O's into 'X's
        in that surrounded region.

    Example:

    X X X X
X O O X
X X O X
X O X X

    After running your function, the board should be:

    X X X X
X X X X
X X X X
X O X X

    Explanation:

    Surrounded regions shouldn’t be on the border, which means that any
        'O' on the border of the board are not flipped to 'X'.
        Any 'O' that is not on the border and it is not connected to an
        'O' on the border will be flipped to 'X'. Two
        cells are connected if they are adjacent cells connected horizontally or vertically.
-----------------

# 1679_Max_Number_of_K-Sum_Pairs
# 1679. Max Number of K-Sum Pairs


-----------------

# 1264_Page_Recommendations
# 1264. Page Recommendations


-----------------

# 921_Minimum_Add_to_Make_Parentheses_Valid
# 921. Minimum Add to Make Parentheses Valid

Given a string S of '(' and ')'
        parentheses, we add the minimum number of parentheses ( '(' or ')',
        and in any positions ) so that the resulting parentheses string is valid.

    Formally, a parentheses string is valid if and only if:

    
        It is the empty string, or
        It can be written as AB (A concatenated with
            B), where A and B are valid strings, or
        
        It can be written as (A), where A is a valid string.
    

    Given a parentheses string, return the minimum number of parentheses we must add to make the
        resulting string valid.

     

    Example 1:

    Input: "())"
Output: 1
-----------------

# 1611_Minimum_One_Bit_Operations_to_Make_Integers_Zero
# 1611. Minimum One Bit Operations to Make Integers Zero


-----------------

# 873_Length_of_Longest_Fibonacci_Subsequence
# 873. Length of Longest Fibonacci Subsequence

A sequence X_1, X_2, ..., X_n is fibonacci-like if:

    
        n >= 3
        X_i + X_{i+1} = X_{i+2} for all i + 2 <= n
    

    Given a strictly increasing array A of positive integers
        forming a sequence, find the length of the longest fibonacci-like
        subsequence of A.  If one does not exist, return 0.

    (Recall that a subsequence is derived from another sequence A by deleting
        any number of elements (including none) from A, without changing the
        order of the remaining elements.  For example, [3, 5, 8] is a subsequence
        of [3, 4, 5, 6, 7, 8].)

     

    
    

    Example 1:

    Input: [1,2,3,4,5,6,7,8]
Output: 5
Explanation:
The longest subsequence that is fibonacci-like: [1,2,3,5,8].

    Example 2:

    Input: [1,3,7,11,12,14,18]
Output: 3
Explanation:
The longest subsequence that is fibonacci-like:
[1,11,12], [3,11,14] or [7,11,18].

     

    Note:

    
        3 <= A.length <= 1000
        1 <= A[0] < A[1] < ... < A[A.length - 1] <= 10^9
        (The time limit has been reduced by 50% for submissions in Java, C, and C++.)
-----------------

# 118_Pascal's_Triangle
# 118. Pascal's Triangle

Given a non-negative integer numRows, generate the first numRows of
        Pascal's triangle.

    
        In Pascal's triangle, each number is the sum of the two numbers directly above
            it.
        
    

    Example:

    Input: 5
Output:
[
     [1],
    [1,1],
   [1,2,1],
  [1,3,3,1],
 [1,4,6,4,1]
]
-----------------

# 1024_Video_Stitching
# 1024. Video Stitching

You are given a series of video clips from a sporting event that lasted T
        seconds.  These video clips can be overlapping with each other and have varied
        lengths.

    Each video clip clips[i] is an interval: it starts at time clips[i][0]
        and ends at time clips[i][1].  We can cut these clips into segments
        freely: for example, a clip [0, 7] can be cut into segments [0, 1] + [1,
            3] + [3, 7].

    Return the minimum number of clips needed so that we can cut the clips into segments that
        cover the entire sporting event ([0, T]).  If the task is impossible,
        return -1.

     

    Example 1:

    Input: clips = [[0,2],[4,6],[8,10],[1,9],[1,5],[5,9]], T = 10
Output: 3
Explanation: 
We take the clips [0,2], [8,10], [1,9]; a total of 3 clips.
Then, we can reconstruct the sporting event as follows:
We cut [1,9] into segments [1,2] + [2,8] + [8,9].
Now we have segments [0,2] + [2,8] + [8,10] which cover the sporting event [0, 10].

    Example 2:

    Input: clips = [[0,1],[1,2]], T = 5
Output: -1
Explanation: 
We can't cover [0,5] with only [0,1] and [0,2].

    Example 3:

    Input: clips = [[0,1],[6,8],[0,2],[5,6],[0,4],[0,3],[6,7],[1,3],[4,7],[1,4],[2,5],[2,6],[3,4],[4,5],[5,7],[6,9]], T = 9
Output: 3
Explanation: 
We can take clips [0,4], [4,7], and [6,9].

    Example 4:

    Input: clips = [[0,4],[2,8]], T = 5
Output: 2
Explanation: 
Notice you can have extra video after the event ends.

     

    Note:

    
        1 <= clips.length <= 100
        0 <= clips[i][0], clips[i][1] <= 100
        0 <= T <= 100
-----------------

# 1765_Map_of_Highest_Peak
# 1765. Map of Highest Peak


-----------------

# 99_Recover_Binary_Search_Tree
# 99. Recover Binary Search Tree

Two elements of a binary search tree (BST) are swapped by mistake.

    Recover the tree without changing its structure.

    Example 1:

    Input: [1,3,null,null,2]

   1
  /
 3
  \
   2

Output: [3,1,null,null,2]

   3
  /
 1
  \
   2

    Example 2:

    Input: [3,1,4,null,null,2]

  3
 / \
1   4
   /
  2

Output: [2,1,4,null,null,3]

  2
 / \
1   4
   /
  3

    Follow up:

    
        A solution using O(n) space is pretty straight forward.
        Could you devise a constant space solution?
-----------------

# 752_Open_the_Lock
# 752. Open the Lock

You have a lock in front of you with 4 circular wheels. Each wheel has 10 slots: '0',
        '1', '2', '3', '4', '5', '6', '7', '8', '9'. The wheels can rotate freely and wrap
        around: for example we can turn '9' to be '0', or '0'
        to be '9'. Each move consists of turning one wheel one slot.
    
    
        The lock initially starts at '0000', a string representing the state of the 4
        wheels.
    
    
        You are given a list of deadends dead ends, meaning if the lock displays any of
        these codes, the wheels of the lock will stop turning and you will be unable to open it.
    
    
        Given a target representing the value of the wheels that will unlock the lock,
        return the minimum total number of turns required to open the lock, or -1 if it is
        impossible.
    

    Example 1:
    Input: deadends = ["0201","0101","0102","1212","2002"], target = "0202"
Output: 6
Explanation:
A sequence of valid moves would be "0000" -> "1000" -> "1100" -> "1200" -> "1201" -> "1202" -> "0202".
Note that a sequence like "0000" -> "0001" -> "0002" -> "0102" -> "0202" would be invalid,
because the wheels of the lock become stuck after the display becomes the dead end "0102".

    

    Example 2:
    Input: deadends = ["8888"], target = "0009"
Output: 1
Explanation:
We can turn the last wheel in reverse to move from "0000" -> "0009".

    

    Example 3:
    Input: deadends = ["8887","8889","8878","8898","8788","8988","7888","9888"], target = "8888"
Output: -1
Explanation:
We can't reach the target without getting stuck.

    

    Example 4:
    Input: deadends = ["0000"], target = "8888"
Output: -1

    

    Note:
    
        The length of deadends will be in the range [1, 500].
        target will not be in the list deadends.
        Every string in deadends and the string target will be a
            string of 4 digits from the 10,000 possibilities '0000' to
            '9999'.
-----------------

# 676_Implement_Magic_Dictionary
# 676. Implement Magic Dictionary

Implement a magic directory with buildDict, and search methods.
    

    
        For the method buildDict, you'll be given a list of non-repetitive words to
        build a dictionary.
    

    
        For the method search, you'll be given a word, and judge whether if you modify
        exactly one character into another character in this word, the modified word
        is in the dictionary you just built.
    

    Example 1:
    Input: buildDict(["hello", "leetcode"]), Output: Null
Input: search("hello"), Output: False
Input: search("hhllo"), Output: True
Input: search("hell"), Output: False
Input: search("leetcoded"), Output: False

    

    Note:
    
        You may assume that all the inputs are consist of lowercase letters a-z.
        
        For contest purpose, the test data is rather small by now. You could think about highly
            efficient algorithm after the contest.
        
        Please remember to RESET your class variables declared in class MagicDictionary,
            as static/class variables are persisted across multiple test cases. Please see here for more details.
-----------------

# 391_Perfect_Rectangle
# 391. Perfect Rectangle

Given N axis-aligned rectangles where N > 0, determine if they all together form an exact
        cover of a rectangular region.

    Each rectangle is represented as a bottom-left point and a top-right point. For example, a
        unit square is represented as [1,1,2,2]. (coordinate of bottom-left point is (1, 1) and
        top-right point is (2, 2)).
-----------------

# 1571_Warehouse_Manager
# 1571. Warehouse Manager


-----------------

# 355_Design_Twitter
# 355. Design Twitter

Design a simplified version of Twitter where users can post tweets, follow/unfollow another
        user and is able to see the 10 most recent tweets in the user's news feed. Your design
        should support the following methods:

    
    
        postTweet(userId, tweetId): Compose a new tweet.
        getNewsFeed(userId): Retrieve the 10 most recent tweet ids in the user's news
            feed. Each item in the news feed must be posted by users who the user followed or by the
            user herself. Tweets must be ordered from most recent to least recent.
        
        follow(followerId, followeeId): Follower follows a followee.
        unfollow(followerId, followeeId): Follower unfollows a followee.
    
    

    Example:
    Twitter twitter = new Twitter();

// User 1 posts a new tweet (id = 5).
twitter.postTweet(1, 5);

// User 1's news feed should return a list with 1 tweet id -> [5].
twitter.getNewsFeed(1);

// User 1 follows user 2.
twitter.follow(1, 2);

// User 2 posts a new tweet (id = 6).
twitter.postTweet(2, 6);

// User 1's news feed should return a list with 2 tweet ids -> [6, 5].
// Tweet id 6 should precede tweet id 5 because it is posted after tweet id 5.
twitter.getNewsFeed(1);

// User 1 unfollows user 2.
twitter.unfollow(1, 2);

// User 1's news feed should return a list with 1 tweet id -> [5],
// since user 1 is no longer following user 2.
twitter.getNewsFeed(1);
-----------------

# 489_Robot_Room_Cleaner
# 489. Robot Room Cleaner

Given a robot cleaner in a room modeled as a grid.

    Each cell in the grid can be empty or blocked.

    The robot cleaner with 4 given APIs can move forward, turn left or turn right. Each turn it
        made is 90 degrees.

    When it tries to move into a blocked cell, its bumper sensor detects the obstacle and it
        stays on the current cell.

    Design an algorithm to clean the entire room using only the 4 given APIs shown below.

    interface Robot {
  // returns true if next cell is open and robot moves into the cell.
  // returns false if next cell is obstacle and robot stays on the current cell.
  boolean move();

  // Robot will stay on the same cell after calling turnLeft/turnRight.
  // Each turn will be 90 degrees.
  void turnLeft();
  void turnRight();

  // Clean the current cell.
  void clean();
}

    Example:

    Input:
room = [
  [1,1,1,1,1,0,1,1],
  [1,1,1,1,1,0,1,1],
  [1,0,1,1,1,1,1,1],
  [0,0,0,1,0,0,0,0],
  [1,1,1,1,1,1,1,1]
],
row = 1,
col = 3

Explanation:
All grids in the room are marked by either 0 or 1.
0 means the cell is blocked, while 1 means the cell is accessible.
The robot initially starts at the position of row=1, col=3.
From the top left corner, its position is one row below and three columns right.

    Notes:

    
        The input is only given to initialize the room and the robot's position internally. You
            must solve this problem "blindfolded". In other words, you must control the
            robot using only the mentioned 4 APIs, without knowing the room layout and the initial
            robot's position.
        
        The robot's initial position will always be in an accessible cell.
        The initial direction of the robot will be facing up.
        All accessible cells are connected, which means the all cells marked as 1 will be
            accessible by the robot.
        
        Assume all four edges of the grid are all surrounded by wall.
-----------------

# 1134_Armstrong_Number
# 1134. Armstrong Number

The k-digit number N is an Armstrong number if and only if the k-th power of
        each digit sums to N.

    Given a positive integer N, return true if and only if it is an Armstrong
        number.

     

    Example 1:

    Input: 153
Output: true
Explanation: 
153 is a 3-digit number, and 153 = 1^3 + 5^3 + 3^3.

    Example 2:

    Input: 123
Output: false
Explanation: 
123 is a 3-digit number, and 123 != 1^3 + 2^3 + 3^3 = 36.

     

    Note:

    
        1 <= N <= 10^8
-----------------

# 1381_Design_a_Stack_With_Increment_Operation
# 1381. Design a Stack With Increment Operation


-----------------

# 282_Expression_Add_Operators
# 282. Expression Add Operators

Given a string that contains only digits 0-9 and a target value, return all
        possibilities to add binary operators (not unary) +, -, or
        * between the digits so they evaluate to the target value.

    Example 1:

    Input: num = "123", target = 6
Output: ["1+2+3", "1*2*3"]

    Example 2:

    Input: num = "232", target = 8
Output: ["2*3+2", "2+3*2"]

    Example 3:

    Input: num = "105", target = 5
Output: ["1*0+5","10-5"]

    Example 4:

    Input: num = "00", target = 0
Output: ["0+0", "0-0", "0*0"]

    Example 5:

    Input: num = "3456237490", target = 9191
Output: []
-----------------

# 218_The_Skyline_Problem
# 218. The Skyline Problem

A city's skyline is the outer contour of the silhouette formed by all the buildings in
        that city when viewed from a distance. Now suppose you are given the locations and height
            of all the buildings as shown on a cityscape photo (Figure A), write a program to
        output the skyline formed by these buildings collectively (Figure B).
        

    The geometric information of each building is represented by a triplet of integers [Li,
        Ri, Hi], where Li and Ri are the x coordinates of the left
        and right edge of the ith building, respectively, and Hi is its height. It is
        guaranteed that 0 ≤ Li, Ri ≤ INT_MAX, 0 < Hi ≤ INT_MAX,
        and Ri - Li > 0. You may assume all buildings are perfect rectangles
        grounded on an absolutely flat surface at height 0.

    For instance, the dimensions of all buildings in Figure A are recorded as: [ [2 9 10],
        [3 7 15], [5 12 12], [15 20 10], [19 24 8] ] .

    The output is a list of "key points" (red dots in Figure B) in the format of
        [ [x1,y1], [x2, y2], [x3, y3], ... ] that uniquely defines a skyline. A key
            point is the left endpoint of a horizontal line segment. Note that the last key
        point, where the rightmost building ends, is merely used to mark the termination of the
        skyline, and always has zero height. Also, the ground in between any two adjacent buildings
        should be considered part of the skyline contour.

    For instance, the skyline in Figure B should be represented as:[ [2 10], [3 15], [7
        12], [12 0], [15 10], [20 8], [24, 0] ].

    Notes:

    
        The number of buildings in any input list is guaranteed to be in the range [0,
            10000].
        
        The input list is already sorted in ascending order by the left x position
            Li.
        
        The output list must be sorted by the x position.
        There must be no consecutive horizontal lines of equal height in the output skyline. For
            instance, [...[2 3], [4 5], [7 5], [11 5], [12 7]...] is not acceptable;
            the three lines of height 5 should be merged into one in the final output as such:
            [...[2 3], [4 5], [12 7], ...]
-----------------

# 1585_Check_If_String_Is_Transformable_With_Substring_Sort_Operations
# 1585. Check If String Is Transformable With Substring Sort Operations


-----------------

# 1658_Minimum_Operations_to_Reduce_X_to_Zero
# 1658. Minimum Operations to Reduce X to Zero


-----------------

# 953_Verifying_an_Alien_Dictionary
# 953. Verifying an Alien Dictionary

In an alien language, surprisingly they also use english lowercase letters, but possibly in
        a different order. The order of the alphabet is some
        permutation of lowercase letters.

    Given a sequence of words written in the alien language, and the
        order of the alphabet, return true if and only if the given
        words are sorted lexicographicaly in this alien language.
-----------------

# 538_Convert_BST_to_Greater_Tree
# 538. Convert BST to Greater Tree

Given a Binary Search Tree (BST), convert it to a Greater Tree such that every key of the
        original BST is changed to the original key plus sum of all keys greater than the original
        key in BST.

    
        Example:
    Input: The root of a Binary Search Tree like this:
              5
            /   \
           2     13

Output: The root of a Greater Tree like this:
             18
            /   \
          20     13
-----------------

# 931_Minimum_Falling_Path_Sum
# 931. Minimum Falling Path Sum

Given a square array of integers A, we want the
        minimum sum of a falling path through A.

    A falling path starts at any element in the first row, and chooses one element from each row. 
        The next row's choice must be in a column that is different from the previous row's
        column by at most one.

     

    Example 1:

    Input: [[1,2,3],[4,5,6],[7,8,9]]
Output: 12
Explanation: 
The possible falling paths are:

    
        [1,4,7], [1,4,8], [1,5,7], [1,5,8], [1,5,9]
        [2,4,7], [2,4,8], [2,5,7], [2,5,8], [2,5,9], [2,6,8], [2,6,9]
        [3,5,7], [3,5,8], [3,5,9], [3,6,8], [3,6,9]
    

    The falling path with the smallest sum is [1,4,7], so the answer is
        12.

     

    Note:

    
        1 <= A.length == A[0].length <= 100
        -100 <= A[i][j] <= 100
-----------------

# 713_Subarray_Product_Less_Than_K
# 713. Subarray Product Less Than K

Your are given an array of positive integers nums.
    Count and print the number of (contiguous) subarrays where the product of all the elements in
        the subarray is less than k.

    Example 1:
    Input: nums = [10, 5, 2, 6], k = 100
Output: 8
Explanation: The 8 subarrays that have product less than 100 are: [10], [5], [2], [6], [10, 5], [5, 2], [2, 6], [5, 2, 6].
Note that [10, 5, 2] is not included as the product of 100 is not strictly less than k.

    

    Note:
    0 < nums.length <= 50000.
    0 < nums[i] < 1000.
    0 <= k < 10^6.
-----------------

# 1815_Maximum_Number_of_Groups_Getting_Fresh_Donuts
# 1815. Maximum Number of Groups Getting Fresh Donuts


-----------------

# 482_License_Key_Formatting
# 482. License Key Formatting

You are given a license key represented as a string S which consists only alphanumeric
        character and dashes. The string is separated into N+1 groups by N dashes.

    Given a number K, we would want to reformat the strings such that each group contains exactly
        K characters, except for the first group which could be shorter than K, but still must
        contain at least one character. Furthermore, there must be a dash inserted between two
        groups and all lowercase letters should be converted to uppercase.

    Given a non-empty string S and a number K, format the string according to the rules described
        above.

    Example 1:
    Input: S = "5F3Z-2e-9-w", K = 4

Output: "5F3Z-2E9W"

Explanation: The string S has been split into two parts, each part has 4 characters.
Note that the two extra dashes are not needed and can be removed.

    

    Example 2:
    Input: S = "2-5g-3-J", K = 2

Output: "2-5G-3J"

Explanation: The string S has been split into three parts, each part has 2 characters except the first part as it could be shorter as mentioned above.

    

    Note:
    
        The length of string S will not exceed 12,000, and K is a positive integer.
        String S consists only of alphanumerical characters (a-z and/or A-Z and/or 0-9) and
            dashes(-).
        
        String S is non-empty.
-----------------

# 528_Random_Pick_with_Weight
# 528. Random Pick with Weight

Given an array w of positive integers, where w[i] describes the
        weight of index i, write a function pickIndex which
        randomly picks an index in proportion to its weight.

    Note:

    
        1 <= w.length <= 10000
        1 <= w[i] <= 10^5
        pickIndex will be called at most 10000 times.
    

    Example 1:

    Input:
["Solution","pickIndex"]
[[[1]],[]]
Output: [null,0]
-----------------

# 273_Integer_to_English_Words
# 273. Integer to English Words

Convert a non-negative integer to its english words representation. Given input is guaranteed
        to be less than 231 - 1.

    Example 1:

    Input: 123
Output: "One Hundred Twenty Three"

    Example 2:

    Input: 12345
Output: "Twelve Thousand Three Hundred Forty Five"

    Example 3:

    Input: 1234567
Output: "One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven"

    Example 4:

    Input: 1234567891
Output: "One Billion Two Hundred Thirty Four Million Five Hundred Sixty Seven Thousand Eight Hundred Ninety One"
-----------------

# 549_Binary_Tree_Longest_Consecutive_Sequence_II
# 549. Binary Tree Longest Consecutive Sequence II

Given a binary tree, you need to find the length of Longest Consecutive Path in Binary
        Tree.

    Especially, this path can be either increasing or decreasing. For example, [1,2,3,4] and
        [4,3,2,1] are both considered valid, but the path [1,2,4,3] is not valid. On the other hand,
        the path can be in the child-Parent-child order, where not necessarily be parent-child
        order.

    Example 1:

    Input:
        1
       / \
      2   3
Output: 2
Explanation: The longest consecutive path is [1, 2] or [2, 1].

     

    Example 2:

    Input:
        2
       / \
      1   3
Output: 3
Explanation: The longest consecutive path is [1, 2, 3] or [3, 2, 1].

     

    Note: All the values of tree nodes are in the range of [-1e7, 1e7].
-----------------

# 1005_Maximize_Sum_Of_Array_After_K_Negations
# 1005. Maximize Sum Of Array After K Negations

Given an array A of integers, we must modify the array in
        the following way: we choose an i and replace A[i] with
        -A[i], and we repeat this process K times in total.  (We may
        choose the same index i multiple times.)

    Return the largest possible sum of the array after modifying it in this way.

     

    Example 1:

    Input: A = [4,2,3], K = 1
Output: 5
Explanation: Choose indices (1,) and A becomes [4,-2,3].
-----------------

# 1499_Max_Value_of_Equation
# 1499. Max Value of Equation


-----------------

# 332_Reconstruct_Itinerary
# 332. Reconstruct Itinerary

Given a list of airline tickets represented by pairs of departure and arrival airports [from,
        to], reconstruct the itinerary in order. All of the tickets belong to a man who
        departs from JFK. Thus, the itinerary must begin with JFK.

    Note:

    
        If there are multiple valid itineraries, you should return the itinerary that has the
            smallest lexical order when read as a single string. For example, the itinerary ["JFK",
                "LGA"] has a smaller lexical order than ["JFK",
                "LGB"].
        
        All airports are represented by three capital letters (IATA code).
        You may assume all tickets form at least one valid itinerary.
    

    Example 1:

    Input: [["MUC", "LHR"], ["JFK", "MUC"], ["SFO", "SJC"], ["LHR", "SFO"]]
Output: ["JFK", "MUC", "LHR", "SFO", "SJC"]

    Example 2:

    Input: [["JFK","SFO"],["JFK","ATL"],["SFO","ATL"],["ATL","JFK"],["ATL","SFO"]]
Output: ["JFK","ATL","JFK","SFO","ATL","SFO"]
Explanation: Another possible reconstruction is ["JFK","SFO","ATL","JFK","ATL","SFO"].
             But it is larger in lexical order.
-----------------

# 587_Erect_the_Fence
# 587. Erect the Fence

There are some trees, where each tree is represented by (x,y) coordinate in a two-dimensional
        garden. Your job is to fence the entire garden using the minimum length of rope as it
        is expensive. The garden is well fenced only if all the trees are enclosed. Your task is to
        help find the coordinates of trees which are exactly located on the fence perimeter.

     

    Example 1:

    Input: [[1,1],[2,2],[2,0],[2,4],[3,3],[4,2]]
Output: [[1,1],[2,0],[4,2],[3,3],[2,4]]
Explanation:

    Example 2:

    Input: [[1,2],[2,2],[4,2]]
Output: [[1,2],[2,2],[4,2]]
Explanation:

Even you only have trees in a line, you need to use rope to enclose them.

     

    Note:

    
        All trees should be enclosed together. You cannot cut the rope to enclose trees that
            will separate them in more than one group.
        
        All input integers will range from 0 to 100.
        The garden has at least one tree.
        All coordinates are distinct.
        Input points have NO order. No order required for output.
        input types have been changed on April 15, 2019. Please reset to default code definition
            to get new method signature.
-----------------

# 1183_Maximum_Number_of_Ones
# 1183. Maximum Number of Ones

Consider a matrix M with dimensions width * height, such that every
        cell has value 0 or 1, and any square sub-matrix
        of M of size sideLength * sideLength has at most maxOnes ones.
    

    Return the maximum possible number of ones that the matrix M can have.

     
    Example 1:

    Input: width = 3, height = 3, sideLength = 2, maxOnes = 1
Output: 4
Explanation:
In a 3*3 matrix, no 2*2 sub-matrix can have more than 1 one.
The best solution that has 4 ones is:
[1,0,1]
[0,0,0]
[1,0,1]

    Example 2:

    Input: width = 3, height = 3, sideLength = 2, maxOnes = 2
Output: 6
Explanation:
[1,0,1]
[1,0,1]
[1,0,1]

     
    Constraints:

    
        1 <= width, height <= 100
        1 <= sideLength <= width, height
        0 <= maxOnes <= sideLength * sideLength
-----------------

# 558_Quad_Tree_Intersection
# 558. Quad Tree Intersection

A quadtree is a tree data in which each internal node has exactly four children: topLeft,
        topRight, bottomLeft and bottomRight. Quad trees are
        often used to partition a two-dimensional space by recursively subdividing it into four
        quadrants or regions.

    We want to store True/False information in our quad tree. The quad tree is used to represent
        a N * N boolean grid. For each node, it will be subdivided into four children
        nodes until the values in the region it represents are all the same. Each
        node has another two boolean attributes : isLeaf and val. isLeaf
        is true if and only if the node is a leaf node. The val attribute for a leaf
        node contains the value of the region it represents.

    For example, below are two quad trees A and B:

    A:
+-------+-------+   T: true
|       |       |   F: false
|   T   |   T   |
|       |       |
+-------+-------+
|       |       |
|   F   |   F   |
|       |       |
+-------+-------+
topLeft: T
topRight: T
bottomLeft: F
bottomRight: F

B:
+-------+---+---+
|       | F | F |
|   T   +---+---+
|       | T | T |
+-------+---+---+
|       |       |
|   T   |   F   |
|       |       |
+-------+-------+
topLeft: T
topRight:
     topLeft: F
     topRight: F
     bottomLeft: T
     bottomRight: T
bottomLeft: T
bottomRight: F

     

    Your task is to implement a function that will take two quadtrees and return a quadtree that
        represents the logical OR (or union) of the two trees.

    A:                 B:                 C (A or B):
+-------+-------+  +-------+---+---+  +-------+-------+
|       |       |  |       | F | F |  |       |       |
|   T   |   T   |  |   T   +---+---+  |   T   |   T   |
|       |       |  |       | T | T |  |       |       |
+-------+-------+  +-------+---+---+  +-------+-------+
|       |       |  |       |       |  |       |       |
|   F   |   F   |  |   T   |   F   |  |   T   |   F   |
|       |       |  |       |       |  |       |       |
+-------+-------+  +-------+-------+  +-------+-------+

    Note:

    
        Both A and B represent grids of size N * N.
        
        N is guaranteed to be a power of 2.
        If you want to know more about the quad tree, you can refer to its wiki.
        
        The logic OR operation is defined as this: "A or B" is true if A is
            true, or if B is true, or if both A and B are true.
-----------------

# 1380_Lucky_Numbers_in_a_Matrix
# 1380. Lucky Numbers in a Matrix


-----------------

# 125_Valid_Palindrome
# 125. Valid Palindrome

Given a string, determine if it is a palindrome, considering only alphanumeric characters and
        ignoring cases.

    Note: For the purpose of this problem, we define empty string as valid
        palindrome.

    Example 1:

    Input: "A man, a plan, a canal: Panama"
Output: true

    Example 2:

    Input: "race a car"
Output: false
-----------------

# 295_Find_Median_from_Data_Stream
# 295. Find Median from Data Stream

Median is the middle value in an ordered integer list. If the size of the list is even, there
        is no middle value. So the median is the mean of the two middle value.
    For example,

    [2,3,4], the median is 3

    [2,3], the median is (2 + 3) / 2 = 2.5

    Design a data structure that supports the following two operations:

    
        void addNum(int num) - Add a integer number from the data stream to the data
            structure.
        
        double findMedian() - Return the median of all elements so far.
    

     

    Example:

    addNum(1)
addNum(2)
findMedian() -> 1.5
addNum(3)
findMedian() -> 2

     

    Follow up:

    
        If all integer numbers from the stream are between 0 and 100, how would you
            optimize it?
        
        If 99% of all integer numbers from the stream are between 0 and 100, how would you
            optimize it?
-----------------

# 972_Equal_Rational_Numbers
# 972. Equal Rational Numbers

Given two strings S and T, each of which represents a non-negative
        rational number, return True if and only if they represent the same number.
        The strings may use parentheses to denote the repeating part of the rational number.

    In general a rational number can be represented using up to three parts: an integer
        part, a non-repeating part, and a repeating part. The
        number will be represented in one of the following three ways:

    
        <IntegerPart> (e.g. 0, 12, 123)
        <IntegerPart><.><NonRepeatingPart>  (e.g. 0.5, 1.,
            2.12, 2.0001)
        
        <IntegerPart><.><NonRepeatingPart><(><RepeatingPart><)>
            (e.g. 0.1(6), 0.9(9), 0.00(1212))
        
    

    The repeating portion of a decimal expansion is conventionally denoted within a pair of round
        brackets.  For example:

    1 / 6 = 0.16666666... = 0.1(6) = 0.1666(6) = 0.166(66)

    Both 0.1(6) or 0.1666(6) or 0.166(66) are correct representations of 1 / 6.

     

    Example 1:

    Input: S = "0.(52)", T = "0.5(25)"
Output: true
Explanation:
Because "0.(52)" represents 0.52525252..., and "0.5(25)" represents 0.52525252525..... , the strings represent the same number.
-----------------

# 1406_Stone_Game_III
# 1406. Stone Game III


-----------------

# 986_Interval_List_Intersections
# 986. Interval List Intersections

Given two lists of closed intervals, each list of intervals is pairwise
        disjoint and in sorted order.

    Return the intersection of these two interval lists.

    (Formally, a closed interval [a, b] (with a <= b) denotes the
        set of real numbers x with a <= x <= b.  The intersection
        of two closed intervals is a set of real numbers that is either empty, or can be represented
        as a closed interval.  For example, the intersection of [1, 3] and [2, 4] is [2,
        3].)
-----------------

# 608_Tree_Node
# 608. Tree Node

Given a table tree, id is identifier of the tree node and p_id is
        its parent node's id.

    +----+------+
| id | p_id |
+----+------+
| 1  | null |
| 2  | 1    |
| 3  | 1    |
| 4  | 2    |
| 5  | 2    |
+----+------+

    Each node in the tree can be one of three types:

    
        Leaf: if the node is a leaf node.
        Root: if the node is the root of the tree.
        Inner: If the node is neither a leaf node nor a root node.
    

     
    Write a query to print the node id and the type of the node. Sort your output by the node id.
    The result for the above sample is:

     

    +----+------+
| id | Type |
+----+------+
| 1  | Root |
| 2  | Inner|
| 3  | Leaf |
| 4  | Leaf |
| 5  | Leaf |
+----+------+

     

    Explanation

     

    
        Node '1' is root node, because its parent node is NULL and it has child node
            '2' and '3'.
        
        Node '2' is inner node, because it has parent node '1' and child node
            '4' and '5'.
        
        Node '3', '4' and '5' is Leaf node, because they have parent
            node and they don't have child node.
        
        
        And here is the image of the sample tree as below:
             

            			  1
			/   \
                      2       3
                    /   \
                  4       5

            Note

            If there is only one node on the tree, you only need to output its root
                attributes.
-----------------

# 1812_Determine_Color_of_a_Chessboard_Square
# 1812. Determine Color of a Chessboard Square


-----------------

# 762_Prime_Number_of_Set_Bits_in_Binary_Representation
# 762. Prime Number of Set Bits in Binary Representation

Given two integers L and R, find the count of numbers in the range
        [L, R] (inclusive) having a prime number of set bits in their binary
        representation.
    
    
        (Recall that the number of set bits an integer has is the number of 1s present
        when written in binary. For example, 21 written in binary is 10101
        which has 3 set bits. Also, 1 is not a prime.)
    
    

    Example 1:
    Input: L = 6, R = 10
Output: 4
Explanation:
6 -> 110 (2 set bits, 2 is prime)
7 -> 111 (3 set bits, 3 is prime)
9 -> 1001 (2 set bits , 2 is prime)
10->1010 (2 set bits , 2 is prime)

    

    Example 2:
    Input: L = 10, R = 15
Output: 5
Explanation:
10 -> 1010 (2 set bits, 2 is prime)
11 -> 1011 (3 set bits, 3 is prime)
12 -> 1100 (2 set bits, 2 is prime)
13 -> 1101 (3 set bits, 3 is prime)
14 -> 1110 (3 set bits, 3 is prime)
15 -> 1111 (4 set bits, 4 is not prime)

    

    Note:
    
        L, R will be integers L <= R in the range [1,
            10^6].
        
        R - L will be at most 10000.
-----------------

# 1855_Maximum_Distance_Between_a_Pair_of_Values
# 1855. Maximum Distance Between a Pair of Values


-----------------

# 1604_Alert_Using_Same_Key-Card_Three_or_More_Times_in_a_One_Hour_Period
# 1604. Alert Using Same Key-Card Three or More Times in a One Hour Period


-----------------

# 219_Contains_Duplicate_II
# 219. Contains Duplicate II

Given an array of integers and an integer k, find out whether there are two distinct
        indices i and j in the array such that nums[i] = nums[j] and the absolute
        difference between i and j is at most k.
-----------------

# 1306_Jump_Game_III
# 1306. Jump Game III


-----------------

# 599_Minimum_Index_Sum_of_Two_Lists
# 599. Minimum Index Sum of Two Lists

Suppose Andy and Doris want to choose a restaurant for dinner, and they both have a list of
        favorite restaurants represented by strings.
    
    
        You need to help them find out their common interest with the least list index
        sum. If there is a choice tie between answers, output all of them with no order
        requirement. You could assume there always exists an answer.
    

    Example 1:
    Input:
["Shogun", "Tapioca Express", "Burger King", "KFC"]
["Piatti", "The Grill at Torrey Pines", "Hungry Hunter Steakhouse", "Shogun"]
Output: ["Shogun"]
Explanation: The only restaurant they both like is "Shogun".

    

    Example 2:
    Input:
["Shogun", "Tapioca Express", "Burger King", "KFC"]
["KFC", "Shogun", "Burger King"]
Output: ["Shogun"]
Explanation: The restaurant they both like and have the least index sum is "Shogun" with index sum 1 (0+1).

    

    Note:
    
        The length of both lists will be in the range of [1, 1000].
        The length of strings in both lists will be in the range of [1, 30].
        The index is starting from 0 to the list length minus 1.
        No duplicates in both lists.
-----------------

# 1237_Find_Positive_Integer_Solution_for_a_Given_Equation
# 1237. Find Positive Integer Solution for a Given Equation

Given a function  f(x, y) and a value z, return all
        positive integer pairs x and y where f(x,y) == z.
    

    The function is constantly increasing, i.e.:

    
        f(x, y) < f(x + 1, y)
        f(x, y) < f(x, y + 1)
    

    The function interface is defined like this: 

    interface CustomFunction {
public:
  // Returns positive integer f(x, y) for any given positive integer x and y.
  int f(int x, int y);
};

    For custom testing purposes you're given an integer function_id and a target
        z as input, where function_id represent one function from an
        secret internal list, on the examples you'll know only two functions from the list.
         

    You may return the solutions in any order.

     
    Example 1:

    Input: function_id = 1, z = 5
Output: [[1,4],[2,3],[3,2],[4,1]]
Explanation: function_id = 1 means that f(x, y) = x + y

    Example 2:

    Input: function_id = 2, z = 5
Output: [[1,5],[5,1]]
Explanation: function_id = 2 means that f(x, y) = x * y

     
    Constraints:

    
        1 <= function_id <= 9
        1 <= z <= 100
        It's guaranteed that the solutions of f(x, y) == z will be on the range
            1 <= x, y <= 1000
        It's also guaranteed that f(x, y) will fit in 32 bit signed integer if
            1 <= x, y <= 1000
-----------------

# 567_Permutation_in_String
# 567. Permutation in String

Given two strings s1 and s2, write a function to return true if s2
        contains the permutation of s1. In other words, one of the first string's
        permutations is the substring of the second string.

     

    Example 1:

    Input: s1 = "ab" s2 = "eidbaooo"
Output: True
Explanation: s2 contains one permutation of s1 ("ba").

    Example 2:

    Input:s1= "ab" s2 = "eidboaoo"
Output: False

     

    Note:

    
        The input strings only contain lower case letters.
        The length of both given strings is in range [1, 10,000].
-----------------

# 1157_Online_Majority_Element_In_Subarray
# 1157. Online Majority Element In Subarray

Implementing the class MajorityChecker, which has the following API:

    
        MajorityChecker(int[] arr) constructs an instance of MajorityChecker with
            the given array arr;
        
        int query(int left, int right, int threshold) has arguments such
            that:
            
                0 <= left <= right < arr.length representing a
                    subarray of arr;
                
                2 * threshold > right - left + 1, ie. the threshold is always a
                    strict majority of the length of the subarray
                
            
        
    

    Each query(...) returns the element in arr[left], arr[left+1], ...,
        arr[right] that occurs at least threshold times, or -1 if
        no such element exists.

     

    Example:

    MajorityChecker majorityChecker = new MajorityChecker([1,1,2,2,1,1]);
majorityChecker.query(0,5,4); // returns 1
majorityChecker.query(0,3,3); // returns -1
majorityChecker.query(2,3,2); // returns 2

     
    Constraints:

    
        1 <= arr.length <= 20000
        1 <= arr[i] <= 20000
        For each query, 0 <= left <= right < len(arr)
        For each query, 2 * threshold > right - left + 1
        The number of queries is at most 10000
-----------------

# 1726_Tuple_with_Same_Product
# 1726. Tuple with Same Product


-----------------

# 1556_Thousand_Separator
# 1556. Thousand Separator


-----------------

# 232_Implement_Queue_using_Stacks
# 232. Implement Queue using Stacks

Implement the following operations of a queue using stacks.

    
        push(x) -- Push element x to the back of queue.
        pop() -- Removes the element from in front of queue.
        peek() -- Get the front element.
        empty() -- Return whether the queue is empty.
    

    Example:

    MyQueue queue = new MyQueue();

queue.push(1);
queue.push(2);
queue.peek();  // returns 1
queue.pop();   // returns 1
queue.empty(); // returns false

    Notes:

    
        You must use only standard operations of a stack -- which means only push
            to top, peek/pop from top, size, and is
            empty operations are valid.
        
        Depending on your language, stack may not be supported natively. You may simulate a
            stack by using a list or deque (double-ended queue), as long as you use only standard
            operations of a stack.
        
        You may assume that all operations are valid (for example, no pop or peek operations
            will be called on an empty queue).
-----------------

# 1287_Element_Appearing_More_Than_25%_In_Sorted_Array
# 1287. Element Appearing More Than 25% In Sorted Array


-----------------

# 1507_Reformat_Date
# 1507. Reformat Date


-----------------

# 579_Find_Cumulative_Salary_of_an_Employee
# 579. Find Cumulative Salary of an Employee

The Employee table holds the salary information in a year.

    Write a SQL to get the cumulative sum of an employee's salary over a period of 3 months
        but exclude the most recent month.

    The result should be displayed by 'Id' ascending, and then by 'Month'
        descending.

    Example
        Input

    | Id | Month | Salary |
|----|-------|--------|
| 1  | 1     | 20     |
| 2  | 1     | 20     |
| 1  | 2     | 30     |
| 2  | 2     | 30     |
| 3  | 2     | 40     |
| 1  | 3     | 40     |
| 3  | 3     | 60     |
| 1  | 4     | 60     |
| 3  | 4     | 70     |

    Output

    
| Id | Month | Salary |
|----|-------|--------|
| 1  | 3     | 90     |
| 1  | 2     | 50     |
| 1  | 1     | 20     |
| 2  | 1     | 20     |
| 3  | 3     | 100    |
| 3  | 2     | 40     |

     
    Explanation

    Employee '1' has 3 salary records for the following 3 months except the most recent
        month '4': salary 40 for month '3', 30 for month '2' and 20 for
        month '1'
        So the cumulative sum of salary of this employee over 3 months is 90(40+30+20), 50(30+20)
        and 20 respectively.

    | Id | Month | Salary |
|----|-------|--------|
| 1  | 3     | 90     |
| 1  | 2     | 50     |
| 1  | 1     | 20     |

    Employee '2' only has one salary record (month '1') except its most recent month
    '2'.

    | Id | Month | Salary |
|----|-------|--------|
| 2  | 1     | 20     |

     
    Employ '3' has two salary records except its most recent pay month '4': month
    '3' with 60 and month '2' with 40. So the cumulative salary is as following.

    | Id | Month | Salary |
|----|-------|--------|
| 3  | 3     | 100    |
| 3  | 2     | 40     |
-----------------

# 453_Minimum_Moves_to_Equal_Array_Elements
# 453. Minimum Moves to Equal Array Elements

Given a non-empty integer array of size n, find the minimum number of moves
        required to make all array elements equal, where a move is incrementing n - 1
        elements by 1.

    Example:
    Input:
[1,2,3]

Output:
3

Explanation:
Only three moves are needed (remember each move increments two elements):

[1,2,3]  =>  [2,3,3]  =>  [3,4,3]  =>  [4,4,4]
-----------------

# 1671_Minimum_Number_of_Removals_to_Make_Mountain_Array
# 1671. Minimum Number of Removals to Make Mountain Array


-----------------

# 772_Basic_Calculator_III
# 772. Basic Calculator III

Implement a basic calculator to evaluate a simple expression string.

    The expression string may contain open ( and closing parentheses ),
        the plus + or minus sign -, non-negative integers
        and empty spaces  .

    The expression string contains only non-negative integers, +, -,
        *, / operators , open ( and closing parentheses
        ) and empty spaces  . The integer division should truncate toward
        zero.

    You may assume that the given expression is always valid. All intermediate results will be in
        the range of [-2147483648, 2147483647].

    Some examples:

    "1 + 1" = 2
" 6-4 / 2 " = 4
"2*(5+5*2)/3+(6/2+8)" = 21
"(2+6* 3+5- (3*14/7+2)*5)+3"=-12

     

    Note: Do not use the eval built-in library
        function.
-----------------

# 141_Linked_List_Cycle
# 141. Linked List Cycle

Given a linked list, determine if it has a cycle in it.

    To represent a cycle in the given linked list, we use an integer pos which
        represents the position (0-indexed) in the linked list where tail connects to. If
        pos is -1, then there is no cycle in the linked list.
-----------------

# 131_Palindrome_Partitioning
# 131. Palindrome Partitioning

Given a string s, partition s such that every substring of the partition is
        a palindrome.

    Return all possible palindrome partitioning of s.

    Example:

    Input: "aab"
Output:
[
  ["aa","b"],
  ["a","a","b"]
]
-----------------

# 1251_Average_Selling_Price
# 1251. Average Selling Price

Table: Prices

    +---------------+---------+
| Column Name   | Type    |
+---------------+---------+
| product_id    | int     |
| start_date    | date    |
| end_date      | date    |
| price         | int     |
+---------------+---------+
(product_id, start_date, end_date) is the primary key for this table.
Each row of this table indicates the price of the product_id in the period from start_date to end_date.
For each product_id there will be no two overlapping periods. That means there will be no two intersecting periods for the same product_id.

     

    Table: UnitsSold

    +---------------+---------+
| Column Name   | Type    |
+---------------+---------+
| product_id    | int     |
| purchase_date | date    |
| units         | int     |
+---------------+---------+
There is no primary key for this table, it may contain duplicates.
Each row of this table indicates the date, units and product_id of each product sold.

     

    Write an SQL query to find the average selling price for each product.

    average_price should be rounded to 2 decimal places.
    

    The query result format is in the following example:

    Prices table:
+------------+------------+------------+--------+
| product_id | start_date | end_date   | price  |
+------------+------------+------------+--------+
| 1          | 2019-02-17 | 2019-02-28 | 5      |
| 1          | 2019-03-01 | 2019-03-22 | 20     |
| 2          | 2019-02-01 | 2019-02-20 | 15     |
| 2          | 2019-02-21 | 2019-03-31 | 30     |
+------------+------------+------------+--------+

UnitsSold table:
+------------+---------------+-------+
| product_id | purchase_date | units |
+------------+---------------+-------+
| 1          | 2019-02-25    | 100   |
| 1          | 2019-03-01    | 15    |
| 2          | 2019-02-10    | 200   |
| 2          | 2019-03-22    | 30    |
+------------+---------------+-------+

Result table:
+------------+---------------+
| product_id | average_price |
+------------+---------------+
| 1          | 6.96          |
| 2          | 16.96         |
+------------+---------------+
Average selling price = Total Price of Product / Number of products sold.
Average selling price for product 1 = ((100 * 5) + (15 * 20)) / 115 = 6.96
Average selling price for product 2 = ((200 * 15) + (30 * 30)) / 230 = 16.96
-----------------

# 677_Map_Sum_Pairs
# 677. Map Sum Pairs

Implement a MapSum class with insert, and sum methods.
    

    
        For the method insert, you'll be given a pair of (string, integer). The string
        represents the key and the integer represents the value. If the key already existed, then
        the original key-value pair will be overridden to the new one.
    

    
        For the method sum, you'll be given a string representing the prefix, and you
        need to return the sum of all the pairs' value whose key starts with the prefix.
    

    Example 1:
    Input: insert("apple", 3), Output: Null
Input: sum("ap"), Output: 3
Input: insert("app", 2), Output: Null
Input: sum("ap"), Output: 5
-----------------

# 992_Subarrays_with_K_Different_Integers
# 992. Subarrays with K Different Integers

Given an array A of positive integers, call a (contiguous, not necessarily
        distinct) subarray of A good if the number of different integers in
        that subarray is exactly K.

    (For example, [1,2,3,1,2] has 3 different integers: 1,
        2, and 3.)

    Return the number of good subarrays of A.

     

    Example 1:

    Input: A = [1,2,1,2,3], K = 2
Output: 7
Explanation: Subarrays formed with exactly 2 different integers: [1,2], [2,1], [1,2], [2,3], [1,2,1], [2,1,2], [1,2,1,2].

    Example 2:

    Input: A = [1,2,1,3,4], K = 3
Output: 3
Explanation: Subarrays formed with exactly 3 different integers: [1,2,1,3], [2,1,3], [1,3,4].

     

    Note:

    
        1 <= A.length <= 20000
        1 <= A[i] <= A.length
        1 <= K <= A.length
-----------------

# 702_Search_in_a_Sorted_Array_of_Unknown_Size
# 702. Search in a Sorted Array of Unknown Size

Given an integer array sorted in ascending order, write a function to search target
        in nums.  If target exists, then return its index, otherwise
        return -1. However, the array size is unknown to you. You may
        only access the array using an ArrayReader interface, where ArrayReader.get(k)
        returns the element of the array at index k (0-indexed).

    You may assume all integers in the array are less than 10000, and if you
        access the array out of bounds, ArrayReader.get will return
        2147483647.

     

    Example 1:

    Input: array = [-1,0,3,5,9,12], target = 9
Output: 4
Explanation: 9 exists in nums and its index is 4

    Example 2:

    Input: array = [-1,0,3,5,9,12], target = 2
Output: -1
Explanation: 2 does not exist in nums so return -1

     

    Note:

    
        You may assume that all elements in the array are unique.
        The value of each element in the array will be in the range [-9999,
            9999].
-----------------

# 40_Combination_Sum_II
# 40. Combination Sum II

Given a collection of candidate numbers (candidates) and a target number (target),
        find all unique combinations in candidates where the candidate numbers
        sums to target.

    Each number in candidates may only be used once in the
        combination.

    Note:

    
        All numbers (including target) will be positive integers.
        The solution set must not contain duplicate combinations.
    

    Example 1:

    Input: candidates = [10,1,2,7,6,1,5], target = 8,
A solution set is:
[
  [1, 7],
  [1, 2, 5],
  [2, 6],
  [1, 1, 6]
]

    Example 2:

    Input: candidates = [2,5,2,1,2], target = 5,
A solution set is:
[
  [1,2,2],
  [5]
]
-----------------

# 156_Binary_Tree_Upside_Down
# 156. Binary Tree Upside Down

Given a binary tree where all the right nodes are either leaf nodes with a sibling (a left
        node that shares the same parent node) or empty, flip it upside down and turn it into a tree
        where the original right nodes turned into left leaf nodes. Return the new root.

    Example:

    Input: [1,2,3,4,5]

    1
   / \
  2   3
 / \
4   5

Output: return the root of the binary tree [4,5,2,#,#,3,1]

   4
  / \
 5   2
    / \
   3   1

    Clarification:

    Confused what [4,5,2,#,#,3,1] means? Read
        more below on how binary tree is serialized on OJ.

    The serialization of a binary tree follows a level order traversal, where '#'
        signifies a path terminator where no node exists below.

    Here's an example:

       1
  / \
 2   3
    /
   4
    \
     5

    The above binary tree is serialized as [1,2,3,#,#,4,#,#,5].
-----------------

# 1425_Constrained_Subset_Sum
# 1425. Constrained Subset Sum


-----------------

# 841_Keys_and_Rooms
# 841. Keys and Rooms

There are N rooms and you start in room 0.  Each room has a
        distinct number in 0, 1, 2, ..., N-1, and each room may have some keys to
        access the next room. 

    Formally, each room i has a list of keys rooms[i], and each
        key rooms[i][j] is an integer in [0, 1, ..., N-1] where N =
            rooms.length.  A key rooms[i][j] = v opens the room with
        number v.

    Initially, all the rooms start locked (except for room 0). 

    You can walk back and forth between rooms freely.

    Return true if and only if you can enter every room.

    
    

    Example 1:

    Input: [[1],[2],[3],[]]
Output: true
Explanation:  
We start in room 0, and pick up key 1.
We then go to room 1, and pick up key 2.
We then go to room 2, and pick up key 3.
We then go to room 3.  Since we were able to go to every room, we return true.

    Example 2:

    Input: [[1,3],[3,0,1],[2],[0]]
Output: false
Explanation: We can't enter the room with number 2.

    Note:

    
        1 <= rooms.length <= 1000
        0 <= rooms[i].length <= 1000
        The number of keys in all rooms combined is at most 3000.
-----------------

# 1791_Find_Center_of_Star_Graph
# 1791. Find Center of Star Graph


-----------------

# 314_Binary_Tree_Vertical_Order_Traversal
# 314. Binary Tree Vertical Order Traversal

Given a binary tree, return the vertical order traversal of its nodes' values.
        (ie, from top to bottom, column by column).

    If two nodes are in the same row and column, the order should be from left to right.
    

    Examples 1:

    Input: [3,9,20,null,null,15,7]

   3
  /\
 /  \
 9  20
    /\
   /  \
  15   7

Output:

[
  [9],
  [3,15],
  [20],
  [7]
]

    Examples 2:

    Input: [3,9,8,4,0,1,7]

     3
    /\
   /  \
   9   8
  /\  /\
 /  \/  \
 4  01   7

Output:

[
  [4],
  [9],
  [3,0,1],
  [8],
  [7]
]

    Examples 3:

    Input: [3,9,8,4,0,1,7,null,null,null,2,5] (0's right child is 2 and 1's left child is 5)

     3
    /\
   /  \
   9   8
  /\  /\
 /  \/  \
 4  01   7
    /\
   /  \
   5   2

Output:

[
  [4],
  [9,5],
  [3,0,1],
  [8,2],
  [7]
]
-----------------

# 1220_Count_Vowels_Permutation
# 1220. Count Vowels Permutation

Given an integer n, your task is to count how many strings of length
        n can be formed under the following rules:

    
        Each character is a lower case vowel ('a',
            'e', 'i', 'o', 'u')
        
        Each vowel 'a' may only be followed by an
            'e'.
        
        Each vowel 'e' may only be followed by an
            'a' or an 'i'.
        
        Each vowel 'i' may not be followed by another
            'i'.
        
        Each vowel 'o' may only be followed by an
            'i' or a 'u'.
        
        Each vowel 'u' may only be followed by an
            'a'.
    

    Since the answer may be too large, return it modulo 10^9 + 7.

     
    Example 1:

    Input: n = 1
Output: 5
Explanation: All possible strings are: "a", "e", "i" , "o" and "u".

    Example 2:

    Input: n = 2
Output: 10
Explanation: All possible strings are: "ae", "ea", "ei", "ia", "ie", "io", "iu", "oi", "ou" and "ua".

    Example 3: 

    Input: n = 5
Output: 68

     
    Constraints:

    
        1 <= n <= 2 * 10^4
-----------------

# 1613_Find_the_Missing_IDs
# 1613. Find the Missing IDs


-----------------

# 154_Find_Minimum_in_Rotated_Sorted_Array_II
# 154. Find Minimum in Rotated Sorted Array II

Suppose an array sorted in ascending order is rotated at some pivot unknown to you
        beforehand.

    (i.e.,  [0,1,2,4,5,6,7] might become
         [4,5,6,7,0,1,2]).

    Find the minimum element.

    The array may contain duplicates.

    Example 1:

    Input: [1,3,5]
Output: 1

    Example 2:

    Input: [2,2,2,0,1]
Output: 0

    Note:

    
        This is a follow up problem to Find
            Minimum in Rotated Sorted Array.
        
        Would allow duplicates affect the run-time complexity? How and why?
-----------------

# 1535_Find_the_Winner_of_an_Array_Game
# 1535. Find the Winner of an Array Game


-----------------

# 1336_Number_of_Transactions_per_Visit
# 1336. Number of Transactions per Visit


-----------------

# 146_LRU_Cache
# 146. LRU Cache

Design and implement a data structure for Least
        Recently Used (LRU) cache. It should support the following operations: get
        and put.

    get(key) - Get the value (will always be positive) of the key if the key exists
        in the cache, otherwise return -1.
        put(key, value) - Set or insert the value if the key is not already present.
        When the cache reached its capacity, it should invalidate the least recently used item
        before inserting a new item.

    The cache is initialized with a positive capacity.

    Follow up:
        Could you do both operations in O(1) time complexity?

    Example:

    LRUCache cache = new LRUCache( 2 /* capacity */ );

cache.put(1, 1);
cache.put(2, 2);
cache.get(1);       // returns 1
cache.put(3, 3);    // evicts key 2
cache.get(2);       // returns -1 (not found)
cache.put(4, 4);    // evicts key 1
cache.get(1);       // returns -1 (not found)
cache.get(3);       // returns 3
cache.get(4);       // returns 4
-----------------

# 1722_Minimize_Hamming_Distance_After_Swap_Operations
# 1722. Minimize Hamming Distance After Swap Operations


-----------------

# 1685_Sum_of_Absolute_Differences_in_a_Sorted_Array
# 1685. Sum of Absolute Differences in a Sorted Array


-----------------

# 176_Second_Highest_Salary
# 176. Second Highest Salary

Write a SQL query to get the second highest salary from the Employee table.

    +----+--------+
| Id | Salary |
+----+--------+
| 1  | 100    |
| 2  | 200    |
| 3  | 300    |
+----+--------+

    For example, given the above Employee table, the query should return 200 as the
        second highest salary. If there is no second highest salary, then the query should return
        null.

    +---------------------+
| SecondHighestSalary |
+---------------------+
| 200                 |
+---------------------+
-----------------

# 929_Unique_Email_Addresses
# 929. Unique Email Addresses

Every email consists of a local name and a domain name, separated by the @ sign.

    For example, in alice@leetcode.com, alice is the local name,
        and leetcode.com is the domain name.

    Besides lowercase letters, these emails may contain '.'s or '+'s.
    

    If you add periods ('.') between some characters in the local
        name part of an email address, mail sent there will be forwarded to the same
        address without dots in the local name.  For example, "alice.z@leetcode.com"
        and "alicez@leetcode.com" forward to the same email address. 
        (Note that this rule does not apply for domain names.)

    If you add a plus ('+') in the local name, everything
        after the first plus sign will be ignored. This allows certain emails
        to be filtered, for example m.y+name@email.com will be forwarded to my@email.com. 
        (Again, this rule does not apply for domain names.)

    It is possible to use both of these rules at the same time.

    Given a list of emails, we send one email to each address in the list.  How
        many different addresses actually receive mails?
-----------------

# 129_Sum_Root_to_Leaf_Numbers
# 129. Sum Root to Leaf Numbers

Given a binary tree containing digits from 0-9 only, each root-to-leaf path
        could represent a number.

    An example is the root-to-leaf path 1->2->3 which represents the number
        123.

    Find the total sum of all root-to-leaf numbers.

    Note: A leaf is a node with no children.

    Example:

    Input: [1,2,3]
    1
   / \
  2   3
Output: 25
Explanation:
The root-to-leaf path 1->2 represents the number 12.
The root-to-leaf path 1->3 represents the number 13.
Therefore, sum = 12 + 13 = 25.

    Example 2:

    Input: [4,9,0,5,1]
    4
   / \
  9   0
 / \
5   1
Output: 1026
Explanation:
The root-to-leaf path 4->9->5 represents the number 495.
The root-to-leaf path 4->9->1 represents the number 491.
The root-to-leaf path 4->0 represents the number 40.
Therefore, sum = 495 + 491 + 40 = 1026.
-----------------

# 1558_Minimum_Numbers_of_Function_Calls_to_Make_Target_Array
# 1558. Minimum Numbers of Function Calls to Make Target Array


-----------------

# 639_Decode_Ways_II
# 639. Decode Ways II

A message containing letters from A-Z is being encoded to numbers using the
        following mapping way:
    

    'A' -> 1
'B' -> 2
...
'Z' -> 26

    
        Beyond that, now the encoded string can also contain the character '*', which can be treated
        as one of the numbers from 1 to 9.
    

    
        Given the encoded message containing digits and the character '*', return the total number
        of ways to decode it.
    

    
        Also, since the answer may be very large, you should return the output mod 109 +
        7.
    

    Example 1:
    Input: "*"
Output: 9
Explanation: The encoded message can be decoded to the string: "A", "B", "C", "D", "E", "F", "G", "H", "I".

    

    Example 2:
    Input: "1*"
Output: 9 + 9 = 18

    

    Note:
    
        The length of the input string will fit in range [1, 105].
        The input string will only contain the character '*' and digits '0' - '9'.
-----------------

# 1773_Count_Items_Matching_a_Rule
# 1773. Count Items Matching a Rule


-----------------

# 433_Minimum_Genetic_Mutation
# 433. Minimum Genetic Mutation

A gene string can be represented by an 8-character long string, with choices from "A",
        "C", "G", "T".

    Suppose we need to investigate about a mutation (mutation from "start" to "end"),
        where ONE mutation is defined as ONE single character changed in the gene string.

    For example, "AACCGGTT" -> "AACCGGTA" is 1
        mutation.

    Also, there is a given gene "bank", which records all the valid gene mutations. A
        gene must be in the bank to make it a valid gene string.

    Now, given 3 things - start, end, bank, your task is to determine what is the minimum number
        of mutations needed to mutate from "start" to "end". If there is no such
        a mutation, return -1.

    Note:

    
        Starting point is assumed to be valid, so it might not be included in the bank.
        If multiple mutations are needed, all mutations during in the sequence must be valid.
        
        You may assume start and end string is not the same.
    

     

    Example 1:

    start: "AACCGGTT"
end:   "AACCGGTA"
bank: ["AACCGGTA"]

return: 1

     

    Example 2:

    start: "AACCGGTT"
end:   "AAACGGTA"
bank: ["AACCGGTA", "AACCGCTA", "AAACGGTA"]

return: 2

     

    Example 3:

    start: "AAAAACCC"
end:   "AACCCCCC"
bank: ["AAAACCCC", "AAACCCCC", "AACCCCCC"]

return: 3
-----------------

# 581_Shortest_Unsorted_Continuous_Subarray
# 581. Shortest Unsorted Continuous Subarray

Given an integer array, you need to find one continuous subarray that if you only sort
        this subarray in ascending order, then the whole array will be sorted in ascending order,
        too. 

    You need to find the shortest such subarray and output its length.

    Example 1:
    Input: [2, 6, 4, 8, 10, 9, 15]
Output: 5
Explanation: You need to sort [6, 4, 8, 10, 9] in ascending order to make the whole array sorted in ascending order.

    

    Note:
    
        Then length of the input array is in range [1, 10,000].
        The input array may contain duplicates, so ascending order here means <=.
-----------------

# 34_Find_First_and_Last_Position_of_Element_in_Sorted_Array
# 34. Find First and Last Position of Element in Sorted Array

Given an array of integers nums sorted in ascending order, find the starting and
        ending position of a given target value.

    Your algorithm's runtime complexity must be in the order of O(log n).
    

    If the target is not found in the array, return [-1, -1].

    Example 1:

    Input: nums = [5,7,7,8,8,10], target = 8
Output: [3,4]

    Example 2:

    Input: nums = [5,7,7,8,8,10], target = 6
Output: [-1,-1]
-----------------

# 794_Valid_Tic-Tac-Toe_State
# 794. Valid Tic-Tac-Toe State

A Tic-Tac-Toe board is given as a string array board. Return True if and only if
        it is possible to reach this board position during the course of a valid tic-tac-toe game.
    

    The board is a 3 x 3 array, and consists of characters "
        ", "X", and "O".  The "
        " character represents an empty square.

    Here are the rules of Tic-Tac-Toe:

    
        Players take turns placing characters into empty squares (" ").
        The first player always places "X" characters, while the second player always
            places "O" characters.
        
        "X" and "O" characters are always placed into empty squares, never
            filled ones.
        
        The game ends when there are 3 of the same (non-empty) character filling any row,
            column, or diagonal.
        
        The game also ends if all squares are non-empty.
        No more moves can be played if the game is over.
    

    Example 1:
Input: board = ["O  ", "   ", "   "]
Output: false
Explanation: The first player always plays "X".

Example 2:
Input: board = ["XOX", " X ", "   "]
Output: false
Explanation: Players take turns making moves.

Example 3:
Input: board = ["XXX", "   ", "OOO"]
Output: false

Example 4:
Input: board = ["XOX", "O O", "XOX"]
Output: true

    Note:

    
        board is a length-3 array of strings, where each string
            board[i] has length 3.
        
        Each board[i][j] is a character in the set {" ", "X",
            "O"}.
-----------------

# 60_Permutation_Sequence
# 60. Permutation Sequence

The set [1,2,3,...,n] contains a total of n! unique
        permutations.

    By listing and labeling all of the permutations in order, we get the following sequence for
        n = 3:

    
        "123"
        "132"
        "213"
        "231"
        "312"
        "321"
    

    Given n and k, return the kth permutation sequence.

    Note:

    
        Given n will be between 1 and 9 inclusive.
        Given k will be between 1 and n! inclusive.
    

    Example 1:

    Input: n = 3, k = 3
Output: "213"

    Example 2:

    Input: n = 4, k = 9
Output: "2314"
-----------------

# 1050_Actors_and_Directors_Who_Cooperated_At_Least_Three_Times
# 1050. Actors and Directors Who Cooperated At Least Three Times

Table: ActorDirector

    +-------------+---------+
| Column Name | Type    |
+-------------+---------+
| actor_id    | int     |
| director_id | int     |
| timestamp   | int     |
+-------------+---------+
timestamp is the primary key column for this table.

     

    Write a SQL query for a report that provides the pairs (actor_id, director_id)
        where the actor have cooperated with the director at least 3 times.

    Example:

    ActorDirector table:
+-------------+-------------+-------------+
| actor_id    | director_id | timestamp   |
+-------------+-------------+-------------+
| 1           | 1           | 0           |
| 1           | 1           | 1           |
| 1           | 1           | 2           |
| 1           | 2           | 3           |
| 1           | 2           | 4           |
| 2           | 1           | 5           |
| 2           | 1           | 6           |
+-------------+-------------+-------------+

Result table:
+-------------+-------------+
| actor_id    | director_id |
+-------------+-------------+
| 1           | 1           |
+-------------+-------------+
The only pair is (1, 1) where they cooperated exactly 3 times.
-----------------

# 410_Split_Array_Largest_Sum
# 410. Split Array Largest Sum

Given an array which consists of non-negative integers and an integer m, you can split
        the array into m non-empty continuous subarrays. Write an algorithm to minimize the
        largest sum among these m subarrays.
    

    Note:
        If n is the length of array, assume the following constraints are satisfied:
    
        1 ≤ n ≤ 1000
        1 ≤ m ≤ min(50, n)
    
    

    Examples: 
    Input:
nums = [7,2,5,10,8]
m = 2

Output:
18

Explanation:
There are four ways to split nums into two subarrays.
The best way is to split it into [7,2,5] and [10,8],
where the largest sum among the two subarrays is only 18.
-----------------

# 383_Ransom_Note
# 383. Ransom Note

Given an arbitrary ransom note string and another string containing letters from all the
        magazines, write a function that will return true if the ransom
        note can be constructed from the magazines ; otherwise, it will return false.
    
    
        Each letter in the magazine string can only be used once in your ransom note.
    

    Note:
        You may assume that both strings contain only lowercase letters.
    

    canConstruct("a", "b") -> false
canConstruct("aa", "ab") -> false
canConstruct("aa", "aab") -> true
-----------------

# 267_Palindrome_Permutation_II
# 267. Palindrome Permutation II

Given a string s, return all the palindromic permutations (without duplicates)
        of it. Return an empty list if no palindromic permutation could be form.

    Example 1:

    Input: "aabb"
Output: ["abba", "baab"]

    Example 2:

    Input: "abc"
Output: []
-----------------

# 270_Closest_Binary_Search_Tree_Value
# 270. Closest Binary Search Tree Value

Given a non-empty binary search tree and a target value, find the value in the BST that is
        closest to the target.

    Note:

    
        Given target value is a floating point.
        You are guaranteed to have only one unique value in the BST that is closest to the
            target.
        
    

    Example:

    Input: root = [4,2,5,1,3], target = 3.714286

    4
   / \
  2   5
 / \
1   3

Output: 4
-----------------

# 700_Search_in_a_Binary_Search_Tree
# 700. Search in a Binary Search Tree

Given the root node of a binary search tree (BST) and a value. You need to find the node in
        the BST that the node's value equals the given value. Return the subtree rooted with
        that node. If such node doesn't exist, you should return NULL.

    For example, 

    Given the tree:
        4
       / \
      2   7
     / \
    1   3

And the value to search: 2

    You should return this subtree:

          2
     / \
    1   3

    In the example above, if we want to search the value 5, since there is no node
        with value 5, we should return NULL.

    Note that an empty tree is represented by NULL, therefore you would see the
        expected output (serialized tree format) as [], not null.
-----------------

# 959_Regions_Cut_By_Slashes
# 959. Regions Cut By Slashes

In a N x N grid composed of 1 x 1 squares, each 1 x 1 square consists of a
        /, \, or blank space.  These characters divide the square
        into contiguous regions.

    (Note that backslash characters are escaped, so a \ is represented as
        "\\".)

    Return the number of regions.
-----------------

# 796_Rotate_String
# 796. Rotate String

We are given two strings, A and B.

    A shift on A consists of taking string A and moving the
        leftmost character to the rightmost position. For example, if A =
            'abcde', then it will be 'bcdea' after one shift on
        A. Return True if and only if A can become
        B after some number of shifts on A.

    Example 1:
Input: A = 'abcde', B = 'cdeab'
Output: true

Example 2:
Input: A = 'abcde', B = 'abced'
Output: false

    Note:

    
        A and B will have length at most 100.
-----------------

# 1246_Palindrome_Removal
# 1246. Palindrome Removal

Given an integer array arr, in one move you can select a palindromic subarray
        arr[i], arr[i+1], ..., arr[j] where i <= j, and remove
        that subarray from the given array. Note that after removing a subarray, the elements on the
        left and on the right of that subarray move to fill the gap left by the removal.

    Return the minimum number of moves needed to remove all numbers from the array.

     
    Example 1:

    Input: arr = [1,2]
Output: 2

    Example 2:

    Input: arr = [1,3,4,1,5]
Output: 3
Explanation: Remove [4] then remove [1,3,1] then remove [5].

     
    Constraints:

    
        1 <= arr.length <= 100
        1 <= arr[i] <= 20
-----------------

# 255_Verify_Preorder_Sequence_in_Binary_Search_Tree
# 255. Verify Preorder Sequence in Binary Search Tree

Given an array of numbers, verify whether it is the correct preorder traversal sequence of a
        binary search tree.

    You may assume each number in the sequence is unique.

    Consider the following binary search tree: 

         5
    / \
   2   6
  / \
 1   3

    Example 1:

    Input: [5,2,6,1,3]
Output: false

    Example 2:

    Input: [5,2,1,3,6]
Output: true

    Follow up:
        Could you do it using only constant space complexity?
-----------------

# 1011_Capacity_To_Ship_Packages_Within_D_Days
# 1011. Capacity To Ship Packages Within D Days

A conveyor belt has packages that must be shipped from one port to another within
        D days.

    The i-th package on the conveyor belt has a weight of weights[i]. 
        Each day, we load the ship with packages on the conveyor belt (in the order given by weights).
        We may not load more weight than the maximum weight capacity of the ship.

    Return the least weight capacity of the ship that will result in all the packages on the
        conveyor belt being shipped within D days.

     

    Example 1:

    Input: weights = [1,2,3,4,5,6,7,8,9,10], D = 5
Output: 15
Explanation: 
A ship capacity of 15 is the minimum to ship all the packages in 5 days like this:
1st day: 1, 2, 3, 4, 5
2nd day: 6, 7
3rd day: 8
4th day: 9
5th day: 10

Note that the cargo must be shipped in the order given, so using a ship of capacity 14 and splitting the packages into parts like (2, 3, 4, 5), (1, 6, 7), (8), (9), (10) is not allowed.

    Example 2:

    Input: weights = [3,2,2,4,1,4], D = 3
Output: 6
Explanation: 
A ship capacity of 6 is the minimum to ship all the packages in 3 days like this:
1st day: 3, 2
2nd day: 2, 4
3rd day: 1, 4

    Example 3:

    Input: weights = [1,2,3,1,1], D = 4
Output: 3
Explanation: 
1st day: 1
2nd day: 2
3rd day: 3
4th day: 1, 1

     

    Note:

    
        1 <= D <= weights.length <= 50000
        1 <= weights[i] <= 500
-----------------

# 1000_Minimum_Cost_to_Merge_Stones
# 1000. Minimum Cost to Merge Stones

There are N piles of stones arranged in a row.  The i-th pile
        has stones[i] stones.

    A move consists of merging
        exactly K consecutive piles into one pile, and the
        cost of this move is equal to the total number of stones in these K piles.

    Find the minimum cost to merge all piles of stones into one pile.  If it is impossible,
        return -1.
-----------------

# 1124_Longest_Well-Performing_Interval
# 1124. Longest Well-Performing Interval

We are given hours, a list of the number of hours worked per day for a
        given employee.

    A day is considered to be a tiring day if and only if the number of hours worked is
        (strictly) greater than 8.

    A well-performing interval is an interval of days for which the number of tiring
        days is strictly larger than the number of non-tiring days.

    Return the length of the longest well-performing interval.

     
    Example 1:

    Input: hours = [9,9,6,0,6,6,9]
Output: 3
Explanation: The longest well-performing interval is [9,9,6].

     
    Constraints:

    
        1 <= hours.length <= 10000
        0 <= hours[i] <= 16
-----------------

# 1001_Grid_Illumination
# 1001. Grid Illumination

On a N x N grid of cells, each cell (x, y) with 0 <= x
        < N and 0 <= y < N has a lamp.

    Initially, some number of lamps are on.  lamps[i] tells us the location of
        the i-th lamp that is on.  Each lamp that is on illuminates every square
        on its x-axis, y-axis, and both diagonals (similar to a Queen in chess).

    For the i-th query queries[i] = (x, y), the answer to the query is 1 if the
        cell (x, y) is illuminated, else 0.

    After each query (x, y) [in the order given by queries], we turn
        off any lamps that are at cell (x, y) or are adjacent 8-directionally
        (ie., share a corner or edge with cell (x, y).)

    Return an array of answers.  Each value answer[i] should be equal to
        the answer of the i-th query queries[i].

     

    Example 1:

    Input: N = 5, lamps = [[0,0],[4,4]], queries = [[1,1],[1,0]]
Output: [1,0]
Explanation: 
Before performing the first query we have both lamps [0,0] and [4,4] on.
The grid representing which cells are lit looks like this, where [0,0] is the top left corner, and [4,4] is the bottom right corner:
1 1 1 1 1
1 1 0 0 1
1 0 1 0 1
1 0 0 1 1
1 1 1 1 1
Then the query at [1, 1] returns 1 because the cell is lit.  After this query, the lamp at [0, 0] turns off, and the grid now looks like this:
1 0 0 0 1
0 1 0 0 1
0 0 1 0 1
0 0 0 1 1
1 1 1 1 1
Before performing the second query we have only the lamp [4,4] on.  Now the query at [1,0] returns 0, because the cell is no longer lit.

     

    Note:

    
        1 <= N <= 10^9
        0 <= lamps.length <= 20000
        0 <= queries.length <= 20000
        lamps[i].length == queries[i].length == 2
-----------------

# 1601_Maximum_Number_of_Achievable_Transfer_Requests
# 1601. Maximum Number of Achievable Transfer Requests


-----------------

# 1356_Sort_Integers_by_The_Number_of_1_Bits
# 1356. Sort Integers by The Number of 1 Bits


-----------------

# 877_Stone_Game
# 877. Stone Game

Alex and Lee play a game with piles of stones.  There are an even number of piles
        arranged in a row, and each pile has a positive integer number of stones
        piles[i].

    The objective of the game is to end with the most stones.  The total number of
        stones is odd, so there are no ties.

    Alex and Lee take turns, with Alex starting first.  Each turn, a player takes the
        entire pile of stones from either the beginning or the end of the row.  This continues
        until there are no more piles left, at which point the person with the most stones wins.

    Assuming Alex and Lee play optimally, return True if and only if Alex wins
        the game.

     

    Example 1:

    Input: [5,3,4,5]
Output: true
Explanation: 
Alex starts first, and can only take the first 5 or the last 5.
Say he takes the first 5, so that the row becomes [3, 4, 5].
If Lee takes 3, then the board is [4, 5], and Alex takes 5 to win with 10 points.
If Lee takes the last 5, then the board is [3, 4], and Alex takes 4 to win with 9 points.
This demonstrated that taking the first 5 was a winning move for Alex, so we return true.

     

    Note:

    
        2 <= piles.length <= 500
        piles.length is even.
        1 <= piles[i] <= 500
        sum(piles) is odd.
-----------------

# 983_Minimum_Cost_For_Tickets
# 983. Minimum Cost For Tickets

In a country popular for train travel, you have planned some train travelling one year
        in advance.  The days of the year that you will travel is given as an array
        days.  Each day is an integer from 1 to 365.

    Train tickets are sold in 3 different ways:

    
        a 1-day pass is sold for costs[0] dollars;
        a 7-day pass is sold for costs[1] dollars;
        a 30-day pass is sold for costs[2] dollars.
    

    The passes allow that many days of consecutive travel.  For example, if we get a 7-day
        pass on day 2, then we can travel for 7 days: day 2, 3, 4, 5, 6, 7, and 8.

    Return the minimum number of dollars you need to travel every day in the given list of days.
    

     

    Example 1:

    Input: days = [1,4,6,7,8,20], costs = [2,7,15]
Output: 11
Explanation: 
For example, here is one way to buy passes that lets you travel your travel plan:
On day 1, you bought a 1-day pass for costs[0] = $2, which covered day 1.
On day 3, you bought a 7-day pass for costs[1] = $7, which covered days 3, 4, ..., 9.
On day 20, you bought a 1-day pass for costs[0] = $2, which covered day 20.
In total you spent $11 and covered all the days of your travel.
-----------------

# 926_Flip_String_to_Monotone_Increasing
# 926. Flip String to Monotone Increasing

A string of '0's and '1's is monotone
        increasing if it consists of some number of '0's (possibly 0),
        followed by some number of '1's (also possibly 0.)

    We are given a string S of '0's and
        '1's, and we may flip any '0' to a '1'
        or a '1' to a '0'.

    Return the minimum number of flips to make S monotone increasing.
-----------------

# 975_Odd_Even_Jump
# 975. Odd Even Jump

You are given an integer array A.  From some starting index, you can
        make a series of jumps.  The (1st, 3rd, 5th, ...) jumps in the series are called
        odd numbered jumps, and the (2nd, 4th, 6th, ...) jumps in the series are called
        even numbered jumps.

    You may from index i jump forward to index j (with i < j) in the following
        way:

    
        During odd numbered jumps (ie. jumps 1, 3, 5, ...), you jump to the index j such that A[i] <= A[j] and
            A[j] is the smallest possible value.  If there are multiple such
            indexes j, you can only jump to the smallest
            such index j.
        
        During even numbered jumps (ie. jumps 2, 4, 6, ...), you jump to the index j such that A[i] >= A[j] and
            A[j] is the largest possible value.  If there are multiple such
            indexes j, you can only jump to the smallest
            such index j.
        
        (It may be the case that for some index i,
            there are no legal jumps.)
        
    

    A starting index is good if, starting from that index, you can reach the end of the
        array (index A.length - 1) by jumping some number of times (possibly 0 or more
        than once.)

    Return the number of good starting indexes.

     

    Example 1:

    Input: [10,13,12,14,15]
Output: 2
Explanation: 
From starting index i = 0, we can jump to i = 2 (since A[2] is the smallest among A[1], A[2], A[3], A[4] that is greater or equal to A[0]), then we can't jump any more.
From starting index i = 1 and i = 2, we can jump to i = 3, then we can't jump any more.
From starting index i = 3, we can jump to i = 4, so we've reached the end.
From starting index i = 4, we've reached the end already.
In total, there are 2 different starting indexes (i = 3, i = 4) where we can reach the end with some number of jumps.
-----------------

# 184_Department_Highest_Salary
# 184. Department Highest Salary

The Employee table holds all employees. Every employee has an Id, a salary, and
        there is also a column for the department Id.

    +----+-------+--------+--------------+
| Id | Name  | Salary | DepartmentId |
+----+-------+--------+--------------+
| 1  | Joe   | 70000  | 1            |
| 2  | Jim   | 90000  | 1            |
| 3  | Henry | 80000  | 2            |
| 4  | Sam   | 60000  | 2            |
| 5  | Max   | 90000  | 1            |
+----+-------+--------+--------------+

    The Department table holds all departments of the company.

    +----+----------+
| Id | Name     |
+----+----------+
| 1  | IT       |
| 2  | Sales    |
+----+----------+

    Write a SQL query to find employees who have the highest salary in each of the departments. For
        the above tables, your SQL query should return the following rows (order of rows does not
        matter).

    +------------+----------+--------+
| Department | Employee | Salary |
+------------+----------+--------+
| IT         | Max      | 90000  |
| IT         | Jim      | 90000  |
| Sales      | Henry    | 80000  |
+------------+----------+--------+

    Explanation:

    Max and Jim both have the highest salary in the IT department and Henry has the highest
        salary in the Sales department.
-----------------

# 1432_Max_Difference_You_Can_Get_From_Changing_an_Integer
# 1432. Max Difference You Can Get From Changing an Integer


-----------------

# 836_Rectangle_Overlap
# 836. Rectangle Overlap

A rectangle is represented as a list [x1, y1, x2, y2],
        where (x1, y1) are the coordinates of its bottom-left corner, and
        (x2, y2) are the coordinates of its top-right corner.

    Two rectangles overlap if the area of their intersection is positive.  To be clear, two
        rectangles that only touch at the corner or edges do not overlap.

    Given two (axis-aligned) rectangles, return whether they overlap.

    Example 1:

    Input: rec1 = [0,0,2,2], rec2 = [1,1,3,3]
Output: true

    Example 2:

    Input: rec1 = [0,0,1,1], rec2 = [1,0,2,1]
Output: false

    Notes:

    
        Both rectangles rec1 and rec2 are lists of 4 integers.
        All coordinates in rectangles will be between -10^9 and
            10^9.
-----------------

# 429_N-ary_Tree_Level_Order_Traversal
# 429. N-ary Tree Level Order Traversal

Given an n-ary tree, return the level order traversal of its nodes' values. (ie, from
        left to right, level by level).

    For example, given a 3-ary tree:

     

    
        

     

    We should return its level order traversal:

    [
     [1],
     [3,2,4],
     [5,6]
]

     

    Note:

    
        The depth of the tree is at most 1000.
        The total number of nodes is at most 5000.
-----------------

# 1797_Design_Authentication_Manager
# 1797. Design Authentication Manager


-----------------

# 1112_Highest_Grade_For_Each_Student
# 1112. Highest Grade For Each Student

Table: Enrollments

    +---------------+---------+
| Column Name   | Type    |
+---------------+---------+
| student_id    | int     |
| course_id     | int     |
| grade         | int     |
+---------------+---------+
(student_id, course_id) is the primary key of this table.

    Write a SQL query to find the highest grade with its corresponding course for each student.
        In case of a tie, you should find the course with the smallest course_id.
        The output must be sorted by increasing student_id.

    The query result format is in the following example:

    Enrollments table:
+------------+-------------------+
| student_id | course_id | grade |
+------------+-----------+-------+
| 2          | 2         | 95    |
| 2          | 3         | 95    |
| 1          | 1         | 90    |
| 1          | 2         | 99    |
| 3          | 1         | 80    |
| 3          | 2         | 75    |
| 3          | 3         | 82    |
+------------+-----------+-------+

Result table:
+------------+-------------------+
| student_id | course_id | grade |
+------------+-----------+-------+
| 1          | 2         | 99    |
| 2          | 2         | 95    |
| 3          | 3         | 82    |
+------------+-----------+-------+
-----------------

# 461_Hamming_Distance
# 461. Hamming Distance

The Hamming
        distance between two integers is the number of positions at which the corresponding bits
        are different.

    Given two integers x and y, calculate the Hamming distance.

    Note:
        0 ≤ x, y < 231.
    

    Example:
    Input: x = 1, y = 4

Output: 2

Explanation:
1   (0 0 0 1)
4   (0 1 0 0)
       ↑   ↑

The above arrows point to positions where the corresponding bits are different.
-----------------

# 155_Min_Stack
# 155. Min Stack

Design a stack that supports push, pop, top, and retrieving the minimum element in constant
        time.

    
        push(x) -- Push element x onto stack.
        pop() -- Removes the element on top of the stack.
        top() -- Get the top element.
        getMin() -- Retrieve the minimum element in the stack.
    

     

    Example:

    MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.getMin();   --> Returns -3.
minStack.pop();
minStack.top();      --> Returns 0.
minStack.getMin();   --> Returns -2.
-----------------

# 634_Find_the_Derangement_of_An_Array
# 634. Find the Derangement of An Array

In combinatorial mathematics, a derangement is a permutation of the elements of a set, such
        that no element appears in its original position.
    

    
        There's originally an array consisting of n integers from 1 to n
        in ascending order, you need to find the number of derangement it can generate.
    

    
        Also, since the answer may be very large, you should return the output mod 109 +
        7.
    

    Example 1:
    Input: 3
Output: 2
Explanation: The original array is [1,2,3]. The two derangements are [2,3,1] and [3,1,2].

    

    Note:
        n is in the range of [1, 106].
-----------------

# 1526_Minimum_Number_of_Increments_on_Subarrays_to_Form_a_Target_Array
# 1526. Minimum Number of Increments on Subarrays to Form a Target Array


-----------------

# 139_Word_Break
# 139. Word Break

Given a non-empty string s and a dictionary wordDict
        containing a list of non-empty words, determine if s can be
        segmented into a space-separated sequence of one or more dictionary words.

    Note:

    
        The same word in the dictionary may be reused multiple times in the segmentation.
        You may assume the dictionary does not contain duplicate words.
    

    Example 1:

    Input: s = "leetcode", wordDict = ["leet", "code"]
Output: true
Explanation: Return true because "leetcode" can be segmented as "leet code".

    Example 2:

    Input: s = "applepenapple", wordDict = ["apple", "pen"]
Output: true
Explanation: Return true because "applepenapple" can be segmented as "apple pen apple".
             Note that you are allowed to reuse a dictionary word.

    Example 3:

    Input: s = "catsandog", wordDict = ["cats", "dog", "sand", "and", "cat"]
Output: false
-----------------

# 1279_Traffic_Light_Controlled_Intersection
# 1279. Traffic Light Controlled Intersection


-----------------

# 855_Exam_Room
# 855. Exam Room

In an exam room, there are N seats in a single row, numbered 0, 1, 2, ...,
        N-1.

    When a student enters the room, they must sit in the seat that maximizes the distance to the
        closest person.  If there are multiple such seats, they sit in the seat with the lowest
        number.  (Also, if no one is in the room, then the student sits at seat number 0.)

    Return a class ExamRoom(int N) that exposes two functions: ExamRoom.seat() returning
        an int representing what seat the student sat in, and ExamRoom.leave(int
            p) representing that the student in seat number p now
        leaves the room.  It is guaranteed that any calls to ExamRoom.leave(p)
        have a student sitting in seat p.

     

    Example 1:

    Input: ["ExamRoom","seat","seat","seat","seat","leave","seat"], [[10],[],[],[],[],[4],[]]
Output: [null,0,9,4,2,null,5]
Explanation:
ExamRoom(10) -> null
seat() -> 0, no one is in the room, then the student sits at seat number 0.
seat() -> 9, the student sits at the last seat number 9.
seat() -> 4, the student sits at the last seat number 4.
seat() -> 2, the student sits at the last seat number 2.
leave(4) -> null
seat() -> 5, the student sits at the last seat number 5.

    ​​​​​​​

    Note:

    
        1 <= N <= 10^9
        ExamRoom.seat() and ExamRoom.leave() will be called at most
            10^4 times across all test cases.
        
        Calls to ExamRoom.leave(p) are guaranteed to have a student currently
            sitting in seat number p.
-----------------

# 557_Reverse_Words_in_a_String_III
# 557. Reverse Words in a String III

Given a string, you need to reverse the order of characters in each word within a sentence
        while still preserving whitespace and initial word order.

    Example 1:
    Input: "Let's take LeetCode contest"
Output: "s'teL ekat edoCteeL tsetnoc"

    

    Note:
        In the string, each word is separated by single space and there will not be any extra space
        in the string.
-----------------

# 430_Flatten_a_Multilevel_Doubly_Linked_List
# 430. Flatten a Multilevel Doubly Linked List

You are given a doubly linked list which in addition to the next and previous pointers, it
        could have a child pointer, which may or may not point to a separate doubly linked list.
        These child lists may have one or more children of their own, and so on, to produce a
        multilevel data structure, as shown in the example below.

    Flatten the list so that all the nodes appear in a single-level, doubly linked list. You are
        given the head of the first level of the list.

     

    Example:

    Input:
 1---2---3---4---5---6--NULL
         |
         7---8---9---10--NULL
             |
             11--12--NULL

Output:
1-2-3-7-8-11-12-9-10-4-5-6-NULL

     

    Explanation for the above example:

    Given the following multilevel doubly linked list:

    

     

    We should return the following flattened doubly linked list:
-----------------

# 1566_Detect_Pattern_of_Length_M_Repeated_K_or_More_Times
# 1566. Detect Pattern of Length M Repeated K or More Times


-----------------

# 216_Combination_Sum_III
# 216. Combination Sum III


-----------------

# 148_Sort_List
# 148. Sort List

Sort a linked list in O(n log n) time using constant space
        complexity.

    Example 1:

    Input: 4->2->1->3
Output: 1->2->3->4

    Example 2:

    Input: -1->5->3->4->0
Output: -1->0->3->4->5
-----------------

# 874_Walking_Robot_Simulation
# 874. Walking Robot Simulation

A robot on an infinite grid starts at point (0, 0) and faces north.  The robot can
        receive one of three possible types of commands:

    
        -2: turn left 90 degrees
        -1: turn right 90 degrees
        1 <= x <= 9: move forward x units
    

    Some of the grid squares are obstacles. 

    The i-th obstacle is at grid point (obstacles[i][0],
        obstacles[i][1])

    If the robot would try to move onto them, the robot stays on the previous grid square instead
        (but still continues following the rest of the route.)

    Return the square of the maximum Euclidean distance that the robot will be
        from the origin.

     

    Example 1:

    Input: commands = [4,-1,3], obstacles = []
Output: 25
Explanation: robot will go to (3, 4)
-----------------

# 1041_Robot_Bounded_In_Circle
# 1041. Robot Bounded In Circle

On an infinite plane, a robot initially stands at (0, 0) and faces north.  The
        robot can receive one of three instructions:

    
        "G": go straight 1 unit;
        "L": turn 90 degrees to the left;
        "R": turn 90 degress to the right.
    

    The robot performs the instructions given in order, and repeats them forever.
    

    Return true if and only if there exists a circle in the plane such that the
        robot never leaves the circle.

     

    Example 1:

    Input: "GGLLGG"
Output: true
Explanation: 
The robot moves from (0,0) to (0,2), turns 180 degrees, and then returns to (0,0).
When repeating these instructions, the robot remains in the circle of radius 2 centered at the origin.

    Example 2:

    Input: "GG"
Output: false
Explanation: 
The robot moves north indefinitely.

    Example 3:

    Input: "GL"
Output: true
Explanation: 
The robot moves from (0, 0) -> (0, 1) -> (-1, 1) -> (-1, 0) -> (0, 0) -> ...

     

    Note:

    
        1 <= instructions.length <= 100
        instructions[i] is in {'G', 'L', 'R'}
-----------------

# 651_4_Keys_Keyboard
# 651. 4 Keys Keyboard

Imagine you have a special keyboard with the following keys: 
    Key 1: (A): Print one 'A' on screen.
    Key 2: (Ctrl-A): Select the whole screen.
    Key 3: (Ctrl-C): Copy selection to buffer.
    Key 4: (Ctrl-V): Print buffer on screen appending it after what has already been
        printed. 

    Now, you can only press the keyboard for N times (with the above four keys), find out
        the maximum numbers of 'A' you can print on screen.

    Example 1:
    Input: N = 3
Output: 3
Explanation:
We can at most get 3 A's on screen by pressing following key sequence:
A, A, A

    

    Example 2:
    Input: N = 7
Output: 9
Explanation:
We can at most get 9 A's on screen by pressing following key sequence:
A, A, A, Ctrl A, Ctrl C, Ctrl V, Ctrl V

    

    Note:
    
        1 <= N <= 50
        Answers will be in the range of 32-bit signed integer.
-----------------

# 1348_Tweet_Counts_Per_Frequency
# 1348. Tweet Counts Per Frequency


-----------------

# 485_Max_Consecutive_Ones
# 485. Max Consecutive Ones

Given a binary array, find the maximum number of consecutive 1s in this array.

    Example 1:
    Input: [1,1,0,1,1,1]
Output: 3
Explanation: The first two digits or the last three digits are consecutive 1s.
    The maximum number of consecutive 1s is 3.

    

    Note:
    
        The input array will only contain 0 and 1.
        The length of input array is a positive integer and will not exceed 10,000
-----------------

# 1730_Shortest_Path_to_Get_Food
# 1730. Shortest Path to Get Food


-----------------

# 875_Koko_Eating_Bananas
# 875. Koko Eating Bananas

Koko loves to eat bananas.  There are N piles of bananas, the
        i-th pile has piles[i] bananas.  The guards have gone
        and will come back in H hours.

    Koko can decide her bananas-per-hour eating speed of K.  Each hour, she
        chooses some pile of bananas, and eats K bananas from that pile.  If the pile has less
        than K bananas, she eats all of them instead, and won't eat any more
        bananas during this hour.

    Koko likes to eat slowly, but still wants to finish eating all the bananas before the guards
        come back.

    Return the minimum integer K such that she can eat all the bananas within H
        hours.
-----------------

# 629_K_Inverse_Pairs_Array
# 629. K Inverse Pairs Array

Given two integers n and k, find how many different arrays consist
        of numbers from 1 to n such that there are exactly k
        inverse pairs.

    We define an inverse pair as following: For ith and
        jth element in the array, if i < j and
        a[i] > a[j] then it's an inverse pair; Otherwise, it's
        not.

    Since the answer may be very large, the answer should be modulo 109 + 7.

    Example 1:

    Input: n = 3, k = 0
Output: 1
Explanation:
Only the array [1,2,3] which consists of numbers from 1 to 3 has exactly 0 inverse pair.

     

    Example 2:

    Input: n = 3, k = 1
Output: 2
Explanation:
The array [1,3,2] and [2,1,3] have exactly 1 inverse pair.

     

    Note:

    
        The integer n is in the range [1, 1000] and k is in the range
            [0, 1000].
-----------------

# 240_Search_a_2D_Matrix_II
# 240. Search a 2D Matrix II

Write an efficient algorithm that searches for a value in an m x n matrix. This
        matrix has the following properties:

    
        Integers in each row are sorted in ascending from left to right.
        Integers in each column are sorted in ascending from top to bottom.
    

    Example:

    Consider the following matrix:

    [
  [1,   4,  7, 11, 15],
  [2,   5,  8, 12, 19],
  [3,   6,  9, 16, 22],
  [10, 13, 14, 17, 24],
  [18, 21, 23, 26, 30]
]

    Given target = 5, return true.

    Given target = 20, return false.
-----------------

# 1312_Minimum_Insertion_Steps_to_Make_a_String_Palindrome
# 1312. Minimum Insertion Steps to Make a String Palindrome


-----------------

# 742_Closest_Leaf_in_a_Binary_Tree
# 742. Closest Leaf in a Binary Tree

Given a binary tree where every node has a unique value, and a target key
        k, find the value of the nearest leaf node to target k in the
        tree.
    
    
        Here, nearest to a leaf means the least number of edges travelled on the binary tree
        to reach any leaf of the tree. Also, a node is called a leaf if it has no children.
    
    
        In the following examples, the input tree is represented in flattened form row by row.
        The actual root tree given will be a TreeNode object.
    
    
        Example 1:
    Input:
root = [1, 3, 2], k = 1
Diagram of binary tree:
          1
         / \
        3   2

Output: 2 (or 3)

Explanation: Either 2 or 3 is the nearest leaf node to the target of 1.

    
    Example 2:
    Input:
root = [1], k = 1
Output: 1

Explanation: The nearest leaf node is the root node itself.

    

    
        Example 3:
    Input:
root = [1,2,3,4,null,null,null,5,null,6], k = 2
Diagram of binary tree:
             1
            / \
           2   3
          /
         4
        /
       5
      /
     6

Output: 3
Explanation: The leaf node with value 3 (and not the leaf node with value 6) is nearest to the node with value 2.

    

    Note:
    
        root represents a binary tree with at least 1 node and at most
            1000 nodes.
        
        Every node has a unique node.val in range [1, 1000].
        There exists some node in the given binary tree for which node.val == k.
-----------------

# 46_Permutations
# 46. Permutations

Given a collection of distinct integers, return all possible permutations.
    

    Example:

    Input: [1,2,3]
Output:
[
  [1,2,3],
  [1,3,2],
  [2,1,3],
  [2,3,1],
  [3,1,2],
  [3,2,1]
]
-----------------

# 309_Best_Time_to_Buy_and_Sell_Stock_with_Cooldown
# 309. Best Time to Buy and Sell Stock with Cooldown

Say you have an array for which the ith element is the price of a given
        stock on day i.

    Design an algorithm to find the maximum profit. You may complete as many transactions as you
        like (ie, buy one and sell one share of the stock multiple times) with the following
        restrictions:

    
        You may not engage in multiple transactions at the same time (ie, you must sell the
            stock before you buy again).
        
        After you sell your stock, you cannot buy stock on next day. (ie, cooldown 1 day)
    

    Example:

    Input: [1,2,3,0,2]
Output: 3
Explanation: transactions = [buy, sell, cooldown, buy, sell]
-----------------

# 374_Guess_Number_Higher_or_Lower
# 374. Guess Number Higher or Lower

We are playing the Guess Game. The game is as follows:

    I pick a number from 1 to n. You have to guess which number I picked.
    

    Every time you guess wrong, I'll tell you whether the number is higher or lower.

    You call a pre-defined API guess(int num) which returns 3 possible results
        (-1, 1, or 0):

    -1 : My number is lower
 1 : My number is higher
 0 : Congrats! You got it!

    Example :
-----------------

# 179_Largest_Number
# 179. Largest Number

Given a list of non negative integers, arrange them such that they form the largest
        number.

    Example 1:

    Input: [10,2]
Output: "210"

    Example 2:

    Input: [3,30,34,5,9]
Output: "9534330"

    Note: The result may be very large, so you need to return a string instead
        of an integer.
-----------------

# 848_Shifting_Letters
# 848. Shifting Letters

We have a string S of lowercase letters, and an integer array
        shifts.

    Call the shift of a letter, the next letter in the alphabet, (wrapping around so
        that 'z' becomes 'a'). 

    For example, shift('a') = 'b', shift('t') = 'u',
        and shift('z') = 'a'.

    Now for each shifts[i] = x, we want to shift the first i+1 letters
        of S, x times.

    Return the final string after all such shifts to S are applied.

    Example 1:

    Input: S = "abc", shifts = [3,5,9]
Output: "rpl"
Explanation: 
We start with "abc".
After shifting the first 1 letters of S by 3, we have "dbc".
After shifting the first 2 letters of S by 5, we have "igc".
After shifting the first 3 letters of S by 9, we have "rpl", the answer.

    Note:

    
        1 <= S.length = shifts.length <= 20000
        0 <= shifts[i] <= 10 ^ 9
-----------------

# 444_Sequence_Reconstruction
# 444. Sequence Reconstruction

Check whether the original sequence org can be uniquely reconstructed from the
        sequences in seqs. The org sequence is a permutation of the
        integers from 1 to n, with 1 ≤ n ≤ 104. Reconstruction means building a
        shortest common supersequence of the sequences in seqs (i.e., a shortest
        sequence so that all sequences in seqs are subsequences of it). Determine
        whether there is only one sequence that can be reconstructed from seqs and it
        is the org sequence.

    Example 1:
    Input:
org: [1,2,3], seqs: [[1,2],[1,3]]

Output:
false

Explanation:
[1,2,3] is not the only one sequence that can be reconstructed, because [1,3,2] is also a valid sequence that can be reconstructed.

    

    Example 2:
    Input:
org: [1,2,3], seqs: [[1,2]]

Output:
false

Explanation:
The reconstructed sequence can only be [1,2].

    

    Example 3:
    Input:
org: [1,2,3], seqs: [[1,2],[1,3],[2,3]]

Output:
true

Explanation:
The sequences [1,2], [1,3], and [2,3] can uniquely reconstruct the original sequence [1,2,3].

    

    Example 4:
    Input:
org: [4,1,5,2,6,3], seqs: [[5,2,6,3],[4,1,5,2]]

Output:
true

    

    
        UPDATE (2017/1/8):
        The seqs parameter had been changed to a list of list of strings (instead of a 2d
        array of strings). Please reload the code definition to get the latest changes.
-----------------

# 513_Find_Bottom_Left_Tree_Value
# 513. Find Bottom Left Tree Value

Given a binary tree, find the leftmost value in the last row of the tree.
    

    Example 1:
    Input:

    2
   / \
  1   3

Output:
1

    

     Example 2: 
    Input:

        1
       / \
      2   3
     /   / \
    4   5   6
       /
      7

Output:
7

    

    Note:
        You may assume the tree (i.e., the given root node) is not NULL.
-----------------

# 777_Swap_Adjacent_in_LR_String
# 777. Swap Adjacent in LR String

In a string composed of 'L', 'R', and 'X'
        characters, like "RXXLRXRXL", a move consists of either replacing one
        occurrence of "XL" with "LX", or replacing one
        occurrence of "RX" with "XR". Given the
        starting string start and the ending string end, return
        True if and only if there exists a sequence of moves to transform one string to
        the other.

    Example:

    Input: start = "RXXLRXRXL", end = "XRLXXRRLX"
Output: True
Explanation:
We can transform start to end following these steps:
RXXLRXRXL ->
XRXLRXRXL ->
XRLXRXRXL ->
XRLXXRRXL ->
XRLXXRRLX

    Note:

    
        1 <= len(start) = len(end) <= 10000.
        Both start and end will only consist of characters in {'L', 'R',
            'X'}.
-----------------

# 1498_Number_of_Subsequences_That_Satisfy_the_Given_Sum_Condition
# 1498. Number of Subsequences That Satisfy the Given Sum Condition


-----------------

# 395_Longest_Substring_with_At_Least_K_Repeating_Characters
# 395. Longest Substring with At Least K Repeating Characters

Find the length of the longest substring T of a given string (consists of
        lowercase letters only) such that every character in T appears no less than
        k times.
    

    Example 1:
    Input:
s = "aaabb", k = 3

Output:
3

The longest substring is "aaa", as 'a' is repeated 3 times.

    

    Example 2:
    Input:
s = "ababbc", k = 2

Output:
5

The longest substring is "ababb", as 'a' is repeated 2 times and 'b' is repeated 3 times.
-----------------

# 1063_Number_of_Valid_Subarrays
# 1063. Number of Valid Subarrays

Given an array A of integers, return the number of non-empty continuous
        subarrays that satisfy the following condition:

    The leftmost element of the subarray is not larger than other elements in the subarray.

     

    Example 1:

    Input: [1,4,2,5,3]
Output: 11
Explanation: There are 11 valid subarrays: [1],[4],[2],[5],[3],[1,4],[2,5],[1,4,2],[2,5,3],[1,4,2,5],[1,4,2,5,3].

    Example 2:

    Input: [3,2,1]
Output: 3
Explanation: The 3 valid subarrays are: [3],[2],[1].

    Example 3:

    Input: [2,2,2]
Output: 6
Explanation: There are 6 valid subarrays: [2],[2],[2],[2,2],[2,2],[2,2,2].

     

    Note:

    
        1 <= A.length <= 50000
        0 <= A[i] <= 100000
-----------------

# 458_Poor_Pigs
# 458. Poor Pigs

There are 1000 buckets, one and only one of them is poisonous, while the rest are filled with
        water. They all look identical. If a pig drinks the poison it will die within 15 minutes.
        What is the minimum amount of pigs you need to figure out which bucket is poisonous within
        one hour?

    Answer this question, and write an algorithm for the general case.

     

    General case: 

    If there are n buckets and a pig drinking poison will die within m
        minutes, how many pigs (x) you need to figure out the
        poisonous bucket within p minutes? There is exactly one
        bucket with poison.

     

    Note:

    
        A pig can be allowed to drink simultaneously on as many buckets as one would like, and
            the feeding takes no time.
        
        After a pig has instantly finished drinking buckets, there has to be a cool down
            time of m minutes. During this time, only observation is allowed
            and no feedings at all.
        
        Any given bucket can be sampled an infinite number of times (by an unlimited number of
            pigs).
-----------------

# 1529_Bulb_Switcher_IV
# 1529. Bulb Switcher IV


-----------------

# 583_Delete_Operation_for_Two_Strings
# 583. Delete Operation for Two Strings

Given two words word1 and word2, find the minimum number of steps required to
        make word1 and word2 the same, where in each step you can delete one character
        in either string.
    

    Example 1:
    Input: "sea", "eat"
Output: 2
Explanation: You need one step to make "sea" to "ea" and another step to make "eat" to "ea".

    

    Note:
    
        The length of given words won't exceed 500.
        Characters in given words can only be lower-case letters.
-----------------

# 695_Max_Area_of_Island
# 695. Max Area of Island

Given a non-empty 2D array grid of 0's and 1's, an island is a
        group of 1's (representing land) connected 4-directionally (horizontal or
        vertical.) You may assume all four edges of the grid are surrounded by water.

    Find the maximum area of an island in the given 2D array. (If there is no island, the maximum
        area is 0.)

    Example 1:

    [[0,0,1,0,0,0,0,1,0,0,0,0,0],
 [0,0,0,0,0,0,0,1,1,1,0,0,0],
 [0,1,1,0,1,0,0,0,0,0,0,0,0],
 [0,1,0,0,1,1,0,0,1,0,1,0,0],
 [0,1,0,0,1,1,0,0,1,1,1,0,0],
 [0,0,0,0,0,0,0,0,0,0,1,0,0],
 [0,0,0,0,0,0,0,1,1,1,0,0,0],
 [0,0,0,0,0,0,0,1,1,0,0,0,0]]

    Given the above grid, return 6. Note the answer is not 11, because the island must
    be connected 4-directionally.

    Example 2:

    [[0,0,0,0,0,0,0,0]]
    Given the above grid, return 0.

    Note: The length of each dimension in the given grid does not exceed 50.
-----------------

# 1624_Largest_Substring_Between_Two_Equal_Characters
# 1624. Largest Substring Between Two Equal Characters


-----------------

# 556_Next_Greater_Element_III
# 556. Next Greater Element III

Given a positive 32-bit integer n, you need to find the
        smallest 32-bit integer which has exactly the same digits existing in the
        integer n and is greater in value than n. If no such positive 32-bit
        integer exists, you need to return -1.

    Example 1:

    Input: 12
Output: 21

     

    Example 2:

    Input: 21
Output: -1
-----------------

# 1221_Split_a_String_in_Balanced_Strings
# 1221. Split a String in Balanced Strings

Balanced strings are those who have equal quantity
        of 'L' and 'R' characters.

    Given a balanced string s split it in the
        maximum amount of balanced strings.

    Return the maximum amount of splitted balanced strings.

     
    Example 1:

    Input: s = "RLRRLLRLRL"
Output: 4
Explanation: s can be split into "RL", "RRLL", "RL", "RL", each substring contains same number of 'L' and 'R'.

    Example 2:

    Input: s = "RLLLLRRRLR"
Output: 3
Explanation: s can be split into "RL", "LLLRRR", "LR", each substring contains same number of 'L' and 'R'.

    Example 3:

    Input: s = "LLLLRRRR"
Output: 1
Explanation: s can be split into "LLLLRRRR".

     
    Constraints:

    
        1 <= s.length <= 1000
        s[i] = 'L' or 'R'
-----------------

# 1520_Maximum_Number_of_Non-Overlapping_Substrings
# 1520. Maximum Number of Non-Overlapping Substrings


-----------------

# 1734_Decode_XORed_Permutation
# 1734. Decode XORed Permutation


-----------------

# 1236_Web_Crawler
# 1236. Web Crawler

Given a url startUrl and an interface HtmlParser, implement a web crawler
        to crawl all links that are under the same hostname as startUrl. 
    

    Returns all urls obtained by your web crawler in any order.

    Your crawler should:

    
        Start from the page: startUrl
        Call HtmlParser.getUrls(url) to get all urls from a webpage of given url.
        
        Do not crawl the same link twice.
        Only the links that are under the same hostname as startUrl should
            be explored by the crawler
        
    

    

    As shown in the example url above, the hostname is example.org. For simplicity
        sake, you may assume all urls use http protocol without
        any port specified.

    The function interface is defined like this: 

    interface HtmlParser {
        public:
          // Returns a list of urls contained in url .
          public List<String> getUrls(String url);
        }

    Below there are two examples explaining the functionality of the problem, for custom testing
        purposes you'll have 3 variables urls, edges and startUrl. Notice that you will only have access to startUrl, while urls and edges are secret to you on the rest of the
        testcases.

     
    Example 1:

    

    Input:
urls = [
  "http://news.yahoo.com",
  "http://news.yahoo.com/news",
  "http://news.yahoo.com/news/topics/",
  "http://news.google.com",
  "http://news.yahoo.com/us"
]
edges = [[2,0],[2,1],[3,2],[3,1],[0,4]]
startUrl = "http://news.yahoo.com/news/topics/"
Output: [
  "http://news.yahoo.com",
  "http://news.yahoo.com/news",
  "http://news.yahoo.com/news/topics/",
  "http://news.yahoo.com/us"
]

    Example 2:

    

    Input:
urls = [
  "http://news.yahoo.com",
  "http://news.yahoo.com/news",
  "http://news.yahoo.com/news/topics/",
  "http://news.google.com"
]
edges = [[0,2],[2,1],[3,2],[3,1],[3,0]]
startUrl = "http://news.google.com"
Output: ["http://news.google.com"]
Explanation: The startUrl links to all other pages that do not share the same hostname.

     
    Constraints:

    
        1 <= urls.length <= 1000
        1 <= urls[i].length <= 300
        startUrl is one of the urls.
        Hostname label must be from 1 to 63 characters long, including the dots, may contain
            only the ASCII letters from 'a' to 'z', digits  from '0'
            to '9' and the hyphen-minus character ('-').
        
        The hostname may not start or end with the hyphen-minus character ('-'). 
        See:  https://en.wikipedia.org/wiki/Hostname#Restrictions_on_valid_hostnames
        
        You may assume there're no duplicates in url library.
-----------------

# 1680_Concatenation_of_Consecutive_Binary_Numbers
# 1680. Concatenation of Consecutive Binary Numbers


-----------------

# 358_Rearrange_String_k_Distance_Apart
# 358. Rearrange String k Distance Apart

Given a non-empty string s and an integer k, rearrange the string such that the
        same characters are at least distance k from each other.

    All input strings are given in lowercase letters. If it is not possible to rearrange the
        string, return an empty string "".

    Example 1:
-----------------

# 414_Third_Maximum_Number
# 414. Third Maximum Number

Given a non-empty array of integers, return the third maximum number in this
        array. If it does not exist, return the maximum number. The time complexity must be in O(n).
    

    Example 1:
    Input: [3, 2, 1]

Output: 1

Explanation: The third maximum is 1.

    

    Example 2:
    Input: [1, 2]

Output: 2

Explanation: The third maximum does not exist, so the maximum (2) is returned instead.

    

    Example 3:
    Input: [2, 2, 3, 1]

Output: 1

Explanation: Note that the third maximum here means the third maximum distinct number.
Both numbers with value 2 are both considered as second maximum.
-----------------

# 534_Game_Play_Analysis_III
# 534. Game Play Analysis III

Table: Activity

    +--------------+---------+
| Column Name  | Type    |
+--------------+---------+
| player_id    | int     |
| device_id    | int     |
| event_date   | date    |
| games_played | int     |
+--------------+---------+
(player_id, event_date) is the primary key of this table.
This table shows the activity of players of some game.
Each row is a record of a player who logged in and played a number of games (possibly 0) before logging out on some day using some device.

     

    Write an SQL query that reports for each player and date, how many games played so
        far by the player. That is, the total number of games played by the player
        until that date. Check the example for clarity.

    The query result format is in the following example:

    Activity table:
+-----------+-----------+------------+--------------+
| player_id | device_id | event_date | games_played |
+-----------+-----------+------------+--------------+
| 1         | 2         | 2016-03-01 | 5            |
| 1         | 2         | 2016-05-02 | 6            |
| 1         | 3         | 2017-06-25 | 1            |
| 3         | 1         | 2016-03-02 | 0            |
| 3         | 4         | 2018-07-03 | 5            |
+-----------+-----------+------------+--------------+

Result table:
+-----------+------------+---------------------+
| player_id | event_date | games_played_so_far |
+-----------+------------+---------------------+
| 1         | 2016-03-01 | 5                   |
| 1         | 2016-05-02 | 11                  |
| 1         | 2017-06-25 | 12                  |
| 3         | 2016-03-02 | 0                   |
| 3         | 2018-07-03 | 5                   |
+-----------+------------+---------------------+
For the player with id 1, 5 + 6 = 11 games played by 2016-05-02, and 5 + 6 + 1 = 12 games played by 2017-06-25.
For the player with id 3, 0 + 5 = 5 games played by 2018-07-03.
Note that for each player we only care about the days when the player logged in.
-----------------

# 1034_Coloring_A_Border
# 1034. Coloring A Border

Given a 2-dimensional grid of integers, each value in the grid represents
        the color of the grid square at that location.

    Two squares belong to the same connected component if and only if they have the same
        color and are next to each other in any of the 4 directions.

    The border of a connected component is all the squares in the connected
        component that are either 4-directionally adjacent to a square not in the
        component, or on the boundary of the grid (the first or last row or column).

    Given a square at location (r0, c0) in the grid and a
        color, color the border of the connected component of that square with the
        given color, and return the final grid.

     

    Example 1:

    Input: grid = [[1,1],[1,2]], r0 = 0, c0 = 0, color = 3
Output: [[3, 3], [3, 2]]
-----------------

# 798_Smallest_Rotation_with_Highest_Score
# 798. Smallest Rotation with Highest Score

Given an array A, we may rotate it by a non-negative integer
        K so that the array becomes A[K], A[K+1], A{K+2], ... A[A.length - 1],
            A[0], A[1], ..., A[K-1].  Afterward, any entries that are less than or equal
        to their index are worth 1 point. 

    For example, if we have [2, 4, 1, 3, 0], and we rotate by K = 2, it
        becomes [1, 3, 0, 2, 4].  This is worth 3 points because 1 > 0 [no
        points], 3 > 1 [no points], 0 <= 2 [one point], 2 <= 3 [one point], 4 <= 4 [one
        point].

    Over all possible rotations, return the rotation index K that corresponds to the highest
        score we could receive.  If there are multiple answers, return the smallest such index
        K.

    Example 1:
Input: [2, 3, 1, 4, 0]
Output: 3
Explanation: 
Scores for each K are listed below:
K = 0,  A = [2,3,1,4,0],    score 2
K = 1,  A = [3,1,4,0,2],    score 3
K = 2,  A = [1,4,0,2,3],    score 3
K = 3,  A = [4,0,2,3,1],    score 4
K = 4,  A = [0,2,3,1,4],    score 3

    So we should choose K = 3, which has the highest score.

     

    Example 2:
Input: [1, 3, 0, 2, 4]
Output: 0
Explanation:  A will always have 3 points no matter how it shifts.
So we will choose the smallest K, which is 0.

    Note:

    
        A will have length at most 20000.
        A[i] will be in the range [0, A.length].
-----------------

# 1411_Number_of_Ways_to_Paint_N_×_3_Grid
# 1411. Number of Ways to Paint N × 3 Grid


-----------------

# 1714_Sum_Of_Special_Evenly-Spaced_Elements_In_Array
# 1714. Sum Of Special Evenly-Spaced Elements In Array


-----------------

# 122_Best_Time_to_Buy_and_Sell_Stock_II
# 122. Best Time to Buy and Sell Stock II

Say you have an array for which the ith element is the price of a given
        stock on day i.

    Design an algorithm to find the maximum profit. You may complete as many transactions as you
        like (i.e., buy one and sell one share of the stock multiple times).

    Note: You may not engage in multiple transactions at the same time (i.e.,
        you must sell the stock before you buy again).

    Example 1:

    Input: [7,1,5,3,6,4]
Output: 7
Explanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.
             Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.

    Example 2:

    Input: [1,2,3,4,5]
Output: 4
Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.
             Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are
             engaging multiple transactions at the same time. You must sell before buying again.

    Example 3:

    Input: [7,6,4,3,1]
Output: 0
Explanation: In this case, no transaction is done, i.e. max profit = 0.
-----------------

# 535_Encode_and_Decode_TinyURL
# 535. Encode and Decode TinyURL

Note: This is a companion problem to the System
        Design problem: Design TinyURL.
    

    TinyURL is a URL shortening service where you enter a URL such as https://leetcode.com/problems/design-tinyurl
        and it returns a short URL such as http://tinyurl.com/4e9iAk.

    Design the encode and decode methods for the TinyURL service. There
        is no restriction on how your encode/decode algorithm should work. You just need to ensure
        that a URL can be encoded to a tiny URL and the tiny URL can be decoded to the original URL.
-----------------

# 1524_Number_of_Sub-arrays_With_Odd_Sum
# 1524. Number of Sub-arrays With Odd Sum


-----------------

# 913_Cat_and_Mouse
# 913. Cat and Mouse

A game on an undirected graph is played by two players, Mouse and Cat, who
        alternate turns.

    The graph is given as follows: graph[a] is a list of all nodes b
        such that ab is an edge of the graph.

    Mouse starts at node 1 and goes first, Cat starts at node 2 and goes second, and there is a
        Hole at node 0.

    During each player's turn, they must travel along one edge of the
        graph that meets where they are.  For example, if the Mouse is at node 1,
        it must travel to any node in graph[1].

    Additionally, it is not allowed for the Cat to travel to the Hole (node 0.)

    Then, the game can end in 3 ways:

    
        If ever the Cat occupies the same node as the Mouse, the Cat wins.
        If ever the Mouse reaches the Hole, the Mouse wins.
        If ever a position is repeated (ie. the players are in the same position as a
            previous turn, and it is the same player's turn to move), the game is a draw.
        
    

    Given a graph, and assuming both players play optimally, return 1 if
        the game is won by Mouse, 2 if the game is won by Cat, and 0 if
        the game is a draw.
-----------------

# 1398_Customers_Who_Bought_Products_A_and_B_but_Not_C
# 1398. Customers Who Bought Products A and B but Not C


-----------------

# 516_Longest_Palindromic_Subsequence
# 516. Longest Palindromic Subsequence

Given a string s, find the longest palindromic subsequence's length in s. You may assume
        that the maximum length of s is 1000.
    

    Example 1:
        Input:
    "bbbab"

    Output:
    4

    One possible longest palindromic subsequence is "bbbb".
    

    Example 2:
        Input:
    "cbbd"

    Output:
    2

    One possible longest palindromic subsequence is "bb".
-----------------

# 927_Three_Equal_Parts
# 927. Three Equal Parts

Given an array A of 0s and 1s, divide the array into 3
        non-empty parts such that all of these parts represent the same binary value.

    If it is possible, return any [i, j] with i+1 <
        j, such that:

    
        A[0], A[1], ..., A[i] is the first part;
        A[i+1], A[i+2], ..., A[j-1] is the second part, and
        A[j], A[j+1], ..., A[A.length - 1] is the third part.
        All three parts have equal binary value.
    

    If it is not possible, return [-1, -1].

    Note that the entire part is used when considering what binary value it represents.  For
        example, [1,1,0] represents 6 in decimal, not
        3.  Also, leading zeros are allowed, so [0,1,1] and
        [1,1] represent the same value.

     

    Example 1:

    Input: [1,0,1,0,1]
Output: [0,3]
-----------------

# 373_Find_K_Pairs_with_Smallest_Sums
# 373. Find K Pairs with Smallest Sums

You are given two integer arrays nums1 and nums2 sorted in ascending order and
        an integer k.

    Define a pair (u,v) which consists of one element from the first array and one element
        from the second array.

    Find the k pairs (u1,v1),(u2,v2)
        ...(uk,vk) with the smallest sums.

    Example 1:

    Input: nums1 = [1,7,11], nums2 = [2,4,6], k = 3
Output: [[1,2],[1,4],[1,6]]
Explanation: The first 3 pairs are returned from the sequence:
             [1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6]

    Example 2:

    Input: nums1 = [1,1,2], nums2 = [1,2,3], k = 2
Output: [1,1],[1,1]
Explanation: The first 2 pairs are returned from the sequence:
             [1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3]

    Example 3:

    Input: nums1 = [1,2], nums2 = [3], k = 3
Output: [1,3],[2,3]
Explanation: All possible pairs are returned from the sequence: [1,3],[2,3]
-----------------

# 423_Reconstruct_Original_Digits_from_English
# 423. Reconstruct Original Digits from English

Given a non-empty string containing an out-of-order English representation of digits
        0-9, output the digits in ascending order.

    Note:
    
        Input contains only lowercase English letters.
        Input is guaranteed to be valid and can be transformed to its original digits. That
            means invalid inputs such as "abc" or "zerone" are not permitted.
        
        Input length is less than 50,000.
    
    

    Example 1:
    Input: "owoztneoer"

Output: "012"

    

    Example 2:
    Input: "fviefuro"

Output: "45"
-----------------

# 1708_Largest_Subarray_Length_K
# 1708. Largest Subarray Length K


-----------------

# 1065_Index_Pairs_of_a_String
# 1065. Index Pairs of a String

Given a text string and words (a list of strings), return all
        index pairs [i, j] so that the substring text[i]...text[j] is
        in the list of words.

     

    Example 1:

    Input: text = "thestoryofleetcodeandme", words = ["story","fleet","leetcode"]
Output: [[3,7],[9,13],[10,17]]

    Example 2:

    Input: text = "ababa", words = ["aba","ab"]
Output: [[0,1],[0,2],[2,3],[2,4]]
Explanation: 
Notice that matches can overlap, see "aba" is found in [0,2] and [2,4].

     

    Note:

    
        All strings contains only lowercase English letters.
        It's guaranteed that all strings in words are different.
        1 <= text.length <= 100
        1 <= words.length <= 20
        1 <= words[i].length <= 50
        Return the pairs [i,j] in sorted order (i.e. sort them by their first
            coordinate in case of ties sort them by their second coordinate).
-----------------

# 1702_Maximum_Binary_String_After_Change
# 1702. Maximum Binary String After Change


-----------------

# 1270_All_People_Report_to_the_Given_Manager
# 1270. All People Report to the Given Manager


-----------------

# 1198_Find_Smallest_Common_Element_in_All_Rows
# 1198. Find Smallest Common Element in All Rows

Given a matrix mat where every row is sorted in increasing
        order, return the smallest common element in all rows.

    If there is no common element, return -1.

     
    Example 1:
    Input: mat = [[1,2,3,4,5],[2,4,5,8,10],[3,5,7,9,11],[1,3,5,7,9]]
Output: 5

     
    Constraints:

    
        1 <= mat.length, mat[i].length <= 500
        1 <= mat[i][j] <= 10^4
        mat[i] is sorted in increasing order.
-----------------

# 791_Custom_Sort_String
# 791. Custom Sort String

S and T are strings composed of lowercase letters. In
        S, no letter occurs more than once.

    S was sorted in some custom order previously. We want to permute the characters
        of T so that they match the order that S was sorted. More
        specifically, if x occurs before y in S, then
        x should occur before y in the returned string.

    Return any permutation of T (as a string) that satisfies this property.

    Example :
Input:
S = "cba"
T = "abcd"
Output: "cbad"
Explanation:
"a", "b", "c" appear in S, so the order of "a", "b", "c" should be "c", "b", and "a".
Since "d" does not appear in S, it can be at any position in T. "dcba", "cdba", "cbda" are also valid outputs.

     

    Note:

    
        S has length at most 26, and no character is repeated in
            S.
        
        T has length at most 200.
        S and T consist of lowercase letters only.
-----------------

# 952_Largest_Component_Size_by_Common_Factor
# 952. Largest Component Size by Common Factor

Given a non-empty array of unique positive integers A, consider the
        following graph:

    
        There are A.length nodes, labelled A[0] to A[A.length -
            1];
        There is an edge between A[i] and A[j] if and only if A[i]
            and A[j] share a common factor greater than 1.
        
    

    Return the size of the largest connected component in the graph.
-----------------

# 1364_Number_of_Trusted_Contacts_of_a_Customer
# 1364. Number of Trusted Contacts of a Customer


-----------------

# 1574_Shortest_Subarray_to_be_Removed_to_Make_Array_Sorted
# 1574. Shortest Subarray to be Removed to Make Array Sorted


-----------------

# 1147_Longest_Chunked_Palindrome_Decomposition
# 1147. Longest Chunked Palindrome Decomposition

Return the largest possible k such that there exists a_1, a_2,
        ..., a_k such that:

    
        Each a_i is a non-empty string;
        Their concatenation a_1 + a_2 + ... + a_k is equal to text;
        
        For all 1 <= i <= k,  a_i = a_{k+1 - i}.
    

     
    Example 1:

    Input: text = "ghiabcdefhelloadamhelloabcdefghi"
Output: 7
Explanation: We can split the string on "(ghi)(abcdef)(hello)(adam)(hello)(abcdef)(ghi)".

    Example 2:

    Input: text = "merchant"
Output: 1
Explanation: We can split the string on "(merchant)".

    Example 3:

    Input: text = "antaprezatepzapreanta"
Output: 11
Explanation: We can split the string on "(a)(nt)(a)(pre)(za)(tpe)(za)(pre)(a)(nt)(a)".

    Example 4:

    Input: text = "aaa"
Output: 3
Explanation: We can split the string on "(a)(a)(a)".

     
    Constraints:

    
        text consists only of lowercase English characters.
        1 <= text.length <= 1000
-----------------

# 906_Super_Palindromes
# 906. Super Palindromes

Let's say a positive integer is a superpalindrome if it is a
        palindrome, and it is also the square of a palindrome.

    Now, given two positive integers L and R (represented as
        strings), return the number of superpalindromes in the inclusive range [L, R].
    

     

    Example 1:

    Input: L = "4", R = "1000"
Output: 4
Explanation: 4, 9, 121, and 484 are superpalindromes.
Note that 676 is not a superpalindrome: 26 * 26 = 676, but 26 is not a palindrome.

     

    Note:

    
        1 <= len(L) <= 18
        1 <= len(R) <= 18
        L and R are strings representing integers in the range [1,
            10^18).
        
        int(L) <= int(R)
-----------------

# 1331_Rank_Transform_of_an_Array
# 1331. Rank Transform of an Array


-----------------

# 1691_Maximum_Height_by_Stacking_Cuboids
# 1691. Maximum Height by Stacking Cuboids


-----------------

# 1694_Reformat_Phone_Number
# 1694. Reformat Phone Number


-----------------

# 1117_Building_H2O
# 1117. Building H2O

There are two kinds of threads, oxygen and hydrogen. Your goal is
        to group these threads to form water molecules. There is a barrier where each thread
        has to wait until a complete molecule can be formed. Hydrogen and oxygen threads will
        be given releaseHydrogen and releaseOxygen methods
        respectively, which will allow them to pass the barrier. These threads should pass the
        barrier in groups of three, and they must be able to immediately bond with each other to
        form a water molecule. You must guarantee that all the threads from one molecule bond
        before any other threads from the next molecule do.

    In other words:

    
        If an oxygen thread arrives at the barrier when no hydrogen threads are present, it has
            to wait for two hydrogen threads.
        
        If a hydrogen thread arrives at the barrier when no other threads are present, it has to
            wait for an oxygen thread and another hydrogen thread.
        
    

    We don’t have to worry about matching the threads up explicitly; that is, the threads
        do not necessarily know which other threads they are paired up with. The key is just that
        threads pass the barrier in complete sets; thus, if we examine the sequence of threads that
        bond and divide them into groups of three, each group should contain one oxygen and two
        hydrogen threads.

    Write synchronization code for oxygen and hydrogen molecules that enforces these
        constraints.
-----------------

# 1653_Minimum_Deletions_to_Make_String_Balanced
# 1653. Minimum Deletions to Make String Balanced


-----------------

# 1684_Count_the_Number_of_Consistent_Strings
# 1684. Count the Number of Consistent Strings


-----------------

# 1373_Maximum_Sum_BST_in_Binary_Tree
# 1373. Maximum Sum BST in Binary Tree


-----------------

# 1578_Minimum_Deletion_Cost_to_Avoid_Repeating_Letters
# 1578. Minimum Deletion Cost to Avoid Repeating Letters


-----------------

# 795_Number_of_Subarrays_with_Bounded_Maximum
# 795. Number of Subarrays with Bounded Maximum

We are given an array A of positive integers, and two positive integers
        L and R (L <= R).

    Return the number of (contiguous, non-empty) subarrays such that the value of the maximum
        array element in that subarray is at least L and at most R.

    Example :
Input:
A = [2, 1, 4, 3]
L = 2
R = 3
Output: 3
Explanation: There are three subarrays that meet the requirements: [2], [2, 1], [3].

    Note:

    
        L, R  and A[i] will be an integer in the range [0, 10^9].
        
        The length of A will be in the range of [1, 50000].
-----------------

# 647_Palindromic_Substrings
# 647. Palindromic Substrings

Given a string, your task is to count how many palindromic substrings in this string.

    The substrings with different start indexes or end indexes are counted as different
        substrings even they consist of same characters.

    Example 1:

    Input: "abc"
Output: 3
Explanation: Three palindromic strings: "a", "b", "c".

     

    Example 2:

    Input: "aaa"
Output: 6
Explanation: Six palindromic strings: "a", "a", "a", "aa", "aa", "aaa".

     

    Note:

    
        The input string length won't exceed 1000.
-----------------

# 980_Unique_Paths_III
# 980. Unique Paths III

On a 2-dimensional grid, there are 4 types of squares:

    
        1 represents the starting square.  There is exactly one starting
            square.
        
        2 represents the ending square.  There is exactly one ending square.
        
        0 represents empty squares we can walk over.
        -1 represents obstacles that we cannot walk over.
    

    Return the number of 4-directional walks from the starting square to the ending square,
        that walk over every non-obstacle square exactly once.
-----------------

# 1584_Min_Cost_to_Connect_All_Points
# 1584. Min Cost to Connect All Points


-----------------

# 1492_The_kth_Factor_of_n
# 1492. The kth Factor of n


-----------------

# 1588_Sum_of_All_Odd_Length_Subarrays
# 1588. Sum of All Odd Length Subarrays


-----------------

# 81_Search_in_Rotated_Sorted_Array_II
# 81. Search in Rotated Sorted Array II

Suppose an array sorted in ascending order is rotated at some pivot unknown to you
        beforehand.

    (i.e., [0,0,1,2,2,5,6] might become [2,5,6,0,0,1,2]).

    You are given a target value to search. If found in the array return true,
        otherwise return false.

    Example 1:

    Input: nums = [2,5,6,0,0,1,2], target = 0
Output: true

    Example 2:

    Input: nums = [2,5,6,0,0,1,2], target = 3
Output: false

    Follow up:

    
        This is a follow up problem to Search
            in Rotated Sorted Array, where nums may contain duplicates.
        
        Would this affect the run-time complexity? How and why?
-----------------

# 368_Largest_Divisible_Subset
# 368. Largest Divisible Subset

Given a set of distinct positive integers, find the largest subset such that every
        pair (Si, Sj) of elements in this subset satisfies:

    Si % Sj = 0 or Sj % Si = 0.

    If there are multiple solutions, return any subset is fine.

    Example 1:
-----------------

# 1833_Maximum_Ice_Cream_Bars
# 1833. Maximum Ice Cream Bars


-----------------

# 1043_Partition_Array_for_Maximum_Sum
# 1043. Partition Array for Maximum Sum

Given an integer array A, you partition the array into (contiguous) subarrays of
        length at most K.  After partitioning, each subarray has their values
        changed to become the maximum value of that subarray.

    Return the largest sum of the given array after partitioning.

     

    Example 1:

    Input: A = [1,15,7,9,2,5,10], K = 3
Output: 84
Explanation: A becomes [15,15,15,9,10,10,10]

     

    Note:

    
        1 <= K <= A.length <= 500
        0 <= A[i] <= 10^6
-----------------

# 843_Guess_the_Word
# 843. Guess the Word

This problem is an interactive problem new to the
        LeetCode platform.

    We are given a word list of unique words, each word is 6 letters long, and one word in this
        list is chosen as secret.

    You may call master.guess(word) to guess a word.  The guessed word
        should have type string and must be from the original list with
        6 lowercase letters.

    This function returns an integer type, representing the number of
        exact matches (value and position) of your guess to the secret word. 
        Also, if your guess is not in the given wordlist, it will return -1 instead.
    

    For each test case, you have 10 guesses to guess the word. At the end of any number of calls,
        if you have made 10 or less calls to master.guess and at least one of
        these guesses was the secret, you pass the testcase.

    Besides the example test case below, there will be 5 additional test cases, each with
        100 words in the word list.  The letters of each word in those testcases were chosen independently
        at random from 'a' to 'z', such that every word in
        the given word lists is unique.

    Example 1:
Input: secret = "acckzz", wordlist = ["acckzz","ccbazz","eiowzz","abcczz"]

Explanation:

master.guess("aaaaaa") returns -1, because "aaaaaa" is not in wordlist.
master.guess("acckzz") returns 6, because "acckzz" is secret and has all 6 matches.
master.guess("ccbazz") returns 3, because "ccbazz" has 3 matches.
master.guess("eiowzz") returns 2, because "eiowzz" has 2 matches.
master.guess("abcczz") returns 4, because "abcczz" has 4 matches.

We made 5 calls to master.guess and one of them was the secret, so we pass the test case.

    Note:  Any solutions that attempt to circumvent the judge will
        result in disqualification.
-----------------

# 1836_Remove_Duplicates_From_an_Unsorted_Linked_List
# 1836. Remove Duplicates From an Unsorted Linked List


-----------------

# 1587_Bank_Account_Summary_II
# 1587. Bank Account Summary II


-----------------

# 1413_Minimum_Value_to_Get_Positive_Step_by_Step_Sum
# 1413. Minimum Value to Get Positive Step by Step Sum


-----------------

# 20_Valid_Parentheses
# 20. Valid Parentheses

Given a string containing just the characters '(',
        ')', '{', '}', '['
        and ']', determine if the input string is valid.

    An input string is valid if:

    
        Open brackets must be closed by the same type of brackets.
        Open brackets must be closed in the correct order.
    

    Note that an empty string is also considered valid.

    Example 1:

    Input: "()"
Output: true

    Example 2:

    Input: "()[]{}"
Output: true

    Example 3:

    Input: "(]"
Output: false

    Example 4:

    Input: "([)]"
Output: false

    Example 5:

    Input: "{[]}"
Output: true
-----------------

# 922_Sort_Array_By_Parity_II
# 922. Sort Array By Parity II

Given an array A of non-negative integers, half of the integers in A are
        odd, and half of the integers are even.

    Sort the array so that whenever A[i] is odd, i is odd; and whenever
        A[i] is even, i is even.

    You may return any answer array that satisfies this condition.

     

    Example 1:

    Input: [4,2,5,7]
Output: [4,5,2,7]
Explanation: [4,7,2,5], [2,5,4,7], [2,7,4,5] would also have been accepted.

     

    Note:

    
        2 <= A.length <= 20000
        A.length % 2 == 0
        0 <= A[i] <= 1000
-----------------

# 659_Split_Array_into_Consecutive_Subsequences
# 659. Split Array into Consecutive Subsequences

Given an array nums sorted in ascending order, return true if
        and only if you can split it into 1 or more subsequences such that each subsequence consists
        of consecutive integers and has length at least 3.

     

    Example 1:

    Input: [1,2,3,3,4,5]
Output: True
Explanation:
You can split them into two consecutive subsequences :
1, 2, 3
3, 4, 5

    Example 2:

    Input: [1,2,3,3,4,4,5,5]
Output: True
Explanation:
You can split them into two consecutive subsequences :
1, 2, 3, 4, 5
3, 4, 5

    Example 3:

    Input: [1,2,3,4,4,5]
Output: False

     

    Constraints:

    
        1 <= nums.length <= 10000
-----------------

# 90_Subsets_II
# 90. Subsets II

Given a collection of integers that might contain duplicates, nums,
        return all possible subsets (the power set).

    Note: The solution set must not contain duplicate subsets.

    Example:

    Input: [1,2,2]
Output:
[
  [2],
  [1],
  [1,2,2],
  [2,2],
  [1,2],
  []
]
-----------------

# 602_Friend_Requests_II_Who_Has_the_Most_Friends
# 602. Friend Requests II: Who Has the Most Friends

In social network like Facebook or Twitter, people send friend requests and accept others'
    requests as well.
     
    Table request_accepted holds the data of friend acceptance, while
    requester_id and accepter_id both are the id of a person.

     

    | requester_id | accepter_id | accept_date|
|--------------|-------------|------------|
| 1            | 2           | 2016_06-03 |
| 1            | 3           | 2016-06-08 |
| 2            | 3           | 2016-06-08 |
| 3            | 4           | 2016-06-09 |

    Write a query to find the the people who has most friends and the most friends number. For the
    sample data above, the result is:

    | id | num |
|----|-----|
| 3  | 3   |

    Note:

    
        It is guaranteed there is only 1 people having the most friends.
        The friend request could only been accepted once, which mean there is no multiple
            records with the same requester_id and accepter_id value.
             
            Explanation:
            The person with id '3' is a friend of people '1', '2' and '4',
            so he has 3 friends in total, which is the most number than any others.
             
            Follow-up:
            In the real world, multiple people could have the same most number of friends, can you
            find all these people in this case?
-----------------

# 1824_Minimum_Sideway_Jumps
# 1824. Minimum Sideway Jumps


-----------------

# 162_Find_Peak_Element
# 162. Find Peak Element

A peak element is an element that is greater than its neighbors.

    Given an input array nums, where nums[i] ≠ nums[i+1], find a
        peak element and return its index.

    The array may contain multiple peaks, in that case return the index to any one of the peaks
        is fine.

    You may imagine that nums[-1] = nums[n] = -∞.

    Example 1:

    Input: nums = [1,2,3,1]
Output: 2
Explanation: 3 is a peak element and your function should return the index number 2.

    Example 2:

    Input: nums = [1,2,1,3,5,6,4]
Output: 1 or 5
Explanation: Your function can return either index number 1 where the peak element is 2,
             or index number 5 where the peak element is 6.

    Note:

    Your solution should be in logarithmic complexity.
-----------------

# 1651_Hopper_Company_Queries_III
# 1651. Hopper Company Queries III


-----------------

# 280_Wiggle_Sort
# 280. Wiggle Sort

Given an unsorted array nums, reorder it in-place such that nums[0]
        <= nums[1] >= nums[2] <= nums[3]....

    Example:

    Input: nums = [3,5,2,1,6,4]
Output: One possible answer is [3,5,1,6,2,4]
-----------------

# 1614_Maximum_Nesting_Depth_of_the_Parentheses
# 1614. Maximum Nesting Depth of the Parentheses


-----------------

# 854_K-Similar_Strings
# 854. K-Similar Strings

Strings A and B are K-similar (for some
        non-negative integer K) if we can swap the positions of two letters in
        A exactly K times so that the resulting string equals
        B.

    Given two anagrams A and B, return the smallest K for
        which A and B are K-similar.

    Example 1:

    Input: A = "ab", B = "ba"
Output: 1
-----------------

# 1073_Adding_Two_Negabinary_Numbers
# 1073. Adding Two Negabinary Numbers

Given two numbers arr1 and arr2 in base -2, return
        the result of adding them together.

    Each number is given in array format:  as an array of 0s and 1s, from most
        significant bit to least significant bit.  For example, arr = [1,1,0,1]
        represents the number (-2)^3 + (-2)^2 + (-2)^0 = -3.  A number arr
        in array format is also guaranteed to have no leading zeros: either arr
            == [0] or arr[0] == 1.

    Return the result of adding arr1 and arr2 in the same format: as an
        array of 0s and 1s with no leading zeros.

     

    Example 1:

    Input: arr1 = [1,1,1,1,1], arr2 = [1,0,1]
Output: [1,0,0,0,0]
Explanation: arr1 represents 11, arr2 represents 5, the output represents 16.

     

    Note:

    
        1 <= arr1.length <= 1000
        1 <= arr2.length <= 1000
        arr1 and arr2 have no leading zeros
        arr1[i] is 0 or 1
        arr2[i] is 0 or 1
-----------------

# 192_Word_Frequency
# 192. Word Frequency

Write a bash script to calculate the frequency of each word in a text file
        words.txt.

    For simplicity sake, you may assume:

    
        words.txt contains only lowercase characters and space '
            ' characters.
        
        Each word must consist of lowercase characters only.
        Words are separated by one or more whitespace characters.
    

    Example:

    Assume that words.txt has the following content:

    the day is sunny the the
the sunny is is

    Your script should output the following, sorted by descending frequency:

    the 4
is 3
sunny 2
day 1

    Note:

    
        Don't worry about handling ties, it is guaranteed that each word's frequency
            count is unique.
        
        Could you write it in one-line using Unix pipes?
-----------------

# 1466_Reorder_Routes_to_Make_All_Paths_Lead_to_the_City_Zero
# 1466. Reorder Routes to Make All Paths Lead to the City Zero


-----------------

# 1758_Minimum_Changes_To_Make_Alternating_Binary_String
# 1758. Minimum Changes To Make Alternating Binary String


-----------------

# 236_Lowest_Common_Ancestor_of_a_Binary_Tree
# 236. Lowest Common Ancestor of a Binary Tree

Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the
        tree.

    According to the definition of LCA on Wikipedia: “The lowest
        common ancestor is defined between two nodes p and q as the lowest node in T that
        has both p and q as descendants (where we allow a node to be a descendant of
            itself).”

    Given the following binary tree:  root = [3,5,1,6,2,0,8,null,null,7,4]
    
     

    Example 1:

    Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
Output: 3
Explanation: The LCA of nodes 5 and 1 is 3.

    Example 2:

    Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
Output: 5
Explanation: The LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition.

     

    Note:

    
        All of the nodes' values will be unique.
        p and q are different and both values will exist in the binary tree.
-----------------

# 784_Letter_Case_Permutation
# 784. Letter Case Permutation

Given a string S, we can transform every letter individually to be lowercase or
        uppercase to create another string.  Return a list of all possible strings we could
        create.

    Examples:
Input: S = "a1b2"
Output: ["a1b2", "a1B2", "A1b2", "A1B2"]

Input: S = "3z4"
Output: ["3z4", "3Z4"]

Input: S = "12345"
Output: ["12345"]

    Note:

    
        S will be a string with length between 1 and 12.
        
        S will consist only of letters or digits.
-----------------

# 1818_Minimum_Absolute_Sum_Difference
# 1818. Minimum Absolute Sum Difference


-----------------

# 625_Minimum_Factorization
# 625. Minimum Factorization

Given a positive integer a, find the smallest positive integer b
        whose multiplication of each digit equals to a. 

    
        If there is no answer or the answer is not fit in 32-bit signed integer, then return 0.

    
        Example 1
        Input:
    48 
    Output:
    68
    

    
        Example 2
        Input:
    15

    Output:
    35
-----------------

# 1078_Occurrences_After_Bigram
# 1078. Occurrences After Bigram

Given words first and second, consider occurrences in
        some text of the form "first second third", where
        second comes immediately after first, and third comes
        immediately after second.

    For each such occurrence, add "third" to the answer, and return the
        answer.

     

    Example 1:

    Input: text = "alice is a good girl she is a good student", first = "a", second = "good"
Output: ["girl","student"]
-----------------

# 649_Dota2_Senate
# 649. Dota2 Senate

In the world of Dota2, there are two parties: the Radiant and the
        Dire.

    The Dota2 senate consists of senators coming from two parties. Now the senate wants to make a
        decision about a change in the Dota2 game. The voting for this change is a round-based
        procedure. In each round, each senator can exercise one of the two rights:

    
        Ban one senator's right:
            A senator can make another senator lose all his rights in this and all the
            following rounds.
        
        Announce the victory:
            If this senator found the senators who still have rights to vote are all from the
                same party, he can announce the victory and make the decision about the change
            in the game.
        
    

     

    Given a string representing each senator's party belonging. The character 'R' and
        'D' represent the Radiant party and the Dire party
        respectively. Then if there are n senators, the size of the given string will
        be n.

    The round-based procedure starts from the first senator to the last senator in the given
        order. This procedure will last until the end of voting. All the senators who have lost
        their rights will be skipped during the procedure.

    Suppose every senator is smart enough and will play the best strategy for his own party, you
        need to predict which party will finally announce the victory and make the change in the
        Dota2 game. The output should be Radiant or Dire.

    Example 1:

    Input: "RD"
Output: "Radiant"
Explanation: The first senator comes from Radiant and he can just ban the next senator's right in the round 1.
And the second senator can't exercise any rights any more since his right has been banned.
And in the round 2, the first senator can just announce the victory since he is the only guy in the senate who can vote.

     

    Example 2:

    Input: "RDD"
Output: "Dire"
Explanation:
The first senator comes from Radiant and he can just ban the next senator's right in the round 1.
And the second senator can't exercise any rights anymore since his right has been banned.
And the third senator comes from Dire and he can ban the first senator's right in the round 1.
And in the round 2, the third senator can just announce the victory since he is the only guy in the senate who can vote.

     

    Note:

    
        The length of the given string will in the range [1, 10,000].
-----------------

# 1165_Single-Row_Keyboard
# 1165. Single-Row Keyboard

There is a special keyboard with all keys in a single row.

    Given a string keyboard of length 26 indicating the layout of the keyboard
        (indexed from 0 to 25), initially your finger is at index 0. To type a character, you
        have to move your finger to the index of the desired character. The time taken to move your
        finger from index i to index j is |i - j|.

    You want to type a string word. Write a function to calculate how much time it
        takes to type it with one finger.

     
    Example 1:

    Input: keyboard = "abcdefghijklmnopqrstuvwxyz", word = "cba"
Output: 4
Explanation: The index moves from 0 to 2 to write 'c' then to 1 to write 'b' then to 0 again to write 'a'.
Total time = 2 + 1 + 1 = 4.

    Example 2:

    Input: keyboard = "pqrstuvwxyzabcdefghijklmno", word = "leetcode"
Output: 73

     
    Constraints:

    
        keyboard.length == 26
        keyboard contains each English lowercase
            letter exactly once in some order.
        
        1 <= word.length <= 10^4
        word[i] is an English lowercase letter.
-----------------

# 387_First_Unique_Character_in_a_String
# 387. First Unique Character in a String

Given a string, find the first non-repeating character in it and return it's index. If it
        doesn't exist, return -1.
    
    Examples:
    s = "leetcode"
return 0.

s = "loveleetcode",
return 2.

    

    
        Note: You may assume the string contain only lowercase letters.
-----------------

# 755_Pour_Water
# 755. Pour Water

We are given an elevation map, heights[i] representing the height of the
        terrain at that index. The width at each index is 1. After V units of water
        fall at index K, how much water is at each index?
    
    
        Water first drops at index K and rests on top of the highest terrain or water
        at that index. Then, it flows according to the following rules:
    If the droplet would eventually fall by moving left, then move left.
    Otherwise, if the droplet would eventually fall by moving right, then move right.
    Otherwise, rise at it's current position.
    Here, "eventually fall" means that the droplet will eventually be at a lower level if it moves
    in that direction.
    Also, "level" means the height of the terrain plus any water in that column.
    
    We can assume there's infinitely high terrain on the two sides out of bounds of the array. Also,
    there could not be partial water being spread out evenly on more than 1 grid block - each unit
    of water has to be in exactly one block.
    

    Example 1:
    Input: heights = [2,1,1,2,1,2,2], V = 4, K = 3
Output: [2,2,2,3,2,2,2]
Explanation:
#       #
#       #
##  # ###
#########
 0123456    <- index

The first drop of water lands at index K = 3:

#       #
#   w   #
##  # ###
#########
 0123456

When moving left or right, the water can only move to the same level or a lower level.
(By level, we mean the total height of the terrain plus any water in that column.)
Since moving left will eventually make it fall, it moves left.
(A droplet "made to fall" means go to a lower height than it was at previously.)

#       #
#       #
## w# ###
#########
 0123456

Since moving left will not make it fall, it stays in place.  The next droplet falls:

#       #
#   w   #
## w# ###
#########
 0123456

Since the new droplet moving left will eventually make it fall, it moves left.
Notice that the droplet still preferred to move left,
even though it could move right (and moving right makes it fall quicker.)

#       #
#  w    #
## w# ###
#########
 0123456

#       #
#       #
##ww# ###
#########
 0123456

After those steps, the third droplet falls.
Since moving left would not eventually make it fall, it tries to move right.
Since moving right would eventually make it fall, it moves right.

#       #
#   w   #
##ww# ###
#########
 0123456

#       #
#       #
##ww#w###
#########
 0123456

Finally, the fourth droplet falls.
Since moving left would not eventually make it fall, it tries to move right.
Since moving right would not eventually make it fall, it stays in place:

#       #
#   w   #
##ww#w###
#########
 0123456

The final answer is [2,2,2,3,2,2,2]:

    #
 #######
 #######
 0123456

    

    Example 2:
    Input: heights = [1,2,3,4], V = 2, K = 2
Output: [2,3,3,4]
Explanation:
The last droplet settles at index 1, since moving further left would not cause it to eventually fall to a lower height.

    

    Example 3:
    Input: heights = [3,1,3], V = 5, K = 1
Output: [4,4,4]

    

    Note:
    
        heights will have length in [1, 100] and contain integers in
            [0, 99].
        
        V will be in range [0, 2000].
        K will be in range [0, heights.length - 1].
-----------------

# 749_Contain_Virus
# 749. Contain Virus

A virus is spreading rapidly, and your task is to quarantine the infected area by installing
        walls.
    
    
        The world is modeled as a 2-D array of cells, where 0 represents uninfected
        cells, and 1 represents cells contaminated with the virus. A wall (and only one
        wall) can be installed between any two 4-directionally adjacent cells, on the shared
        boundary.
    
    
        Every night, the virus spreads to all neighboring cells in all four directions unless
        blocked by a wall.
        Resources are limited. Each day, you can install walls around only one region -- the
        affected area (continuous block of infected cells) that threatens the most uninfected cells
        the following night. There will never be a tie.
    
    
        Can you save the day? If so, what is the number of walls required? If not, and the world
        becomes fully infected, return the number of walls used.
    
    

    Example 1:
    Input: grid =
[[0,1,0,0,0,0,0,1],
 [0,1,0,0,0,0,0,1],
 [0,0,0,0,0,0,0,1],
 [0,0,0,0,0,0,0,0]]
Output: 10
Explanation:
There are 2 contaminated regions.
On the first day, add 5 walls to quarantine the viral region on the left. The board after the virus spreads is:

[[0,1,0,0,0,0,1,1],
 [0,1,0,0,0,0,1,1],
 [0,0,0,0,0,0,1,1],
 [0,0,0,0,0,0,0,1]]

On the second day, add 5 walls to quarantine the viral region on the right. The virus is fully contained.

    

    Example 2:
    Input: grid =
[[1,1,1],
 [1,0,1],
 [1,1,1]]
Output: 4
Explanation: Even though there is only one cell saved, there are 4 walls built.
Notice that walls are only built on the shared boundary of two different cells.

    

    Example 3:
    Input: grid =
[[1,1,1,0,0,0,0,0,0],
 [1,0,1,0,1,1,1,1,1],
 [1,1,1,0,0,0,0,0,0]]
Output: 13
Explanation: The region on the left only builds two new walls.

    

    Note:
    
        The number of rows and columns of grid will each be in the range [1,
            50].
        
        Each grid[i][j] will be either 0 or 1.
        Throughout the described process, there is always a contiguous viral region that will
            infect strictly more uncontaminated squares in the next round.
-----------------

# 1399_Count_Largest_Group
# 1399. Count Largest Group


-----------------

# 1522_Diameter_of_N-Ary_Tree
# 1522. Diameter of N-Ary Tree


-----------------

# 303_Range_Sum_Query_-_Immutable
# 303. Range Sum Query - Immutable

Given an integer array nums, find the sum of the elements between indices i and
        j (i ≤ j), inclusive.

    Example:
    Given nums = [-2, 0, 3, -5, 2, -1]

sumRange(0, 2) -> 1
sumRange(2, 5) -> -1
sumRange(0, 5) -> -3

    

    Note:
    
        You may assume that the array does not change.
        There are many calls to sumRange function.
-----------------

# 1182_Shortest_Distance_to_Target_Color
# 1182. Shortest Distance to Target Color

You are given an array colors, in which there are three colors: 1,
        2 and 3.

    You are also given some queries. Each query consists of two integers i and
        c, return the shortest distance between the given
        index i and the target color c. If there is no solution
        return -1.

     
    Example 1:

    Input: colors = [1,1,2,1,3,2,2,3,3], queries = [[1,3],[2,2],[6,1]]
Output: [3,0,3]
Explanation: 
The nearest 3 from index 1 is at index 4 (3 steps away).
The nearest 2 from index 2 is at index 2 itself (0 steps away).
The nearest 1 from index 6 is at index 3 (3 steps away).

    Example 2:

    Input: colors = [1,2], queries = [[0,3]]
Output: [-1]
Explanation: There is no 3 in the array.

     
    Constraints:

    
        1 <= colors.length <= 5*10^4
        1 <= colors[i] <= 3
        1 <= queries.length <= 5*10^4
        queries[i].length == 2
        0 <= queries[i][0] < colors.length
        1 <= queries[i][1] <= 3
-----------------

# 563_Binary_Tree_Tilt
# 563. Binary Tree Tilt

Given a binary tree, return the tilt of the whole tree.

    The tilt of a tree node is defined as the absolute difference between the sum
        of all left subtree node values and the sum of all right subtree node values. Null node has
        tilt 0.

    The tilt of the whole tree is defined as the sum of all nodes' tilt.

    Example:
    Input:
         1
       /   \
      2     3
Output: 1
Explanation:
Tilt of node 2 : 0
Tilt of node 3 : 0
Tilt of node 1 : |2-3| = 1
Tilt of binary tree : 0 + 0 + 1 = 1

    

    Note:
    
        The sum of node values in any subtree won't exceed the range of 32-bit integer.
        All the tilt values won't exceed the range of 32-bit integer.
-----------------

# 646_Maximum_Length_of_Pair_Chain
# 646. Maximum Length of Pair Chain

You are given n pairs of numbers. In every pair, the first number is always
        smaller than the second number.
    

    
        Now, we define a pair (c, d) can follow another pair (a, b) if and
        only if b < c. Chain of pairs can be formed in this fashion.
    

    
        Given a set of pairs, find the length longest chain which can be formed. You needn't use up
        all the given pairs. You can select pairs in any order.
    

    Example 1:
    Input: [[1,2], [2,3], [3,4]]
Output: 2
Explanation: The longest chain is [1,2] -> [3,4]

    

    Note:
    
        The number of given pairs will be in the range [1, 1000].
-----------------

# 1655_Distribute_Repeating_Integers
# 1655. Distribute Repeating Integers


-----------------

# 974_Subarray_Sums_Divisible_by_K
# 974. Subarray Sums Divisible by K

Given an array A of integers, return the number of (contiguous, non-empty)
        subarrays that have a sum divisible by K.
-----------------

# 964_Least_Operators_to_Express_Number
# 964. Least Operators to Express Number

Given a single positive integer x, we will write an expression of the form
        x (op1) x (op2) x (op3) x ... where each operator op1, op2,
        etc. is either addition, subtraction, multiplication, or division (+,
        -, *, or /).  For example, with x =
            3, we might write 3 * 3 / 3 + 3 - 3 which is a value of 3.

    When writing such an expression, we adhere to the following conventions:

    
        The division operator (/) returns rational numbers.
        There are no parentheses placed anywhere.
        We use the usual order of operations: multiplication and division happens before
            addition and subtraction.
        
        It's not allowed to use the unary negation operator (-).  For
            example, "x - x" is a valid expression as it only uses
            subtraction, but "-x + x" is not because it uses negation.
        
    

    We would like to write an expression with the least number of operators such that the
        expression equals the given target.  Return the least number of operators
        used.
-----------------

# 1518_Water_Bottles
# 1518. Water Bottles


-----------------

# 967_Numbers_With_Same_Consecutive_Differences
# 967. Numbers With Same Consecutive Differences

Return all non-negative integers of length N such that the
        absolute difference between every two consecutive digits is K.

    Note that every number in the answer must not have leading
        zeros except for the number 0 itself. For example,
        01 has one leading zero and is invalid, but 0 is valid.

    You may return the answer in any order.

     

    Example 1:

    Input: N = 3, K = 7
Output: [181,292,707,818,929]
Explanation: Note that 070 is not a valid number, because it has leading zeroes.
-----------------

# 632_Smallest_Range_Covering_Elements_from_K_Lists
# 632. Smallest Range Covering Elements from K Lists

You have k lists of sorted integers in ascending order. Find the smallest
        range that includes at least one number from each of the k lists.

    We define the range [a,b] is smaller than range [c,d] if b-a < d-c or a
        < c if b-a == d-c.

     

    Example 1:

    Input: [[4,10,15,24,26], [0,9,12,20], [5,18,22,30]]
Output: [20,24]
Explanation:
List 1: [4, 10, 15, 24,26], 24 is in range [20,24].
List 2: [0, 9, 12, 20], 20 is in range [20,24].
List 3: [5, 18, 22, 30], 22 is in range [20,24].

     

    Note:

    
        The given list may contain duplicates, so ascending order means >= here.
        1 <= k <= 3500
        -105 <= value of elements <= 105.
-----------------

# 957_Prison_Cells_After_N_Days
# 957. Prison Cells After N Days

There are 8 prison cells in a row, and each cell is either occupied or vacant.

    Each day, whether the cell is occupied or vacant changes according to the following
        rules:

    
        If a cell has two adjacent neighbors that are both occupied or both vacant, then
            the cell becomes occupied.
        
        Otherwise, it becomes vacant.
    

    (Note that because the prison is a row, the first and the last cells in the row can't
        have two adjacent neighbors.)

    We describe the current state of the prison in the following way: cells[i] ==
        1 if the i-th cell is occupied, else cells[i] == 0.

    Given the initial state of the prison, return the state of the prison after N
        days (and N such changes described above.)
-----------------

# 1071_Greatest_Common_Divisor_of_Strings
# 1071. Greatest Common Divisor of Strings

For strings S and T, we say "T divides
        S" if and only if S = T + ... + T  (T
        concatenated with itself 1 or more times)

    Return the largest string X such that X divides str1 and X divides str2.

     

    Example 1:

    Input: str1 = "ABCABC", str2 = "ABC"
Output: "ABC"

    Example 2:

    Input: str1 = "ABABAB", str2 = "ABAB"
Output: "AB"

    Example 3:

    Input: str1 = "LEET", str2 = "CODE"
Output: ""

     

    Note:

    
        1 <= str1.length <= 1000
        1 <= str2.length <= 1000
        str1[i] and str2[i] are English uppercase letters.
-----------------

# 814_Binary_Tree_Pruning
# 814. Binary Tree Pruning

We are given the head node root of a binary tree, where additionally every
        node's value is either a 0 or a 1.

    Return the same tree where every subtree (of the given tree) not containing a 1 has been
        removed.

    (Recall that the subtree of a node X is X, plus every node that is a descendant of X.)

    Example 1:
Input: [1,null,0,0,1]
Output: [1,null,0,null,1]

Explanation:
Only the red nodes satisfy the property "every subtree not containing a 1".
The diagram on the right represents the answer.

    Example 2:
Input: [1,0,1,0,0,0,1]
Output: [1,null,1,null,1]

    Example 3:
Input: [1,1,0,1,1,0,1,0]
Output: [1,1,0,1,1,null,1]

    Note: 

    
        The binary tree will have at most 100 nodes.
        The value of each node will only be 0 or 1.
-----------------

# 1782_Count_Pairs_Of_Nodes
# 1782. Count Pairs Of Nodes


-----------------

# 697_Degree_of_an_Array
# 697. Degree of an Array

Given a non-empty array of non-negative integers nums, the degree of this
        array is defined as the maximum frequency of any one of its elements.
    Your task is to find the smallest possible length of a (contiguous) subarray of
        nums, that has the same degree as nums.

    Example 1:
    Input: [1, 2, 2, 3, 1]
Output: 2
Explanation:
The input array has a degree of 2 because both elements 1 and 2 appear twice.
Of the subarrays that have the same degree:
[1, 2, 2, 3, 1], [1, 2, 2, 3], [2, 2, 3, 1], [1, 2, 2], [2, 2, 3], [2, 2]
The shortest length is 2. So return 2.

    

    Example 2:
    Input: [1,2,2,3,1,4,2]
Output: 6

    

    Note:
    nums.length will be between 1 and 50,000.
    nums[i] will be an integer between 0 and 49,999.
-----------------

# 771_Jewels_and_Stones
# 771. Jewels and Stones

You're given strings J representing the types of stones that are jewels, and
        S representing the stones you have.  Each character in S is a
        type of stone you have.  You want to know how many of the stones you have are also
        jewels.

    The letters in J are guaranteed distinct, and all characters in J
        and S are letters. Letters are case sensitive, so "a" is
        considered a different type of stone from "A".

    Example 1:

    Input: J = "aA", S = "aAAbbbb"
Output: 3

    Example 2:

    Input: J = "z", S = "ZZ"
Output: 0

    Note:

    
        S and J will consist of letters and have length at most 50.
        
        The characters in J are distinct.
-----------------

# 934_Shortest_Bridge
# 934. Shortest Bridge

In a given 2D binary array A, there are two islands.  (An island is a
        4-directionally connected group of 1s not connected to any other 1s.)

    Now, we may change 0s to 1s so as to connect the two islands
        together to form 1 island.

    Return the smallest number of 0s that must be flipped.  (It is guaranteed
        that the answer is at least 1.)

     

    Example 1:

    Input: [[0,1],[1,0]]
Output: 1
-----------------

# 872_Leaf-Similar_Trees
# 872. Leaf-Similar Trees

Consider all the leaves of a binary tree.  From left to right order, the values of
        those leaves form a leaf value sequence.

    

    For example, in the given tree above, the leaf value sequence is (6, 7, 4, 9, 8).
    

    Two binary trees are considered leaf-similar if their leaf value sequence is
        the same.

    Return true if and only if the two given trees with head nodes
        root1 and root2 are leaf-similar.

     

    Note:

    
        Both of the given trees will have between 1 and 100 nodes.
-----------------

# 1245_Tree_Diameter
# 1245. Tree Diameter

Given an undirected tree, return its diameter: the number of edges in a
        longest path in that tree.

    The tree is given as an array of edges where edges[i] = [u,
        v] is a bidirectional edge between nodes u and v. 
        Each node has labels in the set {0, 1, ..., edges.length}.

     
    Example 1:

    

    Input: edges = [[0,1],[0,2]]
Output: 2
Explanation: 
A longest path of the tree is the path 1 - 0 - 2.

    Example 2:

    

    Input: edges = [[0,1],[1,2],[2,3],[1,4],[4,5]]
Output: 4
Explanation: 
A longest path of the tree is the path 3 - 2 - 1 - 4 - 5.

     
    Constraints:

    
        0 <= edges.length < 10^4
        edges[i][0] != edges[i][1]
        0 <= edges[i][j] <= edges.length
        The given edges form an undirected tree.
-----------------

# 887_Super_Egg_Drop
# 887. Super Egg Drop

You are given K eggs, and you have access to a building with N
        floors from 1 to N. 

    Each egg is identical in function, and if an egg breaks, you cannot drop it again.

    You know that there exists a floor F with 0 <= F <= N such
        that any egg dropped at a floor higher than F will break, and any egg dropped
        at or below floor F will not break.

    Each move, you may take an egg (if you have an unbroken one) and drop it from any
        floor X (with 1 <= X <= N). 

    Your goal is to know with certainty what the value of
        F is.

    What is the minimum number of moves that you need to know with certainty what
        F is, regardless of the initial value of F?
-----------------

# 1139_Largest_1-Bordered_Square
# 1139. Largest 1-Bordered Square

Given a 2D grid of 0s and 1s, return the number of
        elements in the largest square subgrid that has all
        1s on its border, or 0 if such a subgrid doesn't
        exist in the grid.

     
    Example 1:

    Input: grid = [[1,1,1],[1,0,1],[1,1,1]]
Output: 9

    Example 2:

    Input: grid = [[1,1,0,0]]
Output: 1

     
    Constraints:

    
        1 <= grid.length <= 100
        1 <= grid[0].length <= 100
        grid[i][j] is 0 or 1
-----------------

# 638_Shopping_Offers
# 638. Shopping Offers

In LeetCode Store, there are some kinds of items to sell. Each item has a price.
    

    
        However, there are some special offers, and a special offer consists of one or more
        different kinds of items with a sale price.
    

    
        You are given the each item's price, a set of special offers, and the number we need to buy
        for each item.
        The job is to output the lowest price you have to pay for exactly certain items as
        given, where you could make optimal use of the special offers.
    

    
        Each special offer is represented in the form of an array, the last number represents the
        price you need to pay for this special offer, other numbers represents how many specific
        items you could get if you buy this offer.
    

    You could use any of special offers as many times as you want.

    Example 1:
    Input: [2,5], [[3,0,5],[1,2,10]], [3,2]
Output: 14
Explanation:
There are two kinds of items, A and B. Their prices are $2 and $5 respectively.
In special offer 1, you can pay $5 for 3A and 0B
In special offer 2, you can pay $10 for 1A and 2B.
You need to buy 3A and 2B, so you may pay $10 for 1A and 2B (special offer #2), and $4 for 2A.

    

    Example 2:
    Input: [2,3,4], [[1,1,0,4],[2,2,1,9]], [1,2,1]
Output: 11
Explanation:
The price of A is $2, and $3 for B, $4 for C.
You may pay $4 for 1A and 1B, and $9 for 2A ,2B and 1C.
You need to buy 1A ,2B and 1C, so you may pay $4 for 1A and 1B (special offer #1), and $3 for 1B, $4 for 1C.
You cannot add more items, though only $9 for 2A ,2B and 1C.

    

    Note:
    
        There are at most 6 kinds of items, 100 special offers.
        For each item, you need to buy at most 6 of them.
        You are not allowed to buy more items than you want, even if that would lower the
            overall price.
-----------------

# 398_Random_Pick_Index
# 398. Random Pick Index

Given an array of integers with possible duplicates, randomly output the index of a given
        target number. You can assume that the given target number must exist in the array.

    Note:
        The array size can be very large. Solution that uses too much extra space will not pass the
        judge.

    Example:

    int[] nums = new int[] {1,2,3,3,3};
Solution solution = new Solution(nums);

// pick(3) should return either index 2, 3, or 4 randomly. Each index should have equal probability of returning.
solution.pick(3);

// pick(1) should return 0. Since in the array only nums[0] is equal to 1.
solution.pick(1);
-----------------

# 246_Strobogrammatic_Number
# 246. Strobogrammatic Number

A strobogrammatic number is a number that looks the same when rotated 180 degrees (looked at
        upside down).

    Write a function to determine if a number is strobogrammatic. The number is represented as a
        string.

    Example 1:

    Input:  "69"
Output: true

    Example 2:

    Input:  "88"
Output: true

    Example 3:

    Input:  "962"
Output: false
-----------------

# 1387_Sort_Integers_by_The_Power_Value
# 1387. Sort Integers by The Power Value


-----------------

# 404_Sum_of_Left_Leaves
# 404. Sum of Left Leaves

Find the sum of all left leaves in a given binary tree.

    Example:
        3
   / \
  9  20
    /  \
   15   7

There are two left leaves in the binary tree, with values 9 and 15 respectively. Return 24.
-----------------

# 1150_Check_If_a_Number_Is_Majority_Element_in_a_Sorted_Array
# 1150. Check If a Number Is Majority Element in a Sorted Array

Given an array nums sorted in non-decreasing order, and a
        number target, return True if and only if target is a
        majority element.

    A majority element is an element that appears more than
        N/2 times in an array of length N.

     

    Example 1:

    Input: nums = [2,4,5,5,5,5,5,6,6], target = 5
Output: true
Explanation: 
The value 5 appears 5 times and the length of the array is 9.
Thus, 5 is a majority element because 5 > 9/2 is true.

    Example 2:

    Input: nums = [10,100,101,101], target = 101
Output: false
Explanation: 
The value 101 appears 2 times and the length of the array is 4.
Thus, 101 is not a majority element because 2 > 4/2 is false.

     

    Note:

    
        1 <= nums.length <= 1000
        1 <= nums[i] <= 10^9
        1 <= target <= 10^9
-----------------

# 1644_Lowest_Common_Ancestor_of_a_Binary_Tree_II
# 1644. Lowest Common Ancestor of a Binary Tree II


-----------------

# 1171_Remove_Zero_Sum_Consecutive_Nodes_from_Linked_List
# 1171. Remove Zero Sum Consecutive Nodes from Linked List

Given the head of a linked list, we repeatedly delete consecutive sequences of
        nodes that sum to 0 until there are no such sequences.

    After doing so, return the head of the final linked list.  You may return any such
        answer.

     
    (Note that in the examples below, all sequences are serializations of ListNode
        objects.)

    Example 1:

    Input: head = [1,2,-3,3,1]
Output: [3,1]
Note: The answer [1,2,1] would also be accepted.

    Example 2:

    Input: head = [1,2,3,-3,4]
Output: [1,2,4]

    Example 3:

    Input: head = [1,2,3,-3,-2]
Output: [1]

     
    Constraints:

    
        The given linked list will contain between 1 and 1000 nodes.
        
        Each node in the linked list has -1000 <= node.val <= 1000.
-----------------

# 574_Winning_Candidate
# 574. Winning Candidate

Table: Candidate

    +-----+---------+
| id  | Name    |
+-----+---------+
| 1   | A       |
| 2   | B       |
| 3   | C       |
| 4   | D       |
| 5   | E       |
+-----+---------+

    Table: Vote

    +-----+--------------+
| id  | CandidateId  |
+-----+--------------+
| 1   |     2        |
| 2   |     4        |
| 3   |     3        |
| 4   |     2        |
| 5   |     5        |
+-----+--------------+
id is the auto-increment primary key,
CandidateId is the id appeared in Candidate table.

    Write a sql to find the name of the winning candidate, the above example will return the
        winner B.

    +------+
| Name |
+------+
| B    |
+------+

    Notes:

    
        You may assume there is no tie, in other words there will be at most one
            winning candidate.
-----------------

# 1115_Print_FooBar_Alternately
# 1115. Print FooBar Alternately

Suppose you are given the following code:

    class FooBar {
  public void foo() {
    for (int i = 0; i < n; i++) {
      print("foo");
    }
  }

  public void bar() {
    for (int i = 0; i < n; i++) {
      print("bar");
    }
  }
}

    The same instance of FooBar will be passed to two different threads. Thread A
        will call foo() while thread B will call bar(). Modify
        the given program to output "foobar" n times.

     

    Example 1:

    Input: n = 1
Output: "foobar"
Explanation: There are two threads being fired asynchronously. One of them calls foo(), while the other calls bar(). "foobar" is being output 1 time.

    Example 2:

    Input: n = 2
Output: "foobarfoobar"
Explanation: "foobar" is being output 2 times.
-----------------

# 1441_Build_an_Array_With_Stack_Operations
# 1441. Build an Array With Stack Operations


-----------------

# 1062_Longest_Repeating_Substring
# 1062. Longest Repeating Substring

Given a string S, find out the length of the longest repeating substring(s).
        Return 0 if no repeating substring exists.

     

    Example 1:

    Input: "abcd"
Output: 0
Explanation: There is no repeating substring.

    Example 2:

    Input: "abbaba"
Output: 2
Explanation: The longest repeating substrings are "ab" and "ba", each of which occurs twice.

    Example 3:

    Input: "aabcaabdaab"
Output: 3
Explanation: The longest repeating substring is "aab", which occurs 3 times.

    Example 4:

    Input: "aaaaa"
Output: 4
Explanation: The longest repeating substring is "aaaa", which occurs twice.

     

    Note:

    
        The string S consists of only lowercase English letters from 'a'
            - 'z'.
        
        1 <= S.length <= 1500
-----------------

# 1022_Sum_of_Root_To_Leaf_Binary_Numbers
# 1022. Sum of Root To Leaf Binary Numbers

Given a binary tree, each node has value 0 or 1.  Each
        root-to-leaf path represents a binary number starting with the most significant bit. 
        For example, if the path is 0 -> 1 -> 1 -> 0 -> 1, then this could
        represent 01101 in binary, which is 13.

    For all leaves in the tree, consider the numbers represented by the path from the root
        to that leaf.

    Return the sum of these numbers.

     

    Example 1:

    

    Input: [1,0,1,0,1,0,1]
Output: 22
Explanation: (100) + (101) + (110) + (111) = 4 + 5 + 6 + 7 = 22

     

    Note:

    
        The number of nodes in the tree is between 1 and 1000.
        node.val is 0 or 1.
        The answer will not exceed 2^31 - 1.
-----------------

# 1550_Three_Consecutive_Odds
# 1550. Three Consecutive Odds


-----------------

# 562_Longest_Line_of_Consecutive_One_in_Matrix
# 562. Longest Line of Consecutive One in Matrix

Given a 01 matrix M, find the longest line of consecutive one in the matrix. The line
    could be horizontal, vertical, diagonal or anti-diagonal.

    Example:
    Input:
[[0,1,1,0],
 [0,1,1,0],
 [0,0,0,1]]
Output: 3

    

    
        Hint:
        The number of elements in the given matrix will not exceed 10,000.
-----------------

# 566_Reshape_the_Matrix
# 566. Reshape the Matrix

In MATLAB, there is a very useful function called 'reshape', which can reshape a matrix into
        a new one with different size but keep its original data.
    

    
        You're given a matrix represented by a two-dimensional array, and two positive
        integers r and c representing the row number and column number
        of the wanted reshaped matrix, respectively.

    The reshaped matrix need to be filled with all the elements of the original matrix in the
        same row-traversing order as they were.
    

    
        If the 'reshape' operation with given parameters is possible and legal, output the new
        reshaped matrix; Otherwise, output the original matrix.
    

    Example 1:
    Input:
nums =
[[1,2],
 [3,4]]
r = 1, c = 4
Output:
[[1,2,3,4]]
Explanation:The row-traversing of nums is [1,2,3,4]. The new reshaped matrix is a 1 * 4 matrix, fill it row by row by using the previous list.

    

    Example 2:
    Input:
nums =
[[1,2],
 [3,4]]
r = 2, c = 4
Output:
[[1,2],
 [3,4]]
Explanation:There is no way to reshape a 2 * 2 matrix to a 2 * 4 matrix. So output the original matrix.

    

    Note:
    
        The height and width of the given matrix is in range [1, 100].
        The given r and c are all positive.
-----------------

# 1173_Immediate_Food_Delivery_I
# 1173. Immediate Food Delivery I

Table: Delivery

    +-----------------------------+---------+
| Column Name                 | Type    |
+-----------------------------+---------+
| delivery_id                 | int     |
| customer_id                 | int     |
| order_date                  | date    |
| customer_pref_delivery_date | date    |
+-----------------------------+---------+
delivery_id is the primary key of this table.
The table holds information about food delivery to customers that make orders at some date and specify a preferred delivery date (on the same order date or after it).

     

    If the preferred delivery date of the customer is the same as the order date then
        the order is called immediate otherwise it's called scheduled.
    

    Write an SQL query to find the percentage of immediate orders in the
        table, rounded to 2 decimal places.

    The query result format is in the following example:

    Delivery table:
+-------------+-------------+------------+-----------------------------+
| delivery_id | customer_id | order_date | customer_pref_delivery_date |
+-------------+-------------+------------+-----------------------------+
| 1           | 1           | 2019-08-01 | 2019-08-02                  |
| 2           | 5           | 2019-08-02 | 2019-08-02                  |
| 3           | 1           | 2019-08-11 | 2019-08-11                  |
| 4           | 3           | 2019-08-24 | 2019-08-26                  |
| 5           | 4           | 2019-08-21 | 2019-08-22                  |
| 6           | 2           | 2019-08-11 | 2019-08-13                  |
+-------------+-------------+------------+-----------------------------+

Result table:
+----------------------+
| immediate_percentage |
+----------------------+
| 33.33                |
+----------------------+
The orders with delivery id 2 and 3 are immediate while the others are scheduled.
-----------------

# 279_Perfect_Squares
# 279. Perfect Squares

Given a positive integer n, find the least number of perfect square numbers (for
        example, 1, 4, 9, 16, ...) which sum to n.

    Example 1:

    Input: n = 12
Output: 3
Explanation: 12 = 4 + 4 + 4.

    Example 2:

    Input: n = 13
Output: 2
Explanation: 13 = 4 + 9.
-----------------

# 821_Shortest_Distance_to_a_Character
# 821. Shortest Distance to a Character

Given a string S and a character C, return an array of
        integers representing the shortest distance from the character C in the string.
    

    Example 1:

    Input: S = "loveleetcode", C = 'e'
Output: [3, 2, 1, 0, 1, 0, 0, 1, 2, 2, 1, 0]

     

    Note:

    
        S string length is in [1, 10000].
        C is a single character, and guaranteed to be in string S.
        
        All letters in S and C are lowercase.
-----------------

# 1450_Number_of_Students_Doing_Homework_at_a_Given_Time
# 1450. Number of Students Doing Homework at a Given Time


-----------------

# 1743_Restore_the_Array_From_Adjacent_Pairs
# 1743. Restore the Array From Adjacent Pairs


-----------------

# 1249_Minimum_Remove_to_Make_Valid_Parentheses
# 1249. Minimum Remove to Make Valid Parentheses

Given a string s of '(' , ')' and
        lowercase English characters. 

    Your task is to remove the minimum number of parentheses ( '(' or ')', in
        any positions ) so that the resulting parentheses string is valid and return
        any valid string.

    Formally, a parentheses string is valid if and only if:

    
        It is the empty string, contains only lowercase characters, or
        It can be written as AB (A concatenated with B),
            where A and B are valid strings, or
        
        It can be written as (A), where A is a valid
            string.
        
    

     
    Example 1:

    Input: s = "lee(t(c)o)de)"
Output: "lee(t(c)o)de"
Explanation: "lee(t(co)de)" , "lee(t(c)ode)" would also be accepted.

    Example 2:

    Input: s = "a)b(c)d"
Output: "ab(c)d"

    Example 3:

    Input: s = "))(("
Output: ""
Explanation: An empty string is also valid.

    Example 4:

    Input: s = "(a(b(c)d)"
Output: "a(b(c)d)"

     
    Constraints:

    
        1 <= s.length <= 10^5
        s[i] is one of  '(' , ')'
            and lowercase English letters.
-----------------

# 920_Number_of_Music_Playlists
# 920. Number of Music Playlists

Your music player contains N different songs and she wants to listen to
        L (not necessarily different) songs during your trip.  You create a
        playlist so that:

    
        Every song is played at least once
        A song can only be played again only if K other songs have been
            played
        
    

    Return the number of possible playlists.  As the answer can be very large,
        return it modulo 10^9 + 7.
-----------------

# 1442_Count_Triplets_That_Can_Form_Two_Arrays_of_Equal_XOR
# 1442. Count Triplets That Can Form Two Arrays of Equal XOR


-----------------

# 666_Path_Sum_IV
# 666. Path Sum IV

If the depth of a tree is smaller than 5, then this tree can be represented by a
        list of three-digits integers.

    For each integer in this list:

    
        The hundreds digit represents the depth D of this node, 1 <= D
            <= 4.
        The tens digit represents the position P of this node in the level it
            belongs to, 1 <= P <= 8. The position is the same as that in a full
            binary tree.
        
        The units digit represents the value V of this node, 0 <= V <=
            9.
    

     

    Given a list of ascending three-digits integers representing a binary tree with
        the depth smaller than 5, you need to return the sum of all paths from the root towards the
        leaves.

    Example 1:

    Input: [113, 215, 221]
Output: 12
Explanation:
The tree that the list represents is:
    3
   / \
  5   1

The path sum is (3 + 5) + (3 + 1) = 12.

     

    Example 2:

    Input: [113, 221]
Output: 4
Explanation:
The tree that the list represents is:
    3
     \
      1

The path sum is (3 + 1) = 4.
-----------------

# 501_Find_Mode_in_Binary_Search_Tree
# 501. Find Mode in Binary Search Tree

Given a binary search tree (BST) with duplicates, find all the mode(s) (the
        most frequently occurred element) in the given BST.

    Assume a BST is defined as follows:

    
        The left subtree of a node contains only nodes with keys less than or equal to
            the node's key.
        
        The right subtree of a node contains only nodes with keys greater than or equal
            to the node's key.
        
        Both the left and right subtrees must also be binary search trees.
    

     

    For example:
        Given BST [1,null,2,2],

       1
    \
     2
    /
   2

     

    return [2].

    Note: If a tree has more than one mode, you can return them in any order.

    Follow up: Could you do that without using any extra space? (Assume that the implicit
        stack space incurred due to recursion does not count).
-----------------

# 1397_Find_All_Good_Strings
# 1397. Find All Good Strings


-----------------

# 1451_Rearrange_Words_in_a_Sentence
# 1451. Rearrange Words in a Sentence


-----------------

# 382_Linked_List_Random_Node
# 382. Linked List Random Node

Given a singly linked list, return a random node's value from the linked list. Each node must
        have the same probability of being chosen.

    Follow up:
        What if the linked list is extremely large and its length is unknown to you? Could you solve
        this efficiently without using extra space?
    

    Example:
    // Init a singly linked list [1,2,3].
ListNode head = new ListNode(1);
head.next = new ListNode(2);
head.next.next = new ListNode(3);
Solution solution = new Solution(head);

// getRandom() should return either 1, 2, or 3 randomly. Each element should have equal probability of returning.
solution.getRandom();
-----------------

# 1609_Even_Odd_Tree
# 1609. Even Odd Tree


-----------------

# 598_Range_Addition_II
# 598. Range Addition II

Given an m * n matrix M initialized with all 0's and several update operations.
    
    Operations are represented by a 2D array, and each operation is represented by an array with
        two positive integers a and b, which means M[i][j] should be added
            by one for all 0 <= i < a and 0 <= j < b. 
    You need to count and return the number of maximum integers in the matrix after performing
        all the operations.

    Example 1:
    Input:
m = 3, n = 3
operations = [[2,2],[3,3]]
Output: 4
Explanation:
Initially, M =
[[0, 0, 0],
 [0, 0, 0],
 [0, 0, 0]]

After performing [2,2], M =
[[1, 1, 0],
 [1, 1, 0],
 [0, 0, 0]]

After performing [3,3], M =
[[2, 2, 1],
 [2, 2, 1],
 [1, 1, 1]]

So the maximum integer in M is 2, and there are four of it in M. So return 4.

    

    Note:
    
        The range of m and n is [1,40000].
        The range of a is [1,m], and the range of b is [1,n].
        The range of operations size won't exceed 10,000.
-----------------

# 64_Minimum_Path_Sum
# 64. Minimum Path Sum

Given a m x n grid filled with non-negative numbers, find a path from top
        left to bottom right which minimizes the sum of all numbers along its path.

    Note: You can only move either down or right at any point in time.

    Example:

    Input:
[
  [1,3,1],
  [1,5,1],
  [4,2,1]
]
Output: 7
Explanation: Because the path 1→3→1→1→1 minimizes the sum.
-----------------

# 1197_Minimum_Knight_Moves
# 1197. Minimum Knight Moves

In an infinite chess board with coordinates from -infinity to
        +infinity, you have a knight at square [0,
            0].

    A knight has 8 possible moves it can make, as illustrated below. Each move is two
        squares in a cardinal direction, then one square in an orthogonal direction.

    
        

    Return the minimum number of steps needed to move the knight to the square [x,
        y].  It is guaranteed the answer exists.

     
    Example 1:

    Input: x = 2, y = 1
Output: 1
Explanation: [0, 0] → [2, 1]

    Example 2:

    Input: x = 5, y = 5
Output: 4
Explanation: [0, 0] → [2, 1] → [4, 2] → [3, 4] → [5, 5]

     
    Constraints:

    
        |x| + |y| <= 300
-----------------

# 955_Delete_Columns_to_Make_Sorted_II
# 955. Delete Columns to Make Sorted II

We are given an array A of N lowercase letter strings, all of
        the same length.

    Now, we may choose any set of deletion indices, and for each string, we delete all the
        characters in those indices.

    For example, if we have an array A = ["abcdef","uvwxyz"] and
        deletion indices {0, 2, 3}, then the final array after deletions is ["bef","vyz"].
    

    Suppose we chose a set of deletion indices D such that after deletions, the
        final array has its elements in lexicographic order (A[0] <= A[1]
            <= A[2] ... <= A[A.length - 1]).

    Return the minimum possible value of D.length.
-----------------

# 830_Positions_of_Large_Groups
# 830. Positions of Large Groups

In a string S of lowercase letters, these letters form consecutive
        groups of the same character.

    For example, a string like S = "abbxxxxzyy" has the groups "a",
        "bb", "xxxx", "z" and "yy".
    

    Call a group large if it has 3 or more characters.  We would like the starting
        and ending positions of every large group.

    The final answer should be in lexicographic order.

     

    Example 1:

    Input: "abbxxxxzzy"
Output: [[3,6]]
Explanation: "xxxx" is the single large group with starting  3 and ending positions 6.

    Example 2:

    Input: "abc"
Output: []
Explanation: We have "a","b" and "c" but no large group.

    Example 3:

    Input: "abcdddeeeeaabbbcd"
Output: [[3,5],[6,9],[12,14]]

     

    Note:  1 <= S.length <= 1000
-----------------

# 1290_Convert_Binary_Number_in_a_Linked_List_to_Integer
# 1290. Convert Binary Number in a Linked List to Integer


-----------------

# 960_Delete_Columns_to_Make_Sorted_III
# 960. Delete Columns to Make Sorted III

We are given an array A of N lowercase letter strings, all of
        the same length.

    Now, we may choose any set of deletion indices, and for each string, we delete all the
        characters in those indices.

    For example, if we have an array A = ["babca","bbazb"] and
        deletion indices {0, 1, 4}, then the final array after deletions is ["bc","az"].
    

    Suppose we chose a set of deletion indices D such that after deletions, the
        final array has every element (row) in lexicographic order.

    For clarity, A[0] is in lexicographic order (ie. A[0][0] <= A[0][1]
        <= ... <= A[0][A[0].length - 1]), A[1] is in lexicographic order
        (ie. A[1][0] <= A[1][1] <= ... <= A[1][A[1].length - 1]), and so on.
    

    Return the minimum possible value of D.length.
-----------------

# 199_Binary_Tree_Right_Side_View
# 199. Binary Tree Right Side View

Given a binary tree, imagine yourself standing on the right side of it, return the
        values of the nodes you can see ordered from top to bottom.

    Example:

    Input: [1,2,3,null,5,null,4]
Output: [1, 3, 4]
Explanation:

   1            <---
 /   \
2     3         <---
 \     \
  5     4       <---
-----------------

# 1647_Minimum_Deletions_to_Make_Character_Frequencies_Unique
# 1647. Minimum Deletions to Make Character Frequencies Unique


-----------------

# 800_Similar_RGB_Color
# 800. Similar RGB Color

In the following, every capital letter represents some hexadecimal digit from 0
        to f.

    The red-green-blue color "#AABBCC" can be
        written as "#ABC" in shorthand.  For example,
        "#15c" is shorthand for the color "#1155cc".
    

    Now, say the similarity between two colors "#ABCDEF" and "#UVWXYZ"
        is -(AB - UV)^2 - (CD - WX)^2 - (EF - YZ)^2.

    Given the color "#ABCDEF", return a 7 character color that is
        most similar to #ABCDEF, and has a shorthand (that is, it can be represented as
        some "#XYZ"

    Example 1:
Input: color = "#09f166"
Output: "#11ee66"
Explanation: 
The similarity is -(0x09 - 0x11)^2 -(0xf1 - 0xee)^2 - (0x66 - 0x66)^2 = -64 -9 -0 = -73.
This is the highest among any shorthand color.

    Note:

    
        color is a string of length 7.
        color is a valid RGB color: for i > 0,
            color[i] is a hexadecimal digit from 0 to f
        Any answer which has the same (highest) similarity as the best answer will be
            accepted.
        
        All inputs and outputs should use lowercase letters, and the output is 7 characters.
-----------------

# 1113_Reported_Posts
# 1113. Reported Posts

Table: Actions

    +---------------+---------+
| Column Name   | Type    |
+---------------+---------+
| user_id       | int     |
| post_id       | int     |
| action_date   | date    |
| action        | enum    |
| extra         | varchar |
+---------------+---------+
There is no primary key for this table, it may have duplicate rows.
The action column is an ENUM type of ('view', 'like', 'reaction', 'comment', 'report', 'share').
The extra column has optional information about the action such as a reason for report or a type of reaction. 

     

    Write an SQL query that reports the number of posts reported yesterday for each report
        reason. Assume today is 2019-07-05.

    The query result format is in the following example:

    Actions table:
+---------+---------+-------------+--------+--------+
| user_id | post_id | action_date | action | extra  |
+---------+---------+-------------+--------+--------+
| 1       | 1       | 2019-07-01  | view   | null   |
| 1       | 1       | 2019-07-01  | like   | null   |
| 1       | 1       | 2019-07-01  | share  | null   |
| 2       | 4       | 2019-07-04  | view   | null   |
| 2       | 4       | 2019-07-04  | report | spam   |
| 3       | 4       | 2019-07-04  | view   | null   |
| 3       | 4       | 2019-07-04  | report | spam   |
| 4       | 3       | 2019-07-02  | view   | null   |
| 4       | 3       | 2019-07-02  | report | spam   |
| 5       | 2       | 2019-07-04  | view   | null   |
| 5       | 2       | 2019-07-04  | report | racism |
| 5       | 5       | 2019-07-04  | view   | null   |
| 5       | 5       | 2019-07-04  | report | racism |
+---------+---------+-------------+--------+--------+

Result table:
+---------------+--------------+
| report_reason | report_count |
+---------------+--------------+
| spam          | 1            |
| racism        | 2            |
+---------------+--------------+
Note that we only care about report reasons with non zero number of reports.
-----------------

# 808_Soup_Servings
# 808. Soup Servings

There are two types of soup: type A and type B. Initially we have N ml of each
        type of soup. There are four kinds of operations:

    
        Serve 100 ml of soup A and 0 ml of soup B
        Serve 75 ml of soup A and 25 ml of soup B
        Serve 50 ml of soup A and 50 ml of soup B
        Serve 25 ml of soup A and 75 ml of soup B
    

    When we serve some soup, we give it to someone and we no longer have it.  Each turn, we
        will choose from the four operations with equal probability 0.25. If the remaining volume of
        soup is not enough to complete the operation, we will serve as much as we can.  We
        stop once we no longer have some quantity of both types of soup.

    Note that we do not have the operation where all 100 ml's of soup B are used first.  

    Return the probability that soup A will be empty first, plus half the probability that A
        and B become empty at the same time.

     

    Example:
Input: N = 50
Output: 0.625
Explanation:
If we choose the first two operations, A will become empty first. For the third operation, A and B will become empty at the same time. For the fourth operation, B will become empty first. So the total probability of A becoming empty first plus half the probability that A and B become empty at the same time, is 0.25 * (1 + 1 + 0.5 + 0) = 0.625.

    Notes: 

    
        0 <= N <= 10^9. 
        Answers within 10^-6 of the true value will be accepted as
            correct.
-----------------

# 317_Shortest_Distance_from_All_Buildings
# 317. Shortest Distance from All Buildings

You want to build a house on an empty land which reaches all buildings in the shortest
        amount of distance. You can only move up, down, left and right. You are given a 2D grid of
        values 0, 1 or 2, where:

    
        Each 0 marks an empty land which you can pass by freely.
        Each 1 marks a building which you cannot pass through.
        Each 2 marks an obstacle which you cannot pass through.
    

    Example:

    Input: [[1,0,2,0,1],[0,0,0,0,0],[0,0,1,0,0]]

1 - 0 - 2 - 0 - 1
|   |   |   |   |
0 - 0 - 0 - 0 - 0
|   |   |   |   |
0 - 0 - 1 - 0 - 0

Output: 7

Explanation: Given three buildings at (0,0), (0,4), (2,2), and an obstacle at (0,2),
             the point (1,2) is an ideal empty land to build a house, as the total
             travel distance of 3+3+1=7 is minimal. So return 7.

    Note:
        There will be at least one building. If it is not possible to build such house according to
        the above rules, return -1.
-----------------

# 1713_Minimum_Operations_to_Make_a_Subsequence
# 1713. Minimum Operations to Make a Subsequence


-----------------

# 1557_Minimum_Number_of_Vertices_to_Reach_All_Nodes
# 1557. Minimum Number of Vertices to Reach All Nodes


-----------------

# 173_Binary_Search_Tree_Iterator
# 173. Binary Search Tree Iterator

Implement an iterator over a binary search tree (BST). Your iterator will be initialized with
        the root node of a BST.

    Calling next() will return the next smallest number in the BST.

     

    
    

    Example:

    

    BSTIterator iterator = new BSTIterator(root);
iterator.next();    // return 3
iterator.next();    // return 7
iterator.hasNext(); // return true
iterator.next();    // return 9
iterator.hasNext(); // return true
iterator.next();    // return 15
iterator.hasNext(); // return true
iterator.next();    // return 20
iterator.hasNext(); // return false

     

    Note:

    
        next() and hasNext() should run in average O(1) time and uses
            O(h) memory, where h is the height of the tree.
        
        You may assume that next() call will always be valid, that
            is, there will be at least a next smallest number in the BST when next() is
            called.
-----------------

# 787_Cheapest_Flights_Within_K_Stops
# 787. Cheapest Flights Within K Stops

There are n cities connected by m flights. Each fight starts
        from city u and arrives at v with a price w.
    

    Now given all the cities and flights, together with starting city src and the
        destination dst, your task is to find the cheapest price from
        src to dst with up to k stops. If there is no such
        route, output -1.

    Example 1:
Input:
n = 3, edges = [[0,1,100],[1,2,100],[0,2,500]]
src = 0, dst = 2, k = 1
Output: 200
Explanation:
The graph looks like this:

The cheapest price from city 0 to city 2 with at most 1 stop costs 200, as marked red in the picture.

    Example 2:
Input:
n = 3, edges = [[0,1,100],[1,2,100],[0,2,500]]
src = 0, dst = 2, k = 0
Output: 500
Explanation:
The graph looks like this:

The cheapest price from city 0 to city 2 with at most 0 stop costs 500, as marked blue in the picture.

    Note:

    
        The number of nodes n will be in range [1, 100],
            with nodes labeled from 0 to n - 1.
        
        The size of flights will be in range [0, n * (n - 1) /
            2].
        
        The format of each flight will be (src, dst,
            price).
        
        The price of each flight will be in the range [1, 10000].
        k is in the range of [0, n - 1].
        There will not be any duplicated flights or self cycles.
-----------------

# 1540_Can_Convert_String_in_K_Moves
# 1540. Can Convert String in K Moves


-----------------

# 731_My_Calendar_II
# 731. My Calendar II

Implement a MyCalendarTwo class to store your events. A new event can be added
        if adding the event will not cause a triple booking.

    Your class will have one method, book(int start, int end). Formally, this
        represents a booking on the half open interval [start, end), the range of real
        numbers x such that start <= x < end.

    A triple booking happens when three events have some non-empty intersection
        (ie., there is some time that is common to all 3 events.)

    For each call to the method MyCalendar.book, return true if the
        event can be added to the calendar successfully without causing a triple booking.
        Otherwise, return false and do not add the event to the calendar.
    Your class will be called like this: MyCalendar cal = new MyCalendar(); MyCalendar.book(start,
    end)

    Example 1:

    MyCalendar();
MyCalendar.book(10, 20); // returns true
MyCalendar.book(50, 60); // returns true
MyCalendar.book(10, 40); // returns true
MyCalendar.book(5, 15); // returns false
MyCalendar.book(5, 10); // returns true
MyCalendar.book(25, 55); // returns true
Explanation:
The first two events can be booked.  The third event can be double booked.
The fourth event (5, 15) can't be booked, because it would result in a triple booking.
The fifth event (5, 10) can be booked, as it does not use time 10 which is already double booked.
The sixth event (25, 55) can be booked, as the time in [25, 40) will be double booked with the third event;
the time [40, 50) will be single booked, and the time [50, 55) will be double booked with the second event.

     

    Note:

    
        The number of calls to MyCalendar.book per test case will be at most 1000.
        
        In calls to MyCalendar.book(start, end), start and
            end are integers in the range [0, 10^9].
-----------------

# 1711_Count_Good_Meals
# 1711. Count Good Meals


-----------------

# 674_Longest_Continuous_Increasing_Subsequence
# 674. Longest Continuous Increasing Subsequence

Given an unsorted array of integers, find the length of longest continuous
        increasing subsequence (subarray).
    

    Example 1:
    Input: [1,3,5,4,7]
Output: 3
Explanation: The longest continuous increasing subsequence is [1,3,5], its length is 3.
Even though [1,3,5,7] is also an increasing subsequence, it's not a continuous one where 5 and 7 are separated by 4.

    

    Example 2:
    Input: [2,2,2,2,2]
Output: 1
Explanation: The longest continuous increasing subsequence is [2], its length is 1.

    

    Note:
        Length of the array will not exceed 10,000.
-----------------

# 767_Reorganize_String
# 767. Reorganize String

Given a string S, check if the letters can be rearranged so that two characters
        that are adjacent to each other are not the same.

    If possible, output any possible result.  If not possible, return the empty string.

    Example 1:

    Input: S = "aab"
Output: "aba"

    Example 2:

    Input: S = "aaab"
Output: ""

    Note:

    
        S will consist of lowercase letters and have length in range [1,
            500].
-----------------

# 1718_Construct_the_Lexicographically_Largest_Valid_Sequence
# 1718. Construct the Lexicographically Largest Valid Sequence


-----------------

# 1724_Checking_Existence_of_Edge_Length_Limited_Paths_II
# 1724. Checking Existence of Edge Length Limited Paths II


-----------------

# 1510_Stone_Game_IV
# 1510. Stone Game IV


-----------------

# 1795_Rearrange_Products_Table
# 1795. Rearrange Products Table


-----------------

# 580_Count_Student_Number_in_Departments
# 580. Count Student Number in Departments

A university uses 2 data tables, student and department, to store
        data about its students and the departments associated with each major.

    Write a query to print the respective department name and number of students majoring in each
        department for all departments in the department table (even ones with no
        current students).

    Sort your results by descending number of students; if two or more departments have the same
        number of students, then sort those departments alphabetically by department name.

    The student is described as follow:

    | Column Name  | Type      |
|--------------|-----------|
| student_id   | Integer   |
| student_name | String    |
| gender       | Character |
| dept_id      | Integer   |

    where student_id is the student's ID number, student_name is the student's name,
        gender is their gender, and dept_id is the department ID associated with their declared
        major.

    And the department table is described as below:

    | Column Name | Type    |
|-------------|---------|
| dept_id     | Integer |
| dept_name   | String  |

    where dept_id is the department's ID number and dept_name is the department name.

    Here is an example input:
        student table:

    | student_id | student_name | gender | dept_id |
|------------|--------------|--------|---------|
| 1          | Jack         | M      | 1       |
| 2          | Jane         | F      | 1       |
| 3          | Mark         | M      | 2       |

    department table:

    | dept_id | dept_name   |
|---------|-------------|
| 1       | Engineering |
| 2       | Science     |
| 3       | Law         |

    The Output should be:

    | dept_name   | student_number |
|-------------|----------------|
| Engineering | 2              |
| Science     | 1              |
| Law         | 0              |
-----------------

# 915_Partition_Array_into_Disjoint_Intervals
# 915. Partition Array into Disjoint Intervals

Given an array A, partition it into two (contiguous) subarrays left and
        right so that:

    
        Every element in left is less than or equal to every element in right.
        
        left and right are non-empty.
        left has the smallest possible size.
    

    Return the length of left after such a partitioning.  It
        is guaranteed that such a partitioning exists.

     

    Example 1:

    Input: [5,0,3,8,6]
Output: 3
Explanation: left = [5,0,3], right = [8,6]
-----------------

# 1816_Truncate_Sentence
# 1816. Truncate Sentence


-----------------

# 448_Find_All_Numbers_Disappeared_in_an_Array
# 448. Find All Numbers Disappeared in an Array

Given an array of integers where 1 ≤ a[i] ≤ n (n = size of array), some
        elements appear twice and others appear once.

    Find all the elements of [1, n] inclusive that do not appear in this array.

    Could you do it without extra space and in O(n) runtime? You may assume the returned
        list does not count as extra space.

    Example:
    Input:
[4,3,2,7,8,2,3,1]

Output:
[5,6]
-----------------

# 692_Top_K_Frequent_Words
# 692. Top K Frequent Words

Given a non-empty list of words, return the k most frequent elements.
    Your answer should be sorted by frequency from highest to lowest. If two words have the same
        frequency, then the word with the lower alphabetical order comes first.

    Example 1:
    Input: ["i", "love", "leetcode", "i", "love", "coding"], k = 2
Output: ["i", "love"]
Explanation: "i" and "love" are the two most frequent words.
    Note that "i" comes before "love" due to a lower alphabetical order.

    

    Example 2:
    Input: ["the", "day", "is", "sunny", "the", "the", "the", "sunny", "is", "is"], k = 4
Output: ["the", "is", "sunny", "day"]
Explanation: "the", "is", "sunny" and "day" are the four most frequent words,
    with the number of occurrence being 4, 3, 2 and 1 respectively.

    

    Note:
    
        You may assume k is always valid, 1 ≤ k ≤ number of unique elements.
        
        Input words contain only lowercase letters.
    
    

    Follow up:
    
        Try to solve it in O(n log k) time and O(n) extra
            space.
-----------------

# 35_Search_Insert_Position
# 35. Search Insert Position

Given a sorted array and a target value, return the index if the target is found. If not,
        return the index where it would be if it were inserted in order.

    You may assume no duplicates in the array.

    Example 1:

    Input: [1,3,5,6], 5
Output: 2

    Example 2:

    Input: [1,3,5,6], 2
Output: 1

    Example 3:

    Input: [1,3,5,6], 7
Output: 4

    Example 4:

    Input: [1,3,5,6], 0
Output: 0
-----------------

# 1402_Reducing_Dishes
# 1402. Reducing Dishes


-----------------

# 1537_Get_the_Maximum_Score
# 1537. Get the Maximum Score


-----------------

# 1660_Correct_a_Binary_Tree
# 1660. Correct a Binary Tree


-----------------

# 1465_Maximum_Area_of_a_Piece_of_Cake_After_Horizontal_and_Vertical_Cuts
# 1465. Maximum Area of a Piece of Cake After Horizontal and Vertical Cuts


-----------------

# 1076_Project_Employees_II
# 1076. Project Employees II

Table: Project

    +-------------+---------+
| Column Name | Type    |
+-------------+---------+
| project_id  | int     |
| employee_id | int     |
+-------------+---------+
(project_id, employee_id) is the primary key of this table.
employee_id is a foreign key to Employee table.

    Table: Employee

    +------------------+---------+
| Column Name      | Type    |
+------------------+---------+
| employee_id      | int     |
| name             | varchar |
| experience_years | int     |
+------------------+---------+
employee_id is the primary key of this table.

     

    Write an SQL query that reports all the projects that have the most
        employees.

    The query result format is in the following example:

    Project table:
+-------------+-------------+
| project_id  | employee_id |
+-------------+-------------+
| 1           | 1           |
| 1           | 2           |
| 1           | 3           |
| 2           | 1           |
| 2           | 4           |
+-------------+-------------+

Employee table:
+-------------+--------+------------------+
| employee_id | name   | experience_years |
+-------------+--------+------------------+
| 1           | Khaled | 3                |
| 2           | Ali    | 2                |
| 3           | John   | 1                |
| 4           | Doe    | 2                |
+-------------+--------+------------------+

Result table:
+-------------+
| project_id  |
+-------------+
| 1           |
+-------------+
The first project has 3 employees while the second one has 2.
-----------------

# 476_Number_Complement
# 476. Number Complement

Given a positive integer, output its complement number. The complement strategy is to flip
        the bits of its binary representation.

    Note:
    
        The given integer is guaranteed to fit within the range of a 32-bit signed integer.
        You could assume no leading zero bit in the integer’s binary representation.
    
    

    Example 1:
    Input: 5
Output: 2
Explanation: The binary representation of 5 is 101 (no leading zero bits), and its complement is 010. So you need to output 2.

    

    Example 2:
    Input: 1
Output: 0
Explanation: The binary representation of 1 is 1 (no leading zero bits), and its complement is 0. So you need to output 0.
-----------------

# 372_Super_Pow
# 372. Super Pow

Your task is to calculate ab mod 1337 where a is a positive
        integer and b is an extremely large positive integer given in the form of an array.
    

    Example 1:
-----------------

# 1805_Number_of_Different_Integers_in_a_String
# 1805. Number of Different Integers in a String


-----------------

# 759_Employee_Free_Time
# 759. Employee Free Time

We are given a list schedule of employees, which represents the working time for
        each employee.

    Each employee has a list of non-overlapping Intervals, and these intervals are
        in sorted order.

    Return the list of finite intervals representing common, positive-length free time for
        all employees, also in sorted order.

    Example 1:

    Input: schedule = [[[1,2],[5,6]],[[1,3]],[[4,10]]]
Output: [[3,4]]
Explanation:
There are a total of three employees, and all common
free time intervals would be [-inf, 1], [3, 4], [10, inf].
We discard any intervals that contain inf as they aren't finite.

     

    Example 2:

    Input: schedule = [[[1,3],[6,7]],[[2,4]],[[2,5],[9,12]]]
Output: [[5,6],[7,9]]

     

    (Even though we are representing Intervals in the form [x, y], the
        objects inside are Intervals, not lists or arrays. For example, schedule[0][0].start
            = 1, schedule[0][0].end = 2, and schedule[0][0][0] is not defined.)
    

    Also, we wouldn't include intervals like [5, 5] in our answer, as they have zero
        length.

    Note:

    
        schedule and schedule[i] are lists with lengths in range
            [1, 50].
        
        0 <= schedule[i].start < schedule[i].end <= 10^8.
    

    NOTE: input types have been changed on June 17, 2019. Please reset to
        default code definition to get new method signature.
-----------------

# 1376_Time_Needed_to_Inform_All_Employees
# 1376. Time Needed to Inform All Employees


-----------------

# 760_Find_Anagram_Mappings
# 760. Find Anagram Mappings

Given two lists Aand B, and B is an anagram of A.
        B is an anagram of A means B is made by randomizing
        the order of the elements in A.
    
    
        We want to find an index mapping P, from A to
        B. A mapping P[i] = j means the ith element in A
        appears in B at index j.
    
    
        These lists A and B may contain duplicates. If there are multiple
        answers, output any of them.
    

    
        For example, given
    A = [12, 28, 46, 32, 50]
B = [50, 12, 32, 46, 28]

    
    We should return
    [1, 4, 3, 2, 0]

    as P[0] = 1 because the 0th element of A appears at
    B[1],
    and P[1] = 4 because the 1st element of A appears at
    B[4],
    and so on.
    

    Note:
    
        A, B have equal lengths in range [1, 100].
        A[i], B[i] are integers in range [0, 10^5].
-----------------

# 778_Swim_in_Rising_Water
# 778. Swim in Rising Water

On an N x N grid, each square grid[i][j] represents the elevation
        at that point (i,j).

    Now rain starts to fall. At time t, the depth of the water everywhere is
        t. You can swim from a square to another 4-directionally adjacent square if and
        only if the elevation of both squares individually are at most t. You
        can swim infinite distance in zero time. Of course, you must stay within the boundaries of
        the grid during your swim.

    You start at the top left square (0, 0). What is the least time until you can
        reach the bottom right square (N-1, N-1)?

    Example 1:

    Input: [[0,2],[1,3]]
Output: 3
Explanation:
At time 0, you are in grid location (0, 0).
You cannot go anywhere else because 4-directionally adjacent neighbors have a higher elevation than t = 0.

You cannot reach point (1, 1) until time 3.
When the depth of water is 3, we can swim anywhere inside the grid.

    Example 2:

    Input: [[0,1,2,3,4],[24,23,22,21,5],[12,13,14,15,16],[11,17,18,19,20],[10,9,8,7,6]]
Output: 16
Explanation:
 0  1  2  3  4
24 23 22 21  5
12 13 14 15 16
11 17 18 19 20
10  9  8  7  6

The final route is marked in bold.
We need to wait until time 16 so that (0, 0) and (4, 4) are connected.

    Note:

    
        2 <= N <= 50.
        grid[i][j] is a permutation of [0, ..., N*N - 1].
-----------------

# 337_House_Robber_III
# 337. House Robber III

The thief has found himself a new place for his thievery again. There is only one entrance to
        this area, called the "root." Besides the root, each house has one and only one
        parent house. After a tour, the smart thief realized that "all houses in this place
        forms a binary tree". It will automatically contact the police if two directly-linked
        houses were broken into on the same night.

    Determine the maximum amount of money the thief can rob tonight without alerting the
        police.

    Example 1:

    Input: [3,2,3,null,3,null,1]

     3
    / \
   2   3
    \   \
     3   1

Output: 7
Explanation: Maximum amount of money the thief can rob = 3 + 3 + 1 = 7.

    Example 2:

    Input: [3,4,5,1,3,null,1]

     3
    / \
   4   5
  / \   \
 1   3   1

Output: 9
Explanation: Maximum amount of money the thief can rob = 4 + 5 = 9.
-----------------

# 1532_The_Most_Recent_Three_Orders
# 1532. The Most Recent Three Orders


-----------------

# 1766_Tree_of_Coprimes
# 1766. Tree of Coprimes


-----------------

# 1105_Filling_Bookcase_Shelves
# 1105. Filling Bookcase Shelves

We have a sequence of books: the i-th book has thickness books[i][0]
        and height books[i][1].

    We want to place these books in order onto bookcase shelves that have
        total width shelf_width.

    We choose some of the books to place on this shelf (such that the sum of their thickness
        is <= shelf_width), then build another level of shelf of the bookcase so
        that the total height of the bookcase has increased by the maximum height of the books we
        just put down.  We repeat this process until there are no more books to place.

    Note again that at each step of the above process, the order of the books we place is
        the same order as the given sequence of books.  For example, if we have an ordered
        list of 5 books, we might place the first and second book onto the first shelf, the
        third book on the second shelf, and the fourth and fifth book on the last shelf.

    Return the minimum possible height that the total bookshelf can be after placing shelves in
        this manner.

     
    Example 1:
    
    Input: books = [[1,1],[2,3],[2,3],[1,1],[1,1],[1,1],[1,2]], shelf_width = 4
Output: 6
Explanation:
The sum of the heights of the 3 shelves are 1 + 3 + 2 = 6.
Notice that book number 2 does not have to be on the first shelf.

     
    Constraints:

    
        1 <= books.length <= 1000
        1 <= books[i][0] <= shelf_width <= 1000
        1 <= books[i][1] <= 1000
-----------------

# 747_Largest_Number_At_Least_Twice_of_Others
# 747. Largest Number At Least Twice of Others

In a given integer array nums, there is always exactly one largest element.

    Find whether the largest element in the array is at least twice as much as every other number
        in the array.

    If it is, return the index of the largest element, otherwise return -1.

    Example 1:

    Input: nums = [3, 6, 1, 0]
Output: 1
Explanation: 6 is the largest integer, and for every other number in the array x,
6 is more than twice as big as x.  The index of value 6 is 1, so we return 1.

     

    Example 2:

    Input: nums = [1, 2, 3, 4]
Output: -1
Explanation: 4 isn't at least as big as twice the value of 3, so we return -1.

     

    Note:

    
        nums will have a length in the range [1, 50].
        Every nums[i] will be an integer in the range [0, 99].
-----------------

# 1803_Count_Pairs_With_XOR_in_a_Range
# 1803. Count Pairs With XOR in a Range


-----------------

# 1394_Find_Lucky_Integer_in_an_Array
# 1394. Find Lucky Integer in an Array


-----------------

# 292_Nim_Game
# 292. Nim Game

You are playing the following Nim Game with your friend: There is a heap of stones on the
        table, each time one of you take turns to remove 1 to 3 stones. The one who removes the last
        stone will be the winner. You will take the first turn to remove the stones.

    Both of you are very clever and have optimal strategies for the game. Write a function to
        determine whether you can win the game given the number of stones in the heap.

    Example:

    Input: 4
Output: false
Explanation: If there are 4 stones in the heap, then you will never win the game;
             No matter 1, 2, or 3 stones you remove, the last stone will always be
             removed by your friend.
-----------------

# 310_Minimum_Height_Trees
# 310. Minimum Height Trees

For an undirected graph with tree characteristics, we can choose any node as the root. The
        result graph is then a rooted tree. Among all possible rooted trees, those with minimum
        height are called minimum height trees (MHTs). Given such a graph, write a function to find
        all the MHTs and return a list of their root labels.

    Format
        The graph contains n nodes which are labeled from 0 to n -
            1. You will be given the number n and a list of undirected edges
        (each edge is a pair of labels).

    You can assume that no duplicate edges will appear in edges. Since all edges are
        undirected, [0, 1] is the same as [1, 0] and thus will not appear
        together in edges.

    Example 1 :

    Input: n = 4, edges = [[1, 0], [1, 2], [1, 3]]

        0
        |
        1
       / \
      2   3

Output: [1]

    Example 2 :

    Input: n = 6, edges = [[0, 3], [1, 3], [2, 3], [4, 3], [5, 4]]

     0  1  2
      \ | /
        3
        |
        4
        |
        5

Output: [3, 4]

    Note:

    
        According to the definition of tree on Wikipedia: “a tree
            is an undirected graph in which any two vertices are connected by exactly one
            path. In other words, any connected graph without simple cycles is a tree.”
        
        The height of a rooted tree is the number of edges on the longest downward path between
            the root and a leaf.
-----------------

# 614_Second_Degree_Follower
# 614. Second Degree Follower

In facebook, there is a follow table with two columns: followee, follower.
    

    Please write a sql query to get the amount of each follower’s follower if he/she has
        one.

    For example:

    +-------------+------------+
| followee    | follower   |
+-------------+------------+
|     A       |     B      |
|     B       |     C      |
|     B       |     D      |
|     D       |     E      |
+-------------+------------+

    should output:

    +-------------+------------+
| follower    | num        |
+-------------+------------+
|     B       |  2         |
|     D       |  1         |
+-------------+------------+

    Explaination:
    Both B and D exist in the follower list, when as a followee, B's follower is C and D, and D's
    follower is E. A does not exist in follower list.
     

     
    Note:
    Followee would not follow himself/herself in all cases.
    Please display the result in follower's alphabet order.
-----------------

# 925_Long_Pressed_Name
# 925. Long Pressed Name

Your friend is typing his name into a keyboard.  Sometimes, when
        typing a character c, the key might get long pressed, and the
        character will be typed 1 or more times.

    You examine the typed characters of the keyboard.  Return
        True if it is possible that it was your friends name, with some characters
        (possibly none) being long pressed.

     

    Example 1:

    Input: name = "alex", typed = "aaleex"
Output: true
Explanation: 'a' and 'e' in 'alex' were long pressed.
-----------------

# 544_Output_Contest_Matches
# 544. Output Contest Matches

During the NBA playoffs, we always arrange the rather strong team to play with the rather
        weak team, like make the rank 1 team play with the rank nth team, which is a good
        strategy to make the contest more interesting. Now, you're given n teams, you need to
        output their final contest matches in the form of a string.
    

    The n teams are given in the form of positive integers from 1 to n, which represents
        their initial rank. (Rank 1 is the strongest team and Rank n is the weakest team.) We'll use
        parentheses('(', ')') and commas(',') to represent the contest team pairing -
        parentheses('(' , ')') for pairing and commas(',') for partition. During the pairing process
        in each round, you always need to follow the strategy of making the rather strong one pair
        with the rather weak one.

    Example 1:
    Input: 2
Output: (1,2)
Explanation:
Initially, we have the team 1 and the team 2, placed like: 1,2.
Then we pair the team (1,2) together with '(', ')' and ',', which is the final answer.

    

    Example 2:
    Input: 4
Output: ((1,4),(2,3))
Explanation:
In the first round, we pair the team 1 and 4, the team 2 and 3 together, as we need to make the strong team and weak team together.
And we got (1,4),(2,3).
In the second round, the winners of (1,4) and (2,3) need to play again to generate the final winner, so you need to add the paratheses outside them.
And we got the final answer ((1,4),(2,3)).

    

    Example 3:
    Input: 8
Output: (((1,8),(4,5)),((2,7),(3,6)))
Explanation:
First round: (1,8),(2,7),(3,6),(4,5)
Second round: ((1,8),(4,5)),((2,7),(3,6))
Third round: (((1,8),(4,5)),((2,7),(3,6)))
Since the third round will generate the final winner, you need to output the answer (((1,8),(4,5)),((2,7),(3,6))).

    

    Note:
    
        The n is in range [2, 212].
        We ensure that the input n can be converted into the form 2k, where k
            is a positive integer.
-----------------

# 370_Range_Addition
# 370. Range Addition

Assume you have an array of length n initialized with all 0's and
        are given k update operations.

    Each operation is represented as a triplet: [startIndex, endIndex, inc] which
        increments each element of subarray A[startIndex ... endIndex] (startIndex and
        endIndex inclusive) with inc.

    Return the modified array after all k operations were executed.

    Example:

    Input: length = 5, updates = [[1,3,2],[2,4,3],[0,2,-2]]
Output: [-2,0,3,5,3]

    Explanation:

    Initial state:
[0,0,0,0,0]

After applying operation [1,3,2]:
[0,2,2,2,0]

After applying operation [2,4,3]:
[0,2,5,5,3]

After applying operation [0,2,-2]:
[-2,0,3,5,3]
-----------------

# 1321_Restaurant_Growth
# 1321. Restaurant Growth


-----------------

# 123_Best_Time_to_Buy_and_Sell_Stock_III
# 123. Best Time to Buy and Sell Stock III

Say you have an array for which the ith element is the price of a given
        stock on day i.

    Design an algorithm to find the maximum profit. You may complete at most two
        transactions.

    Note: You may not engage in multiple transactions at the same time
        (i.e., you must sell the stock before you buy again).

    Example 1:

    Input: [3,3,5,0,0,3,1,4]
Output: 6
Explanation: Buy on day 4 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.
             Then buy on day 7 (price = 1) and sell on day 8 (price = 4), profit = 4-1 = 3.

    Example 2:

    Input: [1,2,3,4,5]
Output: 4
Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.
             Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are
             engaging multiple transactions at the same time. You must sell before buying again.

    Example 3:

    Input: [7,6,4,3,1]
Output: 0
Explanation: In this case, no transaction is done, i.e. max profit = 0.
-----------------

# 658_Find_K_Closest_Elements
# 658. Find K Closest Elements

Given a sorted array, two integers k and x, find the
        k closest elements to x in the array. The result should also be
        sorted in ascending order.
        If there is a tie, the smaller elements are always preferred.
    

    Example 1:
    Input: [1,2,3,4,5], k=4, x=3
Output: [1,2,3,4]

    

    Example 2:
    Input: [1,2,3,4,5], k=4, x=-1
Output: [1,2,3,4]

    

    Note:
    
        The value k is positive and will always be smaller than the length of the sorted
            array.
        
         Length of the given array is positive and will not exceed 104
         Absolute value of elements in the array and x will not exceed 104
    
    

    

    
        UPDATE (2017/9/19):
        The arr parameter had been changed to an array of integers (instead of a list
        of integers). Please reload the code definition to get the latest changes.
-----------------

# 1143_Longest_Common_Subsequence
# 1143. Longest Common Subsequence

Given two strings text1 and text2, return the length of their
        longest common subsequence.

    A subsequence of a string is a new string generated from the original string with
        some characters(can be none) deleted without changing the relative order of the remaining
        characters. (eg, "ace" is a subsequence of "abcde" while "aec"
        is not). A common subsequence of two strings is a subsequence that is
        common to both strings.

     

    If there is no common subsequence, return 0.

     
    Example 1:

    Input: text1 = "abcde", text2 = "ace"
Output: 3
Explanation: The longest common subsequence is "ace" and its length is 3.

    Example 2:

    Input: text1 = "abc", text2 = "abc"
Output: 3
Explanation: The longest common subsequence is "abc" and its length is 3.

    Example 3:

    Input: text1 = "abc", text2 = "def"
Output: 0
Explanation: There is no such common subsequence, so the result is 0.

     
    Constraints:

    
        1 <= text1.length <= 1000
        1 <= text2.length <= 1000
        The input strings consist of lowercase English characters only.
-----------------

# 1745_Palindrome_Partitioning_IV
# 1745. Palindrome Partitioning IV


-----------------

# 1093_Statistics_from_a_Large_Sample
# 1093. Statistics from a Large Sample

We sampled integers between 0 and 255, and stored the results in an
        array count:  count[k] is the number of integers we sampled
        equal to k.

    Return the minimum, maximum, mean, median, and mode of the sample respectively, as an array
        of floating point numbers.  The mode is guaranteed to be unique.

    (Recall that the median of a sample is:

    
        The middle element, if the elements of the sample were sorted and the number of
            elements is odd;
        The average of the middle two elements, if the elements of the sample were sorted
            and the number of elements is even.)
    

     
    Example 1:
    Input: count = [0,1,3,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
Output: [1.00000,3.00000,2.37500,2.50000,3.00000]

    Example 2:
    Input: count = [0,4,3,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
Output: [1.00000,4.00000,2.18182,2.00000,1.00000]

     
    Constraints:

    
        count.length == 256
        1 <= sum(count) <= 10^9
        The mode of the sample that count represents is unique.
        Answers within 10^-5 of the true value will be accepted as correct.
-----------------

# 1523_Count_Odd_Numbers_in_an_Interval_Range
# 1523. Count Odd Numbers in an Interval Range


-----------------

# 470_Implement_Rand10()_Using_Rand7()
# 470. Implement Rand10() Using Rand7()

Given a function rand7 which generates a uniform random integer in the range 1
        to 7, write a function rand10 which generates a uniform random integer in
        the range 1 to 10.

    Do NOT use system's Math.random().
-----------------

# 1625_Lexicographically_Smallest_String_After_Applying_Operations
# 1625. Lexicographically Smallest String After Applying Operations


-----------------

# 858_Mirror_Reflection
# 858. Mirror Reflection

There is a special square room with mirrors on each of the four walls.  Except
        for the southwest corner, there are receptors on each of the remaining corners,
        numbered 0, 1, and 2.

    The square room has walls of length p, and a laser ray from the southwest corner first
        meets the east wall at a distance q from the 0th receptor.
    

    Return the number of the receptor that the ray meets first.  (It is guaranteed that the
        ray will meet a receptor eventually.)
-----------------

# 1193_Monthly_Transactions_I
# 1193. Monthly Transactions I

Table: Transactions

    +---------------+---------+
| Column Name   | Type    |
+---------------+---------+
| id            | int     |
| country       | varchar |
| state         | enum    |
| amount        | int     |
| trans_date    | date    |
+---------------+---------+
id is the primary key of this table.
The table has information about incoming transactions.
The state column is an enum of type ["approved", "declined"].

     

    Write an SQL query to find for each month and country, the number of transactions and their
        total amount, the number of approved transactions and their total amount.

    The query result format is in the following example:

    Transactions table:
+------+---------+----------+--------+------------+
| id   | country | state    | amount | trans_date |
+------+---------+----------+--------+------------+
| 121  | US      | approved | 1000   | 2018-12-18 |
| 122  | US      | declined | 2000   | 2018-12-19 |
| 123  | US      | approved | 2000   | 2019-01-01 |
| 124  | DE      | approved | 2000   | 2019-01-07 |
+------+---------+----------+--------+------------+

Result table:
+----------+---------+-------------+----------------+--------------------+-----------------------+
| month    | country | trans_count | approved_count | trans_total_amount | approved_total_amount |
+----------+---------+-------------+----------------+--------------------+-----------------------+
| 2018-12  | US      | 2           | 1              | 3000               | 1000                  |
| 2019-01  | US      | 1           | 1              | 2000               | 2000                  |
| 2019-01  | DE      | 1           | 1              | 2000               | 2000                  |
+----------+---------+-------------+----------------+--------------------+-----------------------+
-----------------

# 1308_Running_Total_for_Different_Genders
# 1308. Running Total for Different Genders


-----------------

# 1335_Minimum_Difficulty_of_a_Job_Schedule
# 1335. Minimum Difficulty of a Job Schedule


-----------------

# 1338_Reduce_Array_Size_to_The_Half
# 1338. Reduce Array Size to The Half


-----------------

# 1294_Weather_Type_in_Each_Country
# 1294. Weather Type in Each Country


-----------------

# 1026_Maximum_Difference_Between_Node_and_Ancestor
# 1026. Maximum Difference Between Node and Ancestor

Given the root of a binary tree, find the maximum value V for which
        there exists different nodes A and B where V
            = |A.val - B.val| and A is an ancestor of B.

    (A node A is an ancestor of B if either: any child of A is equal to B, or any child of A is
        an ancestor of B.)

     

    Example 1:

    

    Input: [8,3,10,1,6,null,14,null,null,4,7,13]
Output: 7
Explanation: 
We have various ancestor-node differences, some of which are given below :
|8 - 3| = 5
|3 - 7| = 4
|8 - 1| = 7
|10 - 13| = 3
Among all possible differences, the maximum value of 7 is obtained by |8 - 1| = 7.

     

    Note:

    
        The number of nodes in the tree is between 2 and 5000.
        Each node will have value between 0 and 100000.
-----------------

# 362_Design_Hit_Counter
# 362. Design Hit Counter

Design a hit counter which counts the number of hits received in the past 5 minutes.

    Each function accepts a timestamp parameter (in seconds granularity) and you may assume that
        calls are being made to the system in chronological order (ie, the timestamp is
        monotonically increasing). You may assume that the earliest timestamp starts at 1.

    It is possible that several hits arrive roughly at the same time.

    Example:

    HitCounter counter = new HitCounter();

// hit at timestamp 1.
counter.hit(1);

// hit at timestamp 2.
counter.hit(2);

// hit at timestamp 3.
counter.hit(3);

// get hits at timestamp 4, should return 3.
counter.getHits(4);

// hit at timestamp 300.
counter.hit(300);

// get hits at timestamp 300, should return 4.
counter.getHits(300);

// get hits at timestamp 301, should return 3.
counter.getHits(301);

    Follow up:
        What if the number of hits per second could be very large? Does your design scale?
-----------------

# 1642_Furthest_Building_You_Can_Reach
# 1642. Furthest Building You Can Reach


-----------------

# 479_Largest_Palindrome_Product
# 479. Largest Palindrome Product

Find the largest palindrome made from the product of two n-digit numbers.

    Since the result could be very large, you should return the largest palindrome mod 1337.

     

    Example:

    Input: 2

    Output: 987

    Explanation: 99 x 91 = 9009, 9009 % 1337 = 987

     

    Note:

    The range of n is [1,8].
-----------------

# 439_Ternary_Expression_Parser
# 439. Ternary Expression Parser

Given a string representing arbitrarily nested ternary expressions, calculate the result of
        the expression. You can always assume that the given expression is valid and only consists
        of digits 0-9, ?, :, T and
        F (T and F represent True and False respectively).

    Note:
    
        The length of the given string is ≤ 10000.
        Each number will contain only one digit.
        The conditional expressions group right-to-left (as usual in most languages).
        The condition will always be either T or F. That is, the
            condition will never be a digit.
        
        The result of the expression will always evaluate to either a digit 0-9,
            T or F.
        
    
    

    
        Example 1:
    Input: "T?2:3"

Output: "2"

Explanation: If true, then result is 2; otherwise result is 3.

    

    
        Example 2:
    Input: "F?1:T?4:5"

Output: "4"

Explanation: The conditional expressions group right-to-left. Using parenthesis, it is read/evaluated as:

             "(F ? 1 : (T ? 4 : 5))"                   "(F ? 1 : (T ? 4 : 5))"
          -> "(F ? 1 : 4)"                 or       -> "(T ? 4 : 5)"
          -> "4"                                    -> "4"

    

    
        Example 3:
    Input: "T?T?F:5:3"

Output: "F"

Explanation: The conditional expressions group right-to-left. Using parenthesis, it is read/evaluated as:

             "(T ? (T ? F : 5) : 3)"                   "(T ? (T ? F : 5) : 3)"
          -> "(T ? F : 3)"                 or       -> "(T ? F : 5)"
          -> "F"                                    -> "F"
-----------------

# 1447_Simplified_Fractions
# 1447. Simplified Fractions


-----------------

# 376_Wiggle_Subsequence
# 376. Wiggle Subsequence

A sequence of numbers is called a wiggle sequence if the differences between
        successive numbers strictly alternate between positive and negative. The first difference
        (if one exists) may be either positive or negative. A sequence with fewer than two elements
        is trivially a wiggle sequence.

    For example, [1,7,4,9,2,5] is a wiggle sequence because the differences (6,-3,5,-7,3)
        are alternately positive and negative. In contrast, [1,4,7,2,5] and [1,7,4,5,5]
        are not wiggle sequences, the first because its first two differences are positive and the
        second because its last difference is zero.

    Given a sequence of integers, return the length of the longest subsequence that is a wiggle
        sequence. A subsequence is obtained by deleting some number of elements (eventually, also
        zero) from the original sequence, leaving the remaining elements in their original
        order.

    Example 1:

    Input: [1,7,4,9,2,5]
Output: 6
Explanation: The entire sequence is a wiggle sequence.
-----------------

# 457_Circular_Array_Loop
# 457. Circular Array Loop

You are given a circular array nums of positive and negative integers. If
        a number k at an index is positive, then move forward k steps. Conversely, if
        it's negative (-k), move backward k steps. Since the array is
        circular, you may assume that the last element's next element is the first element, and
        the first element's previous element is the last element.

    Determine if there is a loop (or a cycle) in nums. A cycle must start and end at
        the same index and the cycle's length > 1. Furthermore, movements in a cycle must all
        follow a single direction. In other words, a cycle must not consist of both forward and
        backward movements.

     

    Example 1:

    Input: [2,-1,1,2,2]
Output: true
Explanation: There is a cycle, from index 0 -> 2 -> 3 -> 0. The cycle's length is 3.

    Example 2:

    Input: [-1,2]
Output: false
Explanation: The movement from index 1 -> 1 -> 1 ... is not a cycle, because the cycle's length is 1. By definition the cycle's length must be greater than 1.

    Example 3:

    Input: [-2,1,-1,-2,-2]
Output: false
Explanation: The movement from index 1 -> 2 -> 1 -> ... is not a cycle, because movement from index 1 -> 2 is a forward movement, but movement from index 2 -> 1 is a backward movement. All movements in a cycle must follow a single direction.

     

    Note:

    
        -1000 ≤ nums[i] ≤ 1000
        nums[i] ≠ 0
        1 ≤ nums.length ≤ 5000
    

     

    Follow up:

    Could you solve it in O(n) time complexity and O(1) extra space
        complexity?
-----------------

# 203_Remove_Linked_List_Elements
# 203. Remove Linked List Elements

Remove all elements from a linked list of integers that have value val.

    Example:

    Input:  1->2->6->3->4->5->6, val = 6
Output: 1->2->3->4->5
-----------------

# 1606_Find_Servers_That_Handled_Most_Number_of_Requests
# 1606. Find Servers That Handled Most Number of Requests


-----------------

# 136_Single_Number
# 136. Single Number

Given a non-empty array of integers, every element appears
        twice except for one. Find that single one.

    Note:

    Your algorithm should have a linear runtime complexity. Could you implement it without using
        extra memory?

    Example 1:

    Input: [2,2,1]
Output: 1

    Example 2:

    Input: [4,1,2,1,2]
Output: 4
-----------------

# 691_Stickers_to_Spell_Word
# 691. Stickers to Spell Word

We are given N different types of stickers. Each sticker has a lowercase English word on it.
    
    
        You would like to spell out the given target string by cutting individual
        letters from your collection of stickers and rearranging them.
    
    
        You can use each sticker more than once if you want, and you have infinite quantities of
        each sticker.
    
    
        What is the minimum number of stickers that you need to spell out the target?
        If the task is impossible, return -1.
    

    Example 1:
    Input:
    ["with", "example", "science"], "thehat"

    

    Output:
    3

    

    Explanation:
    We can use 2 "with" stickers, and 1 "example" sticker.
After cutting and rearrange the letters of those stickers, we can form the target "thehat".
Also, this is the minimum number of stickers necessary to form the target string.

    

    Example 2:
    Input:
    ["notice", "possible"], "basicbasic"

    

    Output:
    -1

    

    Explanation:
    We can't form the target "basicbasic" from cutting letters from the given stickers.

    

    Note:
    stickers has length in the range [1, 50].
    stickers consists of lowercase English words (without apostrophes).
    target has length in the range [1, 15], and consists of lowercase
        English letters.
    
    In all test cases, all words were chosen randomly from the 1000 most common US
        English words, and the target was chosen as a concatenation of two random words.
    
    The time limit may be more challenging than usual. It is expected that a 50 sticker test
        case can be solved within 35ms on average.
-----------------

# 1554_Strings_Differ_by_One_Character
# 1554. Strings Differ by One Character


-----------------

# 1400_Construct_K_Palindrome_Strings
# 1400. Construct K Palindrome Strings


-----------------

# 1784_Check_if_Binary_String_Has_at_Most_One_Segment_of_Ones
# 1784. Check if Binary String Has at Most One Segment of Ones


-----------------

# 701_Insert_into_a_Binary_Search_Tree
# 701. Insert into a Binary Search Tree

Given the root node of a binary search tree (BST) and a value to be inserted into the tree, insert
        the value into the BST. Return the root node of the BST after the insertion. It is
        guaranteed that the new value does not exist in the original BST.

    Note that there may exist multiple valid ways for the insertion, as long as the
        tree remains a BST after insertion. You can return any of them.

    For example, 

    Given the tree:
        4
       / \
      2   7
     / \
    1   3
And the value to insert: 5

    You can return this binary search tree:

             4
       /   \
      2     7
     / \   /
    1   3 5

    This tree is also valid:

             5
       /   \
      2     7
     / \
    1   3
         \
          4
-----------------

# 1650_Lowest_Common_Ancestor_of_a_Binary_Tree_III
# 1650. Lowest Common Ancestor of a Binary Tree III


-----------------

# 990_Satisfiability_of_Equality_Equations
# 990. Satisfiability of Equality Equations

Given an array equations of strings that represent
        relationships between variables, each string equations[i] has length
        4 and takes one of two different forms: "a==b" or "a!=b". 
        Here, a and b are lowercase letters (not necessarily different)
        that represent one-letter variable names.

    Return true if and only if it is possible to assign integers to variable
        names so as to satisfy all the given equations.
-----------------

# 311_Sparse_Matrix_Multiplication
# 311. Sparse Matrix Multiplication

Given two sparse
        matrices A and B, return the result of AB.

    You may assume that A's column number is equal to B's row number.

    Example:

    Input:

A = [
  [ 1, 0, 0],
  [-1, 0, 3]
]

B = [
  [ 7, 0, 0 ],
  [ 0, 0, 0 ],
  [ 0, 0, 1 ]
]

Output:

     |  1 0 0 |   | 7 0 0 |   |  7 0 0 |
AB = | -1 0 3 | x | 0 0 0 | = | -7 0 3 |
                  | 0 0 1 |
-----------------

# 249_Group_Shifted_Strings
# 249. Group Shifted Strings

Given a string, we can "shift" each of its letter to its successive letter, for
        example: "abc" -> "bcd". We can keep "shifting"
        which forms the sequence:

    "abc" -> "bcd" -> ... -> "xyz"

    Given a list of strings which contains only lowercase alphabets, group all strings that
        belong to the same shifting sequence.

    Example:

    Input: ["abc", "bcd", "acef", "xyz", "az", "ba", "a", "z"],
Output:
[
  ["abc","bcd","xyz"],
  ["az","ba"],
  ["acef"],
  ["a","z"]
]
-----------------

# 1039_Minimum_Score_Triangulation_of_Polygon
# 1039. Minimum Score Triangulation of Polygon

Given N, consider a convex N-sided polygon with vertices labelled
        A[0], A[i], ..., A[N-1] in clockwise order.

    Suppose you triangulate the polygon into N-2 triangles.  For each triangle,
        the value of that triangle is the product of the labels of the
        vertices, and the total score of the triangulation is the sum of these values over
        all N-2 triangles in the triangulation.

    Return the smallest possible total score that you can achieve with some triangulation of the
        polygon.
-----------------

# 1577_Number_of_Ways_Where_Square_of_Number_Is_Equal_to_Product_of_Two_Numbers
# 1577. Number of Ways Where Square of Number Is Equal to Product of Two Numbers


-----------------

# 1219_Path_with_Maximum_Gold
# 1219. Path with Maximum Gold

In a gold mine grid of size m * n, each cell in this mine
        has an integer representing the amount of gold in that cell, 0 if it
        is empty.

    Return the maximum amount of gold you can collect under the conditions:

    
        Every time you are located in a cell you will collect all the gold in that cell.
        From your position you can walk one step to the left, right, up or down.
        You can't visit the same cell more than once.
        Never visit a cell with 0 gold.
        You can start and stop collecting gold from any position in the
            grid that has some gold.
        
    

     
    Example 1:

    Input: grid = [[0,6,0],[5,8,7],[0,9,0]]
Output: 24
Explanation:
[[0,6,0],
 [5,8,7],
 [0,9,0]]
Path to get the maximum gold, 9 -> 8 -> 7.

    Example 2:

    Input: grid = [[1,0,7],[2,0,6],[3,4,5],[0,3,0],[9,0,20]]
Output: 28
Explanation:
[[1,0,7],
 [2,0,6],
 [3,4,5],
 [0,3,0],
 [9,0,20]]
Path to get the maximum gold, 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7.

     
    Constraints:

    
        1 <= grid.length, grid[i].length <= 15
        0 <= grid[i][j] <= 100
        There are at most 25 cells containing gold.
-----------------

# 831_Masking_Personal_Information
# 831. Masking Personal Information

We are given a personal information string S, which may represent either
        an email address or a phone number.

    We would like to mask this personal information according to the following
        rules:

    
        1. Email address:

    We define a name to be a string of length ≥ 2
        consisting of only lowercase letters a-z or uppercase letters A-Z.
    

    An email address starts with a name, followed by the symbol '@',
        followed by a name, followed by the dot '.' and followed
        by a name. 

    All email addresses are guaranteed to be valid and in the format of "name1@name2.name3".
    

    To mask an email, all names must be converted to lowercase and all
        letters between the first and last letter of the first name must be replaced by 5
        asterisks '*'.

    
        2. Phone number:

    A phone number is a string consisting of only the digits 0-9 or the
        characters from the set {'+', '-', '(', ')', ' '}. You
        may assume a phone number contains 10 to 13 digits.

    The last 10 digits make up the local number, while the digits before those make up the
        country code. Note that the country code is optional. We want to expose only the last 4
        digits and mask all other digits.

    The local number should be formatted and masked as "***-***-1111", where
        1 represents the exposed digits.

    To mask a phone number with country code like "+111 111 111 1111", we
        write it in the form "+***-***-***-1111".  The
        '+' sign and the first '-' sign before
        the local number should only exist if there is a country code.  For example, a 12 digit
        phone number mask should start with "+**-".

    Note that extraneous characters like "(", ")", " ",
        as well as extra dashes or plus signs not part of the above formatting scheme should be
        removed.

     

    Return the correct "mask" of the information provided.

     

    Example 1:

    Input: "LeetCode@LeetCode.com"
Output: "l*****e@leetcode.com"
Explanation: All names are converted to lowercase, and the letters between the
             first and last letter of the first name is replaced by 5 asterisks.
             Therefore, "leetcode" -> "l*****e".

    Example 2:

    Input: "AB@qq.com"
Output: "a*****b@qq.com"
Explanation: There must be 5 asterisks between the first and last letter
             of the first name "ab". Therefore, "ab" -> "a*****b".

    Example 3:

    Input: "1(234)567-890"
Output: "***-***-7890"
Explanation: 10 digits in the phone number, which means all digits make up the local number.

    Example 4:

    Input: "86-(10)12345678"
Output: "+**-***-***-5678"
Explanation: 12 digits, 2 digits for country code and 10 digits for local number.

    Notes:

    
        S.length <= 40.
        Emails have length at least 8.
        Phone numbers have length at least 10.
-----------------

# 1281_Subtract_the_Product_and_Sum_of_Digits_of_an_Integer
# 1281. Subtract the Product and Sum of Digits of an Integer


-----------------

# 1567_Maximum_Length_of_Subarray_With_Positive_Product
# 1567. Maximum Length of Subarray With Positive Product


-----------------

# 1580_Put_Boxes_Into_the_Warehouse_II
# 1580. Put Boxes Into the Warehouse II


-----------------

# 357_Count_Numbers_with_Unique_Digits
# 357. Count Numbers with Unique Digits

Given a non-negative integer n, count all numbers with unique digits, x, where 0 ≤
        x < 10n.
-----------------

# 1132_Reported_Posts_II
# 1132. Reported Posts II

Table: Actions

    +---------------+---------+
| Column Name   | Type    |
+---------------+---------+
| user_id       | int     |
| post_id       | int     |
| action_date   | date    |
| action        | enum    |
| extra         | varchar |
+---------------+---------+
There is no primary key for this table, it may have duplicate rows.
The action column is an ENUM type of ('view', 'like', 'reaction', 'comment', 'report', 'share').
The extra column has optional information about the action such as a reason for report or a type of reaction. 

    Table: Removals

    +---------------+---------+
| Column Name   | Type    |
+---------------+---------+
| post_id       | int     |
| remove_date   | date    |
+---------------+---------+
post_id is the primary key of this table.
Each row in this table indicates that some post was removed as a result of being reported or as a result of an admin review.

     

    Write an SQL query to find the average for daily percentage of posts that got removed
        after being reported as spam, rounded to 2 decimal places.

    The query result format is in the following example:

    Actions table:
+---------+---------+-------------+--------+--------+
| user_id | post_id | action_date | action | extra  |
+---------+---------+-------------+--------+--------+
| 1       | 1       | 2019-07-01  | view   | null   |
| 1       | 1       | 2019-07-01  | like   | null   |
| 1       | 1       | 2019-07-01  | share  | null   |
| 2       | 2       | 2019-07-04  | view   | null   |
| 2       | 2       | 2019-07-04  | report | spam   |
| 3       | 4       | 2019-07-04  | view   | null   |
| 3       | 4       | 2019-07-04  | report | spam   |
| 4       | 3       | 2019-07-02  | view   | null   |
| 4       | 3       | 2019-07-02  | report | spam   |
| 5       | 2       | 2019-07-03  | view   | null   |
| 5       | 2       | 2019-07-03  | report | racism |
| 5       | 5       | 2019-07-03  | view   | null   |
| 5       | 5       | 2019-07-03  | report | racism |
+---------+---------+-------------+--------+--------+

Removals table:
+---------+-------------+
| post_id | remove_date |
+---------+-------------+
| 2       | 2019-07-20  |
| 3       | 2019-07-18  |
+---------+-------------+

Result table:
+-----------------------+
| average_daily_percent |
+-----------------------+
| 75.00                 |
+-----------------------+
The percentage for 2019-07-04 is 50% because only one post of two spam reported posts was removed.
The percentage for 2019-07-02 is 100% because one post was reported as spam and it was removed.
The other days had no spam reports so the average is (50 + 100) / 2 = 75%
Note that the output is only one number and that we do not care about the remove dates.
-----------------

# 900_RLE_Iterator
# 900. RLE Iterator

Write an iterator that iterates through a run-length encoded sequence.

    The iterator is initialized by RLEIterator(int[] A), where A is a
        run-length encoding of some sequence.  More specifically, for all even i, A[i]
        tells us the number of times that the non-negative integer value A[i+1] is
        repeated in the sequence.

    The iterator supports one function: next(int n), which exhausts the next
        n elements (n >= 1) and returns the last element exhausted
        in this way.  If there is no element left to exhaust, next returns
        -1 instead.

    For example, we start with A = [3,8,0,9,2,5], which is a run-length encoding of
        the sequence [8,8,8,5,5].  This is because the sequence can be read as "three
        eights, zero nines, two fives".

     

    Example 1:

    Input: ["RLEIterator","next","next","next","next"], [[[3,8,0,9,2,5]],[2],[1],[1],[2]]
Output: [null,8,8,5,-1]
Explanation: 
RLEIterator is initialized with RLEIterator([3,8,0,9,2,5]).
This maps to the sequence [8,8,8,5,5].
RLEIterator.next is then called 4 times:

.next(2) exhausts 2 terms of the sequence, returning 8.  The remaining sequence is now [8, 5, 5].

.next(1) exhausts 1 term of the sequence, returning 8.  The remaining sequence is now [5, 5].

.next(1) exhausts 1 term of the sequence, returning 5.  The remaining sequence is now [5].

.next(2) exhausts 2 terms, returning -1.  This is because the first term exhausted was 5,
but the second term did not exist.  Since the last term exhausted does not exist, we return -1.

    Note:

    
        0 <= A.length <= 1000
        A.length is an even integer.
        0 <= A[i] <= 10^9
        There are at most 1000 calls to RLEIterator.next(int n) per
            test case.
        
        Each call to RLEIterator.next(int n) will have 1 <= n
            <= 10^9.
-----------------

# 498_Diagonal_Traverse
# 498. Diagonal Traverse

Given a matrix of M x N elements (M rows, N columns), return all elements of the matrix in
        diagonal order as shown in the below image.

     

    Example:

    Input:
[
 [ 1, 2, 3 ],
 [ 4, 5, 6 ],
 [ 7, 8, 9 ]
]

Output:  [1,2,4,7,5,3,6,8,9]

Explanation:

     

    Note:

    The total number of elements of the given matrix will not exceed 10,000.
-----------------

# 1029_Two_City_Scheduling
# 1029. Two City Scheduling

There are 2N people a company is planning to interview. The cost of flying the
        i-th person to city A is costs[i][0], and the cost of
        flying the i-th person to city B is costs[i][1].

    Return the minimum cost to fly every person to a city such that exactly N people
        arrive in each city.

     

    Example 1:

    Input: [[10,20],[30,200],[400,50],[30,20]]
Output: 110
Explanation: 
The first person goes to city A for a cost of 10.
The second person goes to city A for a cost of 30.
The third person goes to city B for a cost of 50.
The fourth person goes to city B for a cost of 20.

The total minimum cost is 10 + 30 + 50 + 20 = 110 to have half the people interviewing in each city.

     

    Note:

    
        1 <= costs.length <= 100
        It is guaranteed that costs.length is even.
        1 <= costs[i][0], costs[i][1] <= 1000
-----------------

# 1032_Stream_of_Characters
# 1032. Stream of Characters

Implement the StreamChecker class as follows:

    
        StreamChecker(words): Constructor, init the data structure with the given
            words.
        
        query(letter): returns true if and only if for some k >= 1,
            the last k characters queried (in order from oldest to newest,
            including this letter just queried) spell one of the words in the given list.
        
    

     

    Example:

    StreamChecker streamChecker = new StreamChecker(["cd","f","kl"]); // init the dictionary.
streamChecker.query('a');          // return false
streamChecker.query('b');          // return false
streamChecker.query('c');          // return false
streamChecker.query('d');          // return true, because 'cd' is in the wordlist
streamChecker.query('e');          // return false
streamChecker.query('f');          // return true, because 'f' is in the wordlist
streamChecker.query('g');          // return false
streamChecker.query('h');          // return false
streamChecker.query('i');          // return false
streamChecker.query('j');          // return false
streamChecker.query('k');          // return false
streamChecker.query('l');          // return true, because 'kl' is in the wordlist

     

    Note:

    
        1 <= words.length <= 2000
        1 <= words[i].length <= 2000
        Words will only consist of lowercase English letters.
        Queries will only consist of lowercase English letters.
        The number of queries is at most 40000.
-----------------

# 1401_Circle_and_Rectangle_Overlapping
# 1401. Circle and Rectangle Overlapping


-----------------

# 551_Student_Attendance_Record_I
# 551. Student Attendance Record I

You are given a string representing an attendance record for a student. The record only contains
    the following three characters:

    
    
        'A' : Absent.
        'L' : Late.
        'P' : Present.
    
    

    
        A student could be rewarded if his attendance record doesn't contain more than one 'A'
        (absent) or more than two continuous 'L' (late). 

    You need to return whether the student could be rewarded according to his attendance
        record.

    Example 1:
    Input: "PPALLP"
Output: True

    

    Example 2:
    Input: "PPALLL"
Output: False
-----------------

# 804_Unique_Morse_Code_Words
# 804. Unique Morse Code Words

International Morse Code defines a standard encoding where each letter is mapped to a series
        of dots and dashes, as follows: "a" maps to
        ".-", "b" maps to
        "-...", "c" maps to
        "-.-.", and so on.

    For convenience, the full table for the 26 letters of the English alphabet is given
        below:

    [".-","-...","-.-.","-..",".","..-.","--.","....","..",".---","-.-",".-..","--","-.","---",".--.","--.-",".-.","...","-","..-","...-",".--","-..-","-.--","--.."]

    Now, given a list of words, each word can be written as a concatenation of the Morse code of
        each letter. For example, "cba" can be written as "-.-..--...", (which
        is the concatenation "-.-." + "-..." + ".-"). We'll call
        such a concatenation, the transformation of a word.

    Return the number of different transformations among all words we have.

    Example:
Input: words = ["gin", "zen", "gig", "msg"]
Output: 2
Explanation: 
The transformation of each word is:
"gin" -> "--...-."
"zen" -> "--...-."
"gig" -> "--...--."
"msg" -> "--...--."

There are 2 different transformations, "--...-." and "--...--.".

    Note:

    
        The length of words will be at most 100.
        Each words[i] will have length in range [1, 12].
        words[i] will only consist of lowercase letters.
-----------------

# 348_Design_Tic-Tac-Toe
# 348. Design Tic-Tac-Toe

Design a Tic-tac-toe game that is played between two players on a n x n grid.
    

    You may assume the following rules:
    
        A move is guaranteed to be valid and is placed on an empty block.
        Once a winning condition is reached, no more moves is allowed.
        A player who succeeds in placing n of their marks in a horizontal, vertical, or
            diagonal row wins the game.
        
    
    

    Example:
    Given n = 3, assume that player 1 is "X" and player 2 is "O" in the board.

TicTacToe toe = new TicTacToe(3);

toe.move(0, 0, 1); -> Returns 0 (no one wins)
|X| | |
| | | |    // Player 1 makes a move at (0, 0).
| | | |

toe.move(0, 2, 2); -> Returns 0 (no one wins)
|X| |O|
| | | |    // Player 2 makes a move at (0, 2).
| | | |

toe.move(2, 2, 1); -> Returns 0 (no one wins)
|X| |O|
| | | |    // Player 1 makes a move at (2, 2).
| | |X|

toe.move(1, 1, 2); -> Returns 0 (no one wins)
|X| |O|
| |O| |    // Player 2 makes a move at (1, 1).
| | |X|

toe.move(2, 0, 1); -> Returns 0 (no one wins)
|X| |O|
| |O| |    // Player 1 makes a move at (2, 0).
|X| |X|

toe.move(1, 0, 2); -> Returns 0 (no one wins)
|X| |O|
|O|O| |    // Player 2 makes a move at (1, 0).
|X| |X|

toe.move(2, 1, 1); -> Returns 1 (player 1 wins)
|X| |O|
|O|O| |    // Player 1 makes a move at (2, 1).
|X|X|X|

    

    Follow up:
        Could you do better than O(n2) per move() operation?
-----------------

# 684_Redundant_Connection
# 684. Redundant Connection

In this problem, a tree is an undirected graph that is connected and has no cycles.
    
    
        The given input is a graph that started as a tree with N nodes (with distinct values 1, 2,
        ..., N), with one additional edge added. The added edge has two different vertices chosen
        from 1 to N, and was not an edge that already existed.
    
    
        The resulting graph is given as a 2D-array of edges. Each element of edges
        is a pair [u, v] with u < v, that represents an undirected
        edge connecting nodes u and v.
    
    
        Return an edge that can be removed so that the resulting graph is a tree of N nodes. If
        there are multiple answers, return the answer that occurs last in the given 2D-array. The
        answer edge [u, v] should be in the same format, with u < v.
    
    Example 1:
    Input: [[1,2], [1,3], [2,3]]
Output: [2,3]
Explanation: The given undirected graph will be like this:
  1
 / \
2 - 3

    
    Example 2:
    Input: [[1,2], [2,3], [3,4], [1,4], [1,5]]
Output: [1,4]
Explanation: The given undirected graph will be like this:
5 - 1 - 2
    |   |
    4 - 3

    
    Note:
    The size of the input 2D-array will be between 3 and 1000.
    Every integer represented in the 2D-array will be between 1 and N, where N is the size of
        the input array.
    
    

    

    
        Update (2017-09-26):
        We have overhauled the problem description + test cases and specified clearly the graph is
        an undirected graph. For the directed graph follow up please see
        Redundant
            Connection II). We apologize for any inconvenience caused.
-----------------

# 635_Design_Log_Storage_System
# 635. Design Log Storage System

You are given several logs that each log contains a unique id and timestamp. Timestamp is a
        string that has the following format: Year:Month:Day:Hour:Minute:Second, for
        example, 2017:01:01:23:59:59. All domains are zero-padded decimal numbers. 

    Design a log storage system to implement the following functions:

    void Put(int id, string timestamp): Given a log's unique id and timestamp, store
        the log in your storage system.
    
    int[] Retrieve(String start, String end, String granularity): Return the id of
        logs whose timestamps are within the range from start to end. Start and end all have the
        same format as timestamp. However, granularity means the time level for consideration. For
        example, start = "2017:01:01:23:59:59", end = "2017:01:02:23:59:59", granularity = "Day", it
        means that we need to find the logs within the range from Jan. 1st 2017 to Jan. 2nd 2017.
    

    Example 1:
    put(1, "2017:01:01:23:59:59");
put(2, "2017:01:01:22:59:59");
put(3, "2016:01:01:00:00:00");
retrieve("2016:01:01:01:01:01","2017:01:01:23:00:00","Year"); // return [1,2,3], because you need to return all logs within 2016 and 2017.
retrieve("2016:01:01:01:01:01","2017:01:01:23:00:00","Hour"); // return [1,2], because you need to return all logs start from 2016:01:01:01 to 2017:01:01:23, where log 3 is left outside the range.

    

    Note:
    
        There will be at most 300 operations of Put or Retrieve.
        Year ranges from [2000,2017]. Hour ranges from [00,23].
        Output for Retrieve has no order required.
-----------------

# 466_Count_The_Repetitions
# 466. Count The Repetitions

Define S = [s,n] as the string S which consists of n connected strings s. For
        example, ["abc", 3] ="abcabcabc". 
    On the other hand, we define that string s1 can be obtained from string s2 if we can remove
        some characters from s2 such that it becomes s1. For example, “abc” can be obtained from
        “abdbec” based on our definition, but it can not be obtained from “acbbe”.
    You are given two non-empty strings s1 and s2 (each at most 100 characters long) and two
        integers 0 ≤ n1 ≤ 106 and 1 ≤ n2 ≤ 106. Now consider the
        strings S1 and S2, where S1=[s1,n1] and S2=[s2,n2]. Find the
        maximum integer M such that [S2,M] can be obtained from S1.

    Example:
    Input:
s1="acb", n1=4
s2="ab", n2=2

Return:
2
-----------------

# 1675_Minimize_Deviation_in_Array
# 1675. Minimize Deviation in Array


-----------------

# 134_Gas_Station
# 134. Gas Station

There are N gas stations along a circular route, where the amount of gas at station
        i is gas[i].

    You have a car with an unlimited gas tank and it costs cost[i] of gas to travel
        from station i to its next station (i+1). You begin the journey with an
        empty tank at one of the gas stations.

    Return the starting gas station's index if you can travel around the circuit once in the
        clockwise direction, otherwise return -1.

    Note:

    
        If there exists a solution, it is guaranteed to be unique.
        Both input arrays are non-empty and have the same length.
        Each element in the input arrays is a non-negative integer.
    

    Example 1:

    Input:
gas  = [1,2,3,4,5]
cost = [3,4,5,1,2]

Output: 3

Explanation:
Start at station 3 (index 3) and fill up with 4 unit of gas. Your tank = 0 + 4 = 4
Travel to station 4. Your tank = 4 - 1 + 5 = 8
Travel to station 0. Your tank = 8 - 2 + 1 = 7
Travel to station 1. Your tank = 7 - 3 + 2 = 6
Travel to station 2. Your tank = 6 - 4 + 3 = 5
Travel to station 3. The cost is 5. Your gas is just enough to travel back to station 3.
Therefore, return 3 as the starting index.

    Example 2:

    Input:
gas  = [2,3,4]
cost = [3,4,3]

Output: -1

Explanation:
You can't start at station 0 or 1, as there is not enough gas to travel to the next station.
Let's start at station 2 and fill up with 4 unit of gas. Your tank = 0 + 4 = 4
Travel to station 0. Your tank = 4 - 3 + 2 = 3
Travel to station 1. Your tank = 3 - 3 + 3 = 3
You cannot travel back to station 2, as it requires 4 unit of gas but you only have 3.
Therefore, you can't travel around the circuit once no matter where you start.
-----------------

# 623_Add_One_Row_to_Tree
# 623. Add One Row to Tree

Given the root of a binary tree, then value v and depth d, you need
        to add a row of nodes with value v at the given depth d. The root
        node is at depth 1. 

    The adding rule is: given a positive integer depth d, for each NOT null tree
        nodes N in depth d-1, create two tree nodes with value
        v as N's left subtree root and right subtree root. And
        N's original left subtree should be the left subtree of the new left
        subtree root, its original right subtree should be the right subtree of the new right
        subtree root. If depth d is 1 that means there is no depth d-1 at all, then
        create a tree node with value v as the new root of the whole original tree, and the
        original tree is the new root's left subtree.

    Example 1:
    Input:
A binary tree as following:
       4
     /   \
    2     6
   / \   /
  3   1 5

v = 1

d = 2

Output:
       4
      / \
     1   1
    /     \
   2       6
  / \     /
 3   1   5

    

    Example 2:
    Input:
A binary tree as following:
      4
     /
    2
   / \
  3   1

v = 1

d = 3

Output:
      4
     /
    2
   / \
  1   1
 /     \
3       1

    

    Note:
    
        The given d is in range [1, maximum depth of the given tree + 1].
        The given binary tree has at least one tree node.
-----------------

# 1634_Add_Two_Polynomials_Represented_as_Linked_Lists
# 1634. Add Two Polynomials Represented as Linked Lists


-----------------

# 668_Kth_Smallest_Number_in_Multiplication_Table
# 668. Kth Smallest Number in Multiplication Table

Nearly every one have used the Multiplication
        Table. But could you find out the k-th smallest number quickly from the
        multiplication table?
    

    
        Given the height m and the length n of a m * n
        Multiplication Table, and a positive integer k, you need to return the k-th
        smallest number in this table.
    

    Example 1:
    Input: m = 3, n = 3, k = 5
Output:
Explanation:
The Multiplication Table:
1	2	3
2	4	6
3	6	9

The 5-th smallest number is 3 (1, 2, 2, 3, 3).

    

    Example 2:
    Input: m = 2, n = 3, k = 6
Output:
Explanation:
The Multiplication Table:
1	2	3
2	4	6

The 6-th smallest number is 6 (1, 2, 2, 3, 4, 6).

    

    Note:
    
        The m and n will be in the range [1, 30000].
        The k will be in the range [1, m * n]
-----------------

# 1573_Number_of_Ways_to_Split_a_String
# 1573. Number of Ways to Split a String


-----------------

# 74_Search_a_2D_Matrix
# 74. Search a 2D Matrix

Write an efficient algorithm that searches for a value in an m x n matrix.
        This matrix has the following properties:

    
        Integers in each row are sorted from left to right.
        The first integer of each row is greater than the last integer of the previous row.
    

    Example 1:

    Input:
matrix = [
  [1,   3,  5,  7],
  [10, 11, 16, 20],
  [23, 30, 34, 50]
]
target = 3
Output: true

    Example 2:

    Input:
matrix = [
  [1,   3,  5,  7],
  [10, 11, 16, 20],
  [23, 30, 34, 50]
]
target = 13
Output: false
-----------------

# 30_Substring_with_Concatenation_of_All_Words
# 30. Substring with Concatenation of All Words

You are given a string, s, and a list of words, words, that
        are all of the same length. Find all starting indices of substring(s) in s
        that is a concatenation of each word in words exactly once and without any
        intervening characters.

    Example 1:

    Input:
  s = "barfoothefoobarman",
  words = ["foo","bar"]
Output: [0,9]
Explanation: Substrings starting at index 0 and 9 are "barfoor" and "foobar" respectively.
The output order does not matter, returning [9,0] is fine too.

    Example 2:

    Input:
  s = "wordgoodgoodgoodbestword",
  words = ["word","good","best","word"]
Output: []
-----------------

# 1304_Find_N_Unique_Integers_Sum_up_to_Zero
# 1304. Find N Unique Integers Sum up to Zero


-----------------

# 392_Is_Subsequence
# 392. Is Subsequence

Given a string s and a string t, check if s is subsequence of t.
    

    
        You may assume that there is only lower case English letters in both s and t.
        t is potentially a very long (length ~= 500,000) string, and s is a short
        string (<=100).
    

    
        A subsequence of a string is a new string which is formed from the original string by
        deleting some (can be none) of the characters without disturbing the relative positions of
        the remaining characters. (ie, "ace" is a subsequence of "abcde"
        while "aec" is not).
    

    Example 1:
        s = "abc", t = "ahbgdc"
    
    
        Return true.
    

    Example 2:
        s = "axc", t = "ahbgdc"
    
    
        Return false.
    

    Follow up:
        If there are lots of incoming S, say S1, S2, ... , Sk where k >= 1B, and you want to check
        one by one to see if T has its subsequence. In this scenario, how would you change your
        code?

    Credits:Special thanks to @pbrother
        for adding this problem and creating all test cases.
-----------------

# 824_Goat_Latin
# 824. Goat Latin

A sentence S is given, composed of words separated by spaces. Each word consists
        of lowercase and uppercase letters only.

    We would like to convert the sentence to "Goat Latin" (a made-up
        language similar to Pig Latin.)

    The rules of Goat Latin are as follows:

    
        If a word begins with a vowel (a, e, i, o, or u), append "ma" to
            the end of the word.
            For example, the word 'apple' becomes 'applema'.
             
        
        If a word begins with a consonant (i.e. not a vowel), remove the first letter and append
            it to the end, then add "ma".
            For example, the word "goat" becomes "oatgma".
             
        
        Add one letter 'a' to the end of each word per its word index
            in the sentence, starting with 1.
            For example, the first word gets "a" added to the end, the
            second word gets "aa" added to the end and so on.
        
    

    Return the final sentence representing the conversion from S to Goat Latin. 
    

     

    Example 1:

    Input: "I speak Goat Latin"
Output: "Imaa peaksmaaa oatGmaaaa atinLmaaaaa"

    Example 2:

    Input: "The quick brown fox jumped over the lazy dog"
Output: "heTmaa uickqmaaa rownbmaaaa oxfmaaaaa umpedjmaaaaaa overmaaaaaaa hetmaaaaaaaa azylmaaaaaaaaa ogdmaaaaaaaaaa"

     

    Notes:

    
        S contains only uppercase, lowercase and spaces. Exactly one space
            between each word.
        
        1 <= S.length <= 150.
-----------------

# 1486_XOR_Operation_in_an_Array
# 1486. XOR Operation in an Array


-----------------

# 467_Unique_Substrings_in_Wraparound_String
# 467. Unique Substrings in Wraparound String

Consider the string s to be the infinite wraparound string of
        "abcdefghijklmnopqrstuvwxyz", so s will look like this:
        "...zabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcd....".

    Now we have another string p. Your job is to find out how many unique non-empty
        substrings of p are present in s. In particular, your input is the
        string p and you need to output the number of different non-empty substrings of
        p in the string s.

    Note: p consists of only lowercase English letters and the size of p
        might be over 10000.

    Example 1:
    Input: "a"
Output: 1

Explanation: Only the substring "a" of string "a" is in the string s.

    

    Example 2:
    Input: "cac"
Output: 2
Explanation: There are two substrings "a", "c" of string "cac" in the string s.

    

    Example 3:
    Input: "zab"
Output: 6
Explanation: There are six substrings "z", "a", "b", "za", "ab", "zab" of string "zab" in the string s.
-----------------

# 1282_Group_the_People_Given_the_Group_Size_They_Belong_To
# 1282. Group the People Given the Group Size They Belong To


-----------------

# 371_Sum_of_Two_Integers
# 371. Sum of Two Integers

Calculate the sum of two integers a and b, but you are not allowed to
        use the operator + and -.
-----------------

# 1654_Minimum_Jumps_to_Reach_Home
# 1654. Minimum Jumps to Reach Home


-----------------

# 86_Partition_List
# 86. Partition List

Given a linked list and a value x, partition it such that all nodes less than
        x come before nodes greater than or equal to x.

    You should preserve the original relative order of the nodes in each of the two
        partitions.

    Example:

    Input: head = 1->4->3->2->5->2, x = 3
Output: 1->2->2->4->3->5
-----------------

# 22_Generate_Parentheses
# 22. Generate Parentheses

Given n pairs of parentheses, write a function to generate all combinations of
        well-formed parentheses.
    

    
        For example, given n = 3, a solution set is:
    
    [
  "((()))",
  "(()())",
  "(())()",
  "()(())",
  "()()()"
]
-----------------

# 505_The_Maze_II
# 505. The Maze II

There is a ball in a maze with empty spaces and walls. The ball can go through empty
        spaces by rolling up, down, left or right, but it won't stop
        rolling until hitting a wall. When the ball stops, it could choose the next direction.

    Given the ball's start position, the destination and the maze, find
        the shortest distance for the ball to stop at the destination. The distance is defined by
        the number of empty spaces traveled by the ball from the start position (excluded) to
        the destination (included). If the ball cannot stop at the destination, return -1.

    The maze is represented by a binary 2D array. 1 means the wall and 0 means the empty space.
        You may assume that the borders of the maze are all walls. The start and destination
        coordinates are represented by row and column indexes.

     

    Example 1:

    Input 1: a maze represented by a 2D array

0 0 1 0 0
0 0 0 0 0
0 0 0 1 0
1 1 0 1 1
0 0 0 0 0

Input 2: start coordinate (rowStart, colStart) = (0, 4)
Input 3: destination coordinate (rowDest, colDest) = (4, 4)

Output: 12

Explanation: One shortest way is : left -> down -> left -> down -> right -> down -> right.
             The total distance is 1 + 1 + 3 + 1 + 2 + 2 + 2 = 12.

    Example 2:

    Input 1: a maze represented by a 2D array

0 0 1 0 0
0 0 0 0 0
0 0 0 1 0
1 1 0 1 1
0 0 0 0 0

Input 2: start coordinate (rowStart, colStart) = (0, 4)
Input 3: destination coordinate (rowDest, colDest) = (3, 2)

Output: -1

Explanation: There is no way for the ball to stop at the destination.

     

    Note:

    
        There is only one ball and one destination in the maze.
        Both the ball and the destination exist on an empty space, and they will not be at the
            same position initially.
        
        The given maze does not contain border (like the red rectangle in the example pictures),
            but you could assume the border of the maze are all walls.
        
        The maze contains at least 2 empty spaces, and both the width and height of the maze won't
            exceed 100.
-----------------

# 447_Number_of_Boomerangs
# 447. Number of Boomerangs

Given n points in the plane that are all pairwise distinct, a "boomerang" is
        a tuple of points (i, j, k) such that the distance between i and
        j equals the distance between i and k (the order
            of the tuple matters).

    Find the number of boomerangs. You may assume that n will be at most 500 and
        coordinates of points are all in the range [-10000, 10000] (inclusive).

    Example:

    Input:
[[0,0],[1,0],[2,0]]

Output:
2

Explanation:
The two boomerangs are [[1,0],[0,0],[2,0]] and [[1,0],[2,0],[0,0]]
-----------------

# 366_Find_Leaves_of_Binary_Tree
# 366. Find Leaves of Binary Tree

Given a binary tree, collect a tree's nodes as if you were doing this: Collect and remove
        all leaves, repeat until the tree is empty.

     

    Example:

    Input: [1,2,3,4,5]
 
          1
         / \
        2   3
       / \
      4   5

Output: [[4,5,3],[2],[1]]

     

    Explanation:

    1. Removing the leaves [4,5,3] would result in this tree:

              1
         /
        2

     

    2. Now removing the leaf [2] would result in this tree:

              1

     

    3. Now removing the leaf [1] would result in the empty tree:

              []
-----------------

# 1200_Minimum_Absolute_Difference
# 1200. Minimum Absolute Difference

Given an array of distinct integers arr, find
        all pairs of elements with the minimum absolute difference of any two elements. 

    Return a list of pairs in ascending order(with respect to pairs), each pair [a,
        b] follows

    
        a, b are from arr
        a < b
        b - a equals to the minimum absolute difference of any two elements in
            arr
    

     
    Example 1:

    Input: arr = [4,2,1,3]
Output: [[1,2],[2,3],[3,4]]
Explanation: The minimum absolute difference is 1. List all pairs with difference equal to 1 in ascending order.

    Example 2:

    Input: arr = [1,3,6,10,15]
Output: [[1,3]]

    Example 3:

    Input: arr = [3,8,-10,23,19,-4,-14,27]
Output: [[-14,-10],[19,23],[23,27]]

     
    Constraints:

    
        2 <= arr.length <= 10^5
        -10^6 <= arr[i] <= 10^6
-----------------

# 515_Find_Largest_Value_in_Each_Tree_Row
# 515. Find Largest Value in Each Tree Row

You need to find the largest value in each row of a binary tree.

    Example:
    Input:

          1
         / \
        3   2
       / \   \
      5   3   9

Output: [1, 3, 9]
-----------------

# 38_Count_and_Say
# 38. Count and Say

The count-and-say sequence is the sequence of integers with the first five terms as
        following:

    1.     1
2.     11
3.     21
4.     1211
5.     111221

    1 is read off as "one 1" or 11.
        11 is read off as "two 1s" or 21.
        21 is read off as "one 2, then one 1" or
        1211.

    Given an integer n where 1 ≤ n ≤ 30, generate the
        nth term of the count-and-say sequence.

    Note: Each term of the sequence of integers will be represented as a string.

     

    Example 1:

    Input: 1
Output: "1"

    Example 2:

    Input: 4
Output: "1211"
-----------------

# 709_To_Lower_Case
# 709. To Lower Case

Implement function ToLowerCase() that has a string parameter str, and returns the same string
        in lowercase.
-----------------

# 916_Word_Subsets
# 916. Word Subsets

We are given two arrays A and B of words.  Each word is a
        string of lowercase letters.

    Now, say that word b is a subset of word
        a if every letter in b occurs in
        a, including multiplicity.  For example, "wrr"
        is a subset of "warrior", but is not a subset of "world".
    

    Now say a word a from A is universal if for every
        b in B, b is a subset of a. 
    

    Return a list of all universal words in A.  You can return the words in any
        order.
-----------------

# 1605_Find_Valid_Matrix_Given_Row_and_Column_Sums
# 1605. Find Valid Matrix Given Row and Column Sums


-----------------

# 363_Max_Sum_of_Rectangle_No_Larger_Than_K
# 363. Max Sum of Rectangle No Larger Than K

Given a non-empty 2D matrix matrix and an integer k, find the max sum of a
        rectangle in the matrix such that its sum is no larger than k.

    Example:

    Input: matrix = [[1,0,1],[0,-2,3]], k = 2
Output: 2
Explanation: Because the sum of rectangle [[0, 1], [-2, 3]] is 2,
             and 2 is the max number no larger than k (k = 2).

    Note:

    
        The rectangle inside the matrix must have an area > 0.
        What if the number of rows is much larger than the number of columns?
-----------------

# 1403_Minimum_Subsequence_in_Non-Increasing_Order
# 1403. Minimum Subsequence in Non-Increasing Order


-----------------

# 1038_Binary_Search_Tree_to_Greater_Sum_Tree
# 1038. Binary Search Tree to Greater Sum Tree

Given the root of a binary search tree with distinct values, modify it so
        that every node has a new value equal to the sum of the values of the
        original tree that are greater than or equal to node.val.

    As a reminder, a binary search tree is a tree that satisfies these constraints:
    

    
        The left subtree of a node contains only nodes with keys less than the
            node's key.
        
        The right subtree of a node contains only nodes with keys greater
            than the node's key.
        
        Both the left and right subtrees must also be binary search trees.
    

     

    Example 1:

    

    Input: [4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]
Output: [30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]
-----------------

# 239_Sliding_Window_Maximum
# 239. Sliding Window Maximum

Given an array nums, there is a sliding window of size k which is moving
        from the very left of the array to the very right. You can only see the k numbers
        in the window. Each time the sliding window moves right by one position. Return the max
        sliding window.

    Example:

    Input: nums = [1,3,-1,-3,5,3,6,7], and k = 3
Output: [3,3,5,5,6,7]
Explanation:

Window position                Max
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7

    Note: 
        You may assume k is always valid, 1 ≤ k ≤ input array's size for
        non-empty array.

    Follow up:
        Could you solve it in linear time?
-----------------

# 1025_Divisor_Game
# 1025. Divisor Game

Alice and Bob take turns playing a game, with Alice starting first.

    Initially, there is a number N on the chalkboard.  On each player's
        turn, that player makes a move consisting of:

    
        Choosing any x with 0 < x < N and N % x ==
            0.
        
        Replacing the number N on the chalkboard with N -
            x.
        
    

    Also, if a player cannot make a move, they lose the game.

    Return True if and only if Alice wins the game, assuming both players play
        optimally.
-----------------

# 542_01_Matrix
# 542. 01 Matrix

Given a matrix consists of 0 and 1, find the distance of the nearest 0 for each cell.

    The distance between two adjacent cells is 1.

     

    Example 1: 

    Input:
[[0,0,0],
 [0,1,0],
 [0,0,0]]

Output:
[[0,0,0],
 [0,1,0],
 [0,0,0]]

    Example 2: 

    Input:
[[0,0,0],
 [0,1,0],
 [1,1,1]]

Output:
[[0,0,0],
 [0,1,0],
 [1,2,1]]

     

    Note:

    
        The number of elements of the given matrix will not exceed 10,000.
        There are at least one 0 in the given matrix.
        The cells are adjacent in only four directions: up, down, left and right.
-----------------

# 914_X_of_a_Kind_in_a_Deck_of_Cards
# 914. X of a Kind in a Deck of Cards

In a deck of cards, each card has an integer written on it.

    Return true if and only if you can choose X >= 2 such that it
        is possible to split the entire deck into 1 or more groups of cards, where:

    
        Each group has exactly X cards.
        All the cards in each group have the same integer.
    

     

    Example 1:

    Input: [1,2,3,4,4,3,2,1]
Output: true
Explanation: Possible partition [1,1],[2,2],[3,3],[4,4]
-----------------

# 1175_Prime_Arrangements
# 1175. Prime Arrangements

Return the number of permutations of 1 to n so that prime numbers are at prime
        indices (1-indexed.)

    (Recall that an integer is prime if and only if it is greater than 1, and cannot be
        written as a product of two positive integers both smaller than it.)

    Since the answer may be large, return the answer modulo 10^9 +
        7.

     
    Example 1:

    Input: n = 5
Output: 12
Explanation: For example [1,2,5,4,3] is a valid permutation, but [5,2,3,4,1] is not because the prime number 5 is at index 1.

    Example 2:

    Input: n = 100
Output: 682289015

     
    Constraints:

    
        1 <= n <= 100
-----------------

# 621_Task_Scheduler
# 621. Task Scheduler

Given a char array representing tasks CPU need to do. It contains capital letters A to Z
        where different letters represent different tasks. Tasks could be done without original
        order. Each task could be done in one interval. For each interval, CPU could finish one task
        or just be idle.

    However, there is a non-negative cooling interval n that means between two same
        tasks, there must be at least n intervals that CPU are doing different tasks or just be
        idle.

    You need to return the least number of intervals the CPU will take to finish all the
        given tasks.

     

    Example:

    Input: tasks = ["A","A","A","B","B","B"], n = 2
Output: 8
Explanation: A -> B -> idle -> A -> B -> idle -> A -> B.

     

    Note:

    
        The number of tasks is in the range [1, 10000].
        The integer n is in the range [0, 100].
-----------------

# 1428_Leftmost_Column_with_at_Least_a_One
# 1428. Leftmost Column with at Least a One


-----------------

# 1418_Display_Table_of_Food_Orders_in_a_Restaurant
# 1418. Display Table of Food Orders in a Restaurant


-----------------

# 826_Most_Profit_Assigning_Work
# 826. Most Profit Assigning Work

We have jobs: difficulty[i] is the difficulty of the ith
        job, and profit[i] is the profit of the ith job. 
    

    Now we have some workers. worker[i] is the ability of
        the ith worker, which means that this worker can only complete a job with
        difficulty at most worker[i]. 

    Every worker can be assigned at most one job, but one job can be completed multiple
        times.

    For example, if 3 people attempt the same job that pays $1, then the total profit will be $3. 
        If a worker cannot complete any job, his profit is $0.

    What is the most profit we can make?

    Example 1:

    Input: difficulty = [2,4,6,8,10], profit = [10,20,30,40,50], worker = [4,5,6,7]
Output: 100
Explanation: Workers are assigned jobs of difficulty [4,4,6,6] and they get profit of [20,20,30,30] seperately.

    Notes:

    
        1 <= difficulty.length = profit.length <= 10000
        1 <= worker.length <= 10000
        difficulty[i], profit[i], worker[i]  are in range [1,
            10^5]
-----------------

# 1238_Circular_Permutation_in_Binary_Representation
# 1238. Circular Permutation in Binary Representation

Given 2 integers n and start. Your task is return
        any permutation p of (0,1,2.....,2^n -1) such
        that :

    
        p[0] = start
        p[i] and p[i+1] differ by only one bit in their binary
            representation.
        
        p[0] and p[2^n -1] must also differ by only one bit in
            their binary representation.
        
    

     
    Example 1:

    Input: n = 2, start = 3
Output: [3,2,0,1]
Explanation: The binary representation of the permutation is (11,10,00,01).
All the adjacent element differ by one bit. Another valid permutation is [3,1,0,2]

    Example 2:

    Input: n = 3, start = 2
Output: [2,6,7,5,4,0,1,3]
Explanation: The binary representation of the permutation is (010,110,111,101,100,000,001,011).

     
    Constraints:

    
        1 <= n <= 16
        0 <= start < 2 ^ n
-----------------

# 1628_Design_an_Expression_Tree_With_Evaluate_Function
# 1628. Design an Expression Tree With Evaluate Function


-----------------

# 864_Shortest_Path_to_Get_All_Keys
# 864. Shortest Path to Get All Keys

We are given a 2-dimensional grid. "." is an
        empty cell, "#" is a wall, "@" is the
        starting point, ("a", "b", ...) are keys, and
        ("A", "B", ...) are locks.

    We start at the starting point, and one move consists of walking one space in one of the 4
        cardinal directions.  We cannot walk outside the grid, or walk into a wall.  If we
        walk over a key, we pick it up.  We can't walk over a lock unless we have the
        corresponding key.

    For some 1 <= K <= 6, there is exactly one lowercase and
        one uppercase letter of the first K letters of the English alphabet in the
        grid.  This means that there is exactly one key for each lock, and one lock for each
        key; and also that the letters used to represent the keys and locks were chosen in the
        same order as the English alphabet.

    Return the lowest number of moves to acquire all keys.  If it's impossible,
        return -1.
-----------------

# 100_Same_Tree
# 100. Same Tree

Given two binary trees, write a function to check if they are the same or not.

    Two binary trees are considered the same if they are structurally identical and the nodes
        have the same value.

    Example 1:

    Input:     1         1
          / \       / \
         2   3     2   3

        [1,2,3],   [1,2,3]

Output: true

    Example 2:

    Input:     1         1
          /           \
         2             2

        [1,2],     [1,null,2]

Output: false

    Example 3:

    Input:     1         1
          / \       / \
         2   1     1   2

        [1,2,1],   [1,1,2]

Output: false
-----------------

# 892_Surface_Area_of_3D_Shapes
# 892. Surface Area of 3D Shapes

On a N * N grid, we place some 1 * 1 *
        1 cubes.

    Each value v = grid[i][j] represents a tower of v cubes
        placed on top of grid cell (i, j).

    Return the total surface area of the resulting shapes.
-----------------

# 575_Distribute_Candies
# 575. Distribute Candies

Given an integer array with even length, where different numbers in this array represent
    different kinds of candies. Each number means one candy of the corresponding kind. You
    need to distribute these candies equally in number to brother and sister. Return the
    maximum number of kinds of candies the sister could gain.

    Example 1:
    Input: candies = [1,1,2,2,3,3]
Output: 3
Explanation:
There are three different kinds of candies (1, 2 and 3), and two candies for each kind.
Optimal distribution: The sister has candies [1,2,3] and the brother has candies [1,2,3], too.
The sister has three different kinds of candies.

    

    Example 2:
    Input: candies = [1,1,2,3]
Output: 2
Explanation: For example, the sister has candies [2,3] and the brother has candies [1,1].
The sister has two different kinds of candies, the brother has only one kind of candies.

    

    Note:
    
        The length of the given array is in range [2, 10,000], and will be even.
        The number in given array is in range [-100,000, 100,000].
-----------------

# 1253_Reconstruct_a_2-Row_Binary_Matrix
# 1253. Reconstruct a 2-Row Binary Matrix

Given the following details of a matrix with n columns and 2 rows :
    

    
        The matrix is a binary matrix, which means each element in the matrix can be
            0 or 1.
        
        The sum of elements of the 0-th(upper) row is given as upper.
        The sum of elements of the 1-st(lower) row is given as lower.
        The sum of elements in the i-th column(0-indexed) is colsum[i], where
            colsum is given as an integer array with length n.
        
    

    Your task is to reconstruct the matrix with upper, lower and colsum.
    

    Return it as a 2-D integer array.

    If there are more than one valid solution, any of them will be accepted.

    If no valid solution exists, return an empty 2-D array.

     
    Example 1:

    Input: upper = 2, lower = 1, colsum = [1,1,1]
Output: [[1,1,0],[0,0,1]]
Explanation: [[1,0,1],[0,1,0]], and [[0,1,1],[1,0,0]] are also correct answers.

    Example 2:

    Input: upper = 2, lower = 3, colsum = [2,2,1,1]
Output: []

    Example 3:

    Input: upper = 5, lower = 5, colsum = [2,1,2,0,1,0,1,2,0,1]
Output: [[1,1,1,0,1,0,0,1,0,0],[1,0,1,0,0,0,1,1,0,1]]

     
    Constraints:

    
        1 <= colsum.length <= 10^5
        0 <= upper, lower <= colsum.length
        0 <= colsum[i] <= 2
-----------------

# 490_The_Maze
# 490. The Maze

There is a ball in a maze with empty spaces and walls. The ball can go through empty
        spaces by rolling up, down, left or right, but it won't stop
        rolling until hitting a wall. When the ball stops, it could choose the next direction.

    Given the ball's start position, the destination and the maze,
        determine whether the ball could stop at the destination.

    The maze is represented by a binary 2D array. 1 means the wall and 0 means the empty space.
        You may assume that the borders of the maze are all walls. The start and destination
        coordinates are represented by row and column indexes.

     

    Example 1:

    Input 1: a maze represented by a 2D array

0 0 1 0 0
0 0 0 0 0
0 0 0 1 0
1 1 0 1 1
0 0 0 0 0

Input 2: start coordinate (rowStart, colStart) = (0, 4)
Input 3: destination coordinate (rowDest, colDest) = (4, 4)

Output: true

Explanation: One possible way is : left -> down -> left -> down -> right -> down -> right.

    Example 2:

    Input 1: a maze represented by a 2D array

0 0 1 0 0
0 0 0 0 0
0 0 0 1 0
1 1 0 1 1
0 0 0 0 0

Input 2: start coordinate (rowStart, colStart) = (0, 4)
Input 3: destination coordinate (rowDest, colDest) = (3, 2)

Output: false

Explanation: There is no way for the ball to stop at the destination.

     

    Note:

    
        There is only one ball and one destination in the maze.
        Both the ball and the destination exist on an empty space, and they will not be at the
            same position initially.
        
        The given maze does not contain border (like the red rectangle in the example pictures),
            but you could assume the border of the maze are all walls.
        
        The maze contains at least 2 empty spaces, and both the width and height of the maze won't
            exceed 100.
-----------------

# 1595_Minimum_Cost_to_Connect_Two_Groups_of_Points
# 1595. Minimum Cost to Connect Two Groups of Points


-----------------

# 1594_Maximum_Non_Negative_Product_in_a_Matrix
# 1594. Maximum Non Negative Product in a Matrix


-----------------

# 1383_Maximum_Performance_of_a_Team
# 1383. Maximum Performance of a Team


-----------------

# 1564_Put_Boxes_Into_the_Warehouse_I
# 1564. Put Boxes Into the Warehouse I


-----------------

# 491_Increasing_Subsequences
# 491. Increasing Subsequences

Given an integer array, your task is to find all the different possible increasing
        subsequences of the given array, and the length of an increasing subsequence should be at
        least 2.

     

    Example:

    Input: [4, 6, 7, 7]
Output: [[4, 6], [4, 7], [4, 6, 7], [4, 6, 7, 7], [6, 7], [6, 7, 7], [7,7], [4,7,7]]

     

    Note:

    
        The length of the given array will not exceed 15.
        The range of integer in the given array is [-100,100].
        The given array may contain duplicates, and two equal integers should also be considered
            as a special case of increasing sequence.
-----------------

# 588_Design_In-Memory_File_System
# 588. Design In-Memory File System

Design an in-memory file system to simulate the following functions:

    ls: Given a path in string format. If it is a file path, return a list that only
        contains this file's name. If it is a directory path, return the list of file and
        directory names in this directory. Your output (file and directory names together)
        should in lexicographic order.

    mkdir: Given a directory path that does not exist, you should make a new
        directory according to the path. If the middle directories in the path don't exist
        either, you should create them as well. This function has void return type.

    addContentToFile: Given a file path and file content in string
        format. If the file doesn't exist, you need to create that file containing given
        content. If the file already exists, you need to append given content to original
        content. This function has void return type.

    readContentFromFile: Given a file path, return its content in
        string format.

     

    Example:

    Input:
["FileSystem","ls","mkdir","addContentToFile","ls","readContentFromFile"]
[[],["/"],["/a/b/c"],["/a/b/c/d","hello"],["/"],["/a/b/c/d"]]

Output:
[null,[],null,null,["a"],"hello"]

Explanation:

     

    Note:

    
        You can assume all file or directory paths are absolute paths which begin with
            / and do not end with / except that the path is just "/".
        
        You can assume that all operations will be passed valid parameters and users will not
            attempt to retrieve file content or list a directory or file that does not exist.
        
        You can assume that all directory names and file names only contain lower-case letters,
            and same names won't exist in the same directory.
-----------------

# 727_Minimum_Window_Subsequence
# 727. Minimum Window Subsequence

Given strings S and T, find the minimum (contiguous)
        substring W of S, so that T is a subsequence
        of W.

    If there is no such window in S that covers all characters in T,
        return the empty string "". If there are multiple such minimum-length
        windows, return the one with the left-most starting index.

    Example 1:

    Input:
S = "abcdebdde", T = "bde"
Output: "bcde"
Explanation:
"bcde" is the answer because it occurs before "bdde" which has the same length.
"deb" is not a smaller window because the elements of T in the window must occur in order.

     

    Note:

    
        All the strings in the input will only contain lowercase letters.
        The length of S will be in the range [1, 20000].
        The length of T will be in the range [1, 100].
-----------------

# 733_Flood_Fill
# 733. Flood Fill

An image is represented by a 2-D array of integers, each integer representing
        the pixel value of the image (from 0 to 65535).
    
    
        Given a coordinate (sr, sc) representing the starting pixel (row and column) of
        the flood fill, and a pixel value newColor, "flood fill" the image.
    
    
        To perform a "flood fill", consider the starting pixel, plus any pixels connected
        4-directionally to the starting pixel of the same color as the starting pixel, plus any
        pixels connected 4-directionally to those pixels (also with the same color as the starting
        pixel), and so on. Replace the color of all of the aforementioned pixels with the newColor.
    
    
        At the end, return the modified image.
    
    Example 1:
    Input:
image = [[1,1,1],[1,1,0],[1,0,1]]
sr = 1, sc = 1, newColor = 2
Output: [[2,2,2],[2,2,0],[2,0,1]]
Explanation:
From the center of the image (with position (sr, sc) = (1, 1)), all pixels connected
by a path of the same color as the starting pixel are colored with the new color.
Note the bottom corner is not colored 2, because it is not 4-directionally connected
to the starting pixel.

    

    Note:
    The length of image and image[0] will be in the range [1,
        50].
    
    The given starting pixel will satisfy 0 <= sr < image.length and 0 <= sc
        < image[0].length.
    
    The value of each color in image[i][j] and newColor will be an
        integer in [0, 65535].
-----------------

# 441_Arranging_Coins
# 441. Arranging Coins

You have a total of n coins that you want to form in a staircase shape, where every
        k-th row must have exactly k coins.

    Given n, find the total number of full staircase rows that can be formed.

    n is a non-negative integer and fits within the range of a 32-bit signed integer.

    Example 1:
    n = 5

The coins can form the following rows:
¤
¤ ¤
¤ ¤

Because the 3rd row is incomplete, we return 2.

    

    Example 2:
    n = 8

The coins can form the following rows:
¤
¤ ¤
¤ ¤ ¤
¤ ¤

Because the 4th row is incomplete, we return 3.
-----------------

# 1012_Numbers_With_Repeated_Digits
# 1012. Numbers With Repeated Digits

Given a positive integer N, return the number of positive integers less than or
        equal to N that have at least 1 repeated digit.
-----------------

# 143_Reorder_List
# 143. Reorder List

Given a singly linked list L: L0→L1→…→Ln-1→Ln,
        reorder it to:
        L0→Ln→L1→Ln-1→L2→Ln-2→…
    

    You may not modify the values in the list's nodes, only nodes itself may
        be changed.

    Example 1:

    Given 1->2->3->4, reorder it to 1->4->2->3.

    Example 2:

    Given 1->2->3->4->5, reorder it to 1->5->2->4->3.
-----------------

# 1140_Stone_Game_II
# 1140. Stone Game II

Alex and Lee continue their games with piles of stones.  There are a number of piles arranged
        in a row, and each pile has a positive integer number of
        stones piles[i].  The objective of the game is to end with the most stones. 
    

    Alex and Lee take turns, with Alex starting first.  Initially, M = 1.

    On each player's turn, that player can take all the stones in the
        first X remaining piles, where 1 <= X <= 2M. 
        Then, we set M = max(M, X).

    The game continues until all the stones have been taken.

    Assuming Alex and Lee play optimally, return the maximum number of stones Alex can get.

     
    Example 1:

    Input: piles = [2,7,9,4,4]
Output: 10
Explanation:  If Alex takes one pile at the beginning, Lee takes two piles, then Alex takes 2 piles again. Alex can get 2 + 4 + 4 = 10 piles in total. If Alex takes two piles at the beginning, then Lee can take all three piles left. In this case, Alex get 2 + 7 = 9 piles in total. So we return 10 since it's larger.

     
    Constraints:

    
        1 <= piles.length <= 100
        1 <= piles[i] <= 10 ^ 4
-----------------

# 483_Smallest_Good_Base
# 483. Smallest Good Base

For an integer n, we call k>=2 a good base of n, if all digits of n base k
        are 1.

    Now given a string representing n, you should return the smallest good base of n in string
        format.

    Example 1:

    Input: "13"
Output: "3"
Explanation: 13 base 3 is 111.

     

    Example 2:

    Input: "4681"
Output: "8"
Explanation: 4681 base 8 is 11111.

     

    Example 3:

    Input: "1000000000000000000"
Output: "999999999999999999"
Explanation: 1000000000000000000 base 999999999999999999 is 11.

     

    Note:

    
        The range of n is [3, 10^18].
        The string representing n is always valid and will not have leading zeros.
-----------------

# 1385_Find_the_Distance_Value_Between_Two_Arrays
# 1385. Find the Distance Value Between Two Arrays


-----------------

# 890_Find_and_Replace_Pattern
# 890. Find and Replace Pattern

You have a list of words and a pattern, and you want to know
        which words in words matches the pattern.

    A word matches the pattern if there exists a permutation of letters p so that
        after replacing every letter x in the pattern with p(x), we get
        the desired word.

    (Recall that a permutation of letters is a bijection from letters to letters: every
        letter maps to another letter, and no two letters map to the same letter.)

    Return a list of the words in words that match the given pattern. 

    You may return the answer in any order.
-----------------

# 518_Coin_Change_2
# 518. Coin Change 2

You are given coins of different denominations and a total amount of money. Write a function
        to compute the number of combinations that make up that amount. You may assume that you have
        infinite number of each kind of coin.

    
    

     

    Example 1:

    Input: amount = 5, coins = [1, 2, 5]
Output: 4
Explanation: there are four ways to make up the amount:
5=5
5=2+2+1
5=2+1+1+1
5=1+1+1+1+1

    Example 2:

    Input: amount = 3, coins = [2]
Output: 0
Explanation: the amount of 3 cannot be made up just with coins of 2.

    Example 3:

    Input: amount = 10, coins = [10]
Output: 1

     

    Note:

    You can assume that

    
        0 <= amount <= 5000
        1 <= coin <= 5000
        the number of coins is less than 500
        the answer is guaranteed to fit into signed 32-bit integer
-----------------

# 1786_Number_of_Restricted_Paths_From_First_to_Last_Node
# 1786. Number of Restricted Paths From First to Last Node


-----------------

# 341_Flatten_Nested_List_Iterator
# 341. Flatten Nested List Iterator

Given a nested list of integers, implement an iterator to flatten it.

    Each element is either an integer, or a list -- whose elements may also be integers or other
        lists.

    Example 1:
-----------------

# 1017_Convert_to_Base_-2
# 1017. Convert to Base -2

Given a number N, return a string consisting of "0"s and
        "1"s that represents its value in base -2 (negative
        two).

    The returned string must have no leading zeroes, unless the string is
        "0".
-----------------

# 1641_Count_Sorted_Vowel_Strings
# 1641. Count Sorted Vowel Strings


-----------------

# 1494_Parallel_Courses_II
# 1494. Parallel Courses II


-----------------

# 197_Rising_Temperature
# 197. Rising Temperature

Given a Weather table, write a SQL query to find all dates' Ids with higher
        temperature compared to its previous (yesterday's) dates.

    +---------+------------------+------------------+
| Id(INT) | RecordDate(DATE) | Temperature(INT) |
+---------+------------------+------------------+
|       1 |       2015-01-01 |               10 |
|       2 |       2015-01-02 |               25 |
|       3 |       2015-01-03 |               20 |
|       4 |       2015-01-04 |               30 |
+---------+------------------+------------------+

    For example, return the following Ids for the above Weather table:

    +----+
| Id |
+----+
|  2 |
|  4 |
+----+
-----------------

# 517_Super_Washing_Machines
# 517. Super Washing Machines

You have n super washing machines on a line. Initially, each washing machine has some
        dresses or is empty.
    

    For each move, you could choose any m (1 ≤ m ≤ n) washing machines, and
        pass one dress of each washing machine to one of its adjacent washing machines  at
            the same time . 

    Given an integer array representing the number of dresses in each washing machine from left
        to right on the line, you should find the minimum number of moves to make all the
        washing machines have the same number of dresses. If it is not possible to do it, return -1.
    

    Example1
    Input: [1,0,5]

Output: 3

Explanation:
1st move:    1     0 <-- 5    =>    1     1     4
2nd move:    1 <-- 1 <-- 4    =>    2     1     3
3rd move:    2     1 <-- 3    =>    2     2     2

    Example2
    Input: [0,3,0]

Output: 2

Explanation:
1st move:    0 <-- 3     0    =>    1     2     0
2nd move:    1     2 --> 0    =>    1     1     1

    Example3
    Input: [0,2,0]

Output: -1

Explanation:
It's impossible to make all the three washing machines have the same number of dresses.

    

    Note:
    
        The range of n is [1, 10000].
        The range of dresses number in a super washing machine is [0, 1e5].
-----------------

# 1780_Check_if_Number_is_a_Sum_of_Powers_of_Three
# 1780. Check if Number is a Sum of Powers of Three


-----------------

# 1196_How_Many_Apples_Can_You_Put_into_the_Basket
# 1196. How Many Apples Can You Put into the Basket

You have some apples, where arr[i] is the weight of the i-th apple. 
        You also have a basket that can carry up to 5000 units of weight.

    Return the maximum number of apples you can put in the basket.

     
    Example 1:

    Input: arr = [100,200,150,1000]
Output: 4
Explanation: All 4 apples can be carried by the basket since their sum of weights is 1450.

    Example 2:

    Input: arr = [900,950,800,1000,700,800]
Output: 5
Explanation: The sum of weights of the 6 apples exceeds 5000 so we choose any 5 of them.

     
    Constraints:

    
        1 <= arr.length <= 10^3
        1 <= arr[i] <= 10^3
-----------------

# 291_Word_Pattern_II
# 291. Word Pattern II

Given a pattern and a string str, find if str follows
        the same pattern.

    Here follow means a full match, such that there is a bijection between a letter in
        pattern and a non-empty substring in str.

    Example 1:

    Input: pattern = "abab", str = "redblueredblue"
Output: true

    Example 2:

    Input: pattern = pattern = "aaaa", str = "asdasdasdasd"
Output: true

    Example 3:

    Input: pattern = "aabb", str = "xyzabcxzyabc"
Output: false

    Notes:
        You may assume both pattern and str contains only lowercase
        letters.
-----------------

# 620_Not_Boring_Movies
# 620. Not Boring Movies

X city opened a new cinema, many people would like to go to this cinema. The cinema also gives
    out a poster indicating the movies’ ratings and descriptions.
    Please write a SQL query to output movies with an odd numbered ID and a description that is
        not 'boring'. Order the result by rating.

     

    For example, table cinema:

    +---------+-----------+--------------+-----------+
|   id    | movie     |  description |  rating   |
+---------+-----------+--------------+-----------+
|   1     | War       |   great 3D   |   8.9     |
|   2     | Science   |   fiction    |   8.5     |
|   3     | irish     |   boring     |   6.2     |
|   4     | Ice song  |   Fantacy    |   8.6     |
|   5     | House card|   Interesting|   9.1     |
+---------+-----------+--------------+-----------+

    For the example above, the output should be:

    +---------+-----------+--------------+-----------+
|   id    | movie     |  description |  rating   |
+---------+-----------+--------------+-----------+
|   5     | House card|   Interesting|   9.1     |
|   1     | War       |   great 3D   |   8.9     |
+---------+-----------+--------------+-----------+
-----------------

# 1131_Maximum_of_Absolute_Value_Expression
# 1131. Maximum of Absolute Value Expression

Given two arrays of integers with equal lengths, return the maximum value of:

    |arr1[i] - arr1[j]| + |arr2[i] - arr2[j]| + |i - j|

    where the maximum is taken over all 0 <= i, j < arr1.length.

     
    Example 1:

    Input: arr1 = [1,2,3,4], arr2 = [-1,4,5,6]
Output: 13

    Example 2:

    Input: arr1 = [1,-2,-5,0,10], arr2 = [0,-2,-1,-7,-4]
Output: 20

     
    Constraints:

    
        2 <= arr1.length == arr2.length <= 40000
        -10^6 <= arr1[i], arr2[i] <= 10^6
-----------------

# 1738_Find_Kth_Largest_XOR_Coordinate_Value
# 1738. Find Kth Largest XOR Coordinate Value


-----------------

# 1582_Special_Positions_in_a_Binary_Matrix
# 1582. Special Positions in a Binary Matrix


-----------------

# 356_Line_Reflection
# 356. Line Reflection

Given n points on a 2D plane, find if there is such a line parallel to y-axis that reflect
        the given points.

    Example 1:

    Input: [[1,1],[-1,1]]
Output: true
-----------------

# 96_Unique_Binary_Search_Trees
# 96. Unique Binary Search Trees

Given n, how many structurally unique BST's (binary search
        trees) that store values 1 ... n?

    Example:

    Input: 3
Output: 5
Explanation:
Given n = 3, there are a total of 5 unique BST's:

   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3
-----------------

# 543_Diameter_of_Binary_Tree
# 543. Diameter of Binary Tree

Given a binary tree, you need to compute the length of the diameter of the tree. The
        diameter of a binary tree is the length of the longest path between any two nodes in
        a tree. This path may or may not pass through the root.
    

    
        Example:
        Given a binary tree 
              1
         / \
        2   3
       / \
      4   5

    
    
        Return 3, which is the length of the path [4,2,1,3] or [5,2,1,3].
    

    Note:
        The length of path between two nodes is represented by the number of edges between them.
-----------------

# 1090_Largest_Values_From_Labels
# 1090. Largest Values From Labels

We have a set of items: the i-th item has value values[i] and label
        labels[i].

    Then, we choose a subset S of these items, such that:

    
        |S| <= num_wanted
        For every label L, the number of items in S with label
            L is <= use_limit.
        
    

    Return the largest possible sum of the subset S.
-----------------

# 776_Split_BST
# 776. Split BST

Given a Binary Search Tree (BST) with root node root, and a target value
        V, split the tree into two subtrees where one subtree has nodes that are
        all smaller or equal to the target value, while the other subtree has all nodes that are
        greater than the target value.  It's not necessarily the case that the tree
        contains a node with value V.

    Additionally, most of the structure of the original tree should remain.  Formally, for
        any child C with parent P in the original tree, if they are both in the same subtree after
        the split, then node C should still have the parent P.

    You should output the root TreeNode of both subtrees after splitting, in any order.

    Example 1:

    Input: root = [4,2,6,1,3,5,7], V = 2
Output: [[2,1],[4,3,6,null,null,5,7]]
Explanation:
Note that root, output[0], and output[1] are TreeNode objects, not arrays.

The given tree [4,2,6,1,3,5,7] is represented by the following diagram:

          4
        /   \
      2      6
     / \    / \
    1   3  5   7

while the diagrams for the outputs are:

          4
        /   \
      3      6      and    2
            / \           /
           5   7         1

    Note:

    
        The size of the BST will not exceed 50.
        The BST is always valid and each node's value is different.
-----------------

# 1361_Validate_Binary_Tree_Nodes
# 1361. Validate Binary Tree Nodes


-----------------

# 973_K_Closest_Points_to_Origin
# 973. K Closest Points to Origin

We have a list of points on the plane.  Find the K
        closest points to the origin (0, 0).

    (Here, the distance between two points on a plane is the Euclidean distance.)

    You may return the answer in any order.  The answer is guaranteed to be unique
        (except for the order that it is in.)
-----------------

# 1256_Encode_Number
# 1256. Encode Number


-----------------

# 1497_Check_If_Array_Pairs_Are_Divisible_by_k
# 1497. Check If Array Pairs Are Divisible by k


-----------------

# 1344_Angle_Between_Hands_of_a_Clock
# 1344. Angle Between Hands of a Clock


-----------------

# 725_Split_Linked_List_in_Parts
# 725. Split Linked List in Parts

Given a (singly) linked list with head node root, write a function to split the
        linked list into k consecutive linked list "parts".
    
    
        The length of each part should be as equal as possible: no two parts should have a size
        differing by more than 1. This may lead to some parts being null.
    
    
        The parts should be in order of occurrence in the input list, and parts occurring earlier
        should always have a size greater than or equal parts occurring later.
    
    
        Return a List of ListNode's representing the linked list parts that are formed.
    

    Examples
    1->2->3->4, k = 5 // 5 equal parts
    [ [1],
    [2],
    [3],
    [4],
    null ]

    Example 1:
    Input:
root = [1, 2, 3], k = 5
Output: [[1],[2],[3],[],[]]
Explanation:
The input and each element of the output are ListNodes, not arrays.
For example, the input root has root.val = 1, root.next.val = 2, \root.next.next.val = 3, and root.next.next.next = null.
The first element output[0] has output[0].val = 1, output[0].next = null.
The last element output[4] is null, but it's string representation as a ListNode is [].

    

    Example 2:
    Input:
root = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], k = 3
Output: [[1, 2, 3, 4], [5, 6, 7], [8, 9, 10]]
Explanation:
The input has been split into consecutive parts with size difference at most 1, and earlier parts are a larger size than the later parts.

    

    Note:
    The length of root will be in the range [0, 1000].
    Each value of a node in the input will be an integer in the range [0, 999].
    
    k will be an integer in the range [1, 50].
-----------------

# 1352_Product_of_the_Last_K_Numbers
# 1352. Product of the Last K Numbers


-----------------

# 1579_Remove_Max_Number_of_Edges_to_Keep_Graph_Fully_Traversable
# 1579. Remove Max Number of Edges to Keep Graph Fully Traversable


-----------------

# 1118_Number_of_Days_in_a_Month
# 1118. Number of Days in a Month

Given a year Y and a month M, return how many days there are in
        that month.

     

    Example 1:

    Input: Y = 1992, M = 7
Output: 31

    Example 2:

    Input: Y = 2000, M = 2
Output: 29

    Example 3:

    Input: Y = 1900, M = 2
Output: 28

     

    Note:

    
        1583 <= Y <= 2100
        1 <= M <= 12
-----------------

# 1725_Number_Of_Rectangles_That_Can_Form_The_Largest_Square
# 1725. Number Of Rectangles That Can Form The Largest Square


-----------------

# 221_Maximal_Square
# 221. Maximal Square

Given a 2D binary matrix filled with 0's and 1's, find the largest square containing
        only 1's and return its area.

    Example:

    Input:

1 0 1 0 0
1 0 1 1 1
1 1 1 1 1
1 0 0 1 0

Output: 4
-----------------

# 196_Delete_Duplicate_Emails
# 196. Delete Duplicate Emails

Write a SQL query to delete all duplicate email entries in a table named
        Person, keeping only unique emails based on its smallest Id.

    +----+------------------+
| Id | Email            |
+----+------------------+
| 1  | john@example.com |
| 2  | bob@example.com  |
| 3  | john@example.com |
+----+------------------+
Id is the primary key column for this table.

    For example, after running your query, the above Person table should have the
        following rows:

    +----+------------------+
| Id | Email            |
+----+------------------+
| 1  | john@example.com |
| 2  | bob@example.com  |
+----+------------------+

    Note:

    Your output is the whole Person table after executing your sql. Use delete
        statement.
-----------------

# 805_Split_Array_With_Same_Average
# 805. Split Array With Same Average

In a given integer array A, we must move every element of A to either list B or list C. (B
        and C initially start empty.)

    Return true if and only if after such a move, it is possible that the average value of B is
        equal to the average value of C, and B and C are both non-empty.

    Example :
Input:
[1,2,3,4,5,6,7,8]
Output: true
Explanation: We can split the array into [1,4,5,8] and [2,3,6,7], and both of them have the average of 4.5.

    Note:

    
        The length of A will be in the range [1, 30].
        A[i] will be in the range of [0, 10000].
-----------------

# 185_Department_Top_Three_Salaries
# 185. Department Top Three Salaries

The Employee table holds all employees. Every employee has an Id, and there is
        also a column for the department Id.

    +----+-------+--------+--------------+
| Id | Name  | Salary | DepartmentId |
+----+-------+--------+--------------+
| 1  | Joe   | 85000  | 1            |
| 2  | Henry | 80000  | 2            |
| 3  | Sam   | 60000  | 2            |
| 4  | Max   | 90000  | 1            |
| 5  | Janet | 69000  | 1            |
| 6  | Randy | 85000  | 1            |
| 7  | Will  | 70000  | 1            |
+----+-------+--------+--------------+

    The Department table holds all departments of the company.

    +----+----------+
| Id | Name     |
+----+----------+
| 1  | IT       |
| 2  | Sales    |
+----+----------+

    Write a SQL query to find employees who earn the top three salaries in each of the
        department. For the above tables, your SQL query should return the following rows (order of
        rows does not matter).

    +------------+----------+--------+
| Department | Employee | Salary |
+------------+----------+--------+
| IT         | Max      | 90000  |
| IT         | Randy    | 85000  |
| IT         | Joe      | 85000  |
| IT         | Will     | 70000  |
| Sales      | Henry    | 80000  |
| Sales      | Sam      | 60000  |
+------------+----------+--------+

    Explanation:

    In IT department, Max earns the highest salary, both Randy and Joe earn the second highest
        salary, and Will earns the third highest salary. There are only two employees in the Sales
        department, Henry earns the highest salary while Sam earns the second highest salary.
-----------------

# 400_Nth_Digit
# 400. Nth Digit

Find the nth digit of the infinite integer sequence 1, 2, 3, 4, 5, 6, 7, 8,
        9, 10, 11, ... 

    Note:
        n is positive and will fit within the range of a 32-bit signed integer (n <
        231).
    

    Example 1:
    Input:
3

Output:
3

    

    Example 2:
    Input:
11

Output:
0

Explanation:
The 11th digit of the sequence 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ... is a 0, which is part of the number 10.
-----------------

# 1480_Running_Sum_of_1d_Array
# 1480. Running Sum of 1d Array


-----------------

# 213_House_Robber_II
# 213. House Robber II

You are a professional robber planning to rob houses along a street. Each house has a certain
        amount of money stashed. All houses at this place are arranged in a circle.
        That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have
        security system connected and it will automatically contact the police if two
            adjacent houses were broken into on the same night.

    Given a list of non-negative integers representing the amount of money of each house,
        determine the maximum amount of money you can rob tonight without alerting the
            police.

    Example 1:

    Input: [2,3,2]
Output: 3
Explanation: You cannot rob house 1 (money = 2) and then rob house 3 (money = 2),
             because they are adjacent houses.

    Example 2:

    Input: [1,2,3,1]
Output: 4
Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).
             Total amount you can rob = 1 + 3 = 4.
-----------------

# 781_Rabbits_in_Forest
# 781. Rabbits in Forest

In a forest, each rabbit has some color. Some subset of rabbits (possibly all of them) tell
        you how many other rabbits have the same color as them. Those answers are
        placed in an array.

    Return the minimum number of rabbits that could be in the forest.

    Examples:
Input: answers = [1, 1, 2]
Output: 5
Explanation:
The two rabbits that answered "1" could both be the same color, say red.
The rabbit than answered "2" can't be red or the answers would be inconsistent.
Say the rabbit that answered "2" was blue.
Then there should be 2 other blue rabbits in the forest that didn't answer into the array.
The smallest possible number of rabbits in the forest is therefore 5: 3 that answered plus 2 that didn't.

Input: answers = [10, 10, 10]
Output: 11

Input: answers = []
Output: 0

    Note:

    
        answers will have length at most 1000.
        Each answers[i] will be an integer in the range [0, 999].
-----------------

# 1214_Two_Sum_BSTs
# 1214. Two Sum BSTs

Given two binary search trees, return True if and only if there is a node
        in the first tree and a node in the second tree whose values sum up to a given integer target.
    

     
    Example 1:

    
    

    Input: root1 = [2,1,4], root2 = [1,0,3], target = 5
Output: true
Explanation: 2 and 3 sum up to 5.

    Example 2:

    
    

    Input: root1 = [0,-10,10], root2 = [5,1,7,0,2], target = 18
Output: false

     
    Constraints:

    
        Each tree has at most 5000 nodes.
        -10^9 <= target, node.val <= 10^9
-----------------

# 612_Shortest_Distance_in_a_Plane
# 612. Shortest Distance in a Plane

Table point_2d holds the coordinates (x,y) of some unique points (more than two) in
    a plane.
     
    Write a query to find the shortest distance between these points rounded to 2 decimals.

     

    | x  | y  |
|----|----|
| -1 | -1 |
| 0  | 0  |
| -1 | -2 |

     
    The shortest distance is 1.00 from point (-1,-1) to (-1,2). So the output should be:

     

    | shortest |
|----------|
| 1.00     |

     
    Note: The longest distance among all the points are less than 10000.
-----------------

# 585_Investments_in_2016
# 585. Investments in 2016

Write a query to print the sum of all total investment values in 2016 (TIV_2016), to a
        scale of 2 decimal places, for all policy holders who meet the following criteria:

    
        Have the same TIV_2015 value as one or more other policyholders.
        Are not located in the same city as any other policyholder (i.e.: the (latitude,
            longitude) attribute pairs must be unique).
        
    

    Input Format:
        The insurance table is described as follows:

    | Column Name | Type          |
|-------------|---------------|
| PID         | INTEGER(11)   |
| TIV_2015    | NUMERIC(15,2) |
| TIV_2016    | NUMERIC(15,2) |
| LAT         | NUMERIC(5,2)  |
| LON         | NUMERIC(5,2)  |

    where PID is the policyholder's policy ID, TIV_2015 is the total investment
        value in 2015, TIV_2016 is the total investment value in 2016, LAT is the
        latitude of the policy holder's city, and LON is the longitude of the policy
        holder's city.

    Sample Input

    | PID | TIV_2015 | TIV_2016 | LAT | LON |
|-----|----------|----------|-----|-----|
| 1   | 10       | 5        | 10  | 10  |
| 2   | 20       | 20       | 20  | 20  |
| 3   | 10       | 30       | 20  | 20  |
| 4   | 10       | 40       | 40  | 40  |

    Sample Output

    | TIV_2016 |
|----------|
| 45.00    |

    Explanation

    The first record in the table, like the last record, meets both of the two criteria.
The TIV_2015 value '10' is as the same as the third and forth record, and its location unique.

The second record does not meet any of the two criteria. Its TIV_2015 is not like any other policyholders.

And its location is the same with the third record, which makes the third record fail, too.

So, the result is the sum of TIV_2016 of the first and last record, which is 45.
-----------------

# 401_Binary_Watch
# 401. Binary Watch

A binary watch has 4 LEDs on the top which represent the hours (0-11), and the
        6 LEDs on the bottom represent the minutes (0-59).
    Each LED represents a zero or one, with the least significant bit on the right.
    
    For example, the above binary watch reads "3:25".

    Given a non-negative integer n which represents the number of LEDs that are currently
        on, return all possible times the watch could represent.

    Example:
    Input: n = 1Return: ["1:00", "2:00", "4:00", "8:00", "0:01", "0:02", "0:04", "0:08", "0:16", "0:32"]
    

    Note:
    
        The order of output does not matter.
        The hour must not contain a leading zero, for example "01:00" is not valid, it should be
            "1:00".
        
        The minute must be consist of two digits and may contain a leading zero, for example
            "10:2" is not valid, it should be "10:02".
-----------------

# 349_Intersection_of_Two_Arrays
# 349. Intersection of Two Arrays

Given two arrays, write a function to compute their intersection.

    Example 1:

    Input: nums1 = [1,2,2,1], nums2 = [2,2]
Output: [2]
-----------------

# 18_4Sum
# 18. 4Sum

Given an array nums of n integers and an integer target,
        are there elements a, b, c, and d in nums
        such that a + b + c + d = target? Find all
        unique quadruplets in the array which gives the sum of target.

    Note:

    The solution set must not contain duplicate quadruplets.

    Example:

    Given array nums = [1, 0, -1, 0, -2, 2], and target = 0.

A solution set is:
[
  [-1,  0, 0, 1],
  [-2, -1, 1, 2],
  [-2,  0, 0, 2]
]
-----------------

# 1419_Minimum_Number_of_Frogs_Croaking
# 1419. Minimum Number of Frogs Croaking


-----------------

# 1368_Minimum_Cost_to_Make_at_Least_One_Valid_Path_in_a_Grid
# 1368. Minimum Cost to Make at Least One Valid Path in a Grid


-----------------

# 1255_Maximum_Score_Words_Formed_by_Letters
# 1255. Maximum Score Words Formed by Letters

Given a list of words, list of  single letters (might be
        repeating) and score of every character.

    Return the maximum score of any valid set of words formed by using the given
        letters (words[i] cannot be used two or more times).

    It is not necessary to use all characters in letters and each letter can only be
        used once. Score of letters 'a', 'b', 'c',
        ... ,'z' is given by score[0], score[1],
        ... , score[25] respectively.

     
    Example 1:

    Input: words = ["dog","cat","dad","good"], letters = ["a","a","c","d","d","d","g","o","o"], score = [1,0,9,5,0,0,3,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0]
Output: 23
Explanation:
Score  a=1, c=9, d=5, g=3, o=2
Given letters, we can form the words "dad" (5+1+5) and "good" (3+2+2+5) with a score of 23.
Words "dad" and "dog" only get a score of 21.

    Example 2:

    Input: words = ["xxxz","ax","bx","cx"], letters = ["z","a","b","c","x","x","x"], score = [4,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,0,10]
Output: 27
Explanation:
Score  a=4, b=4, c=4, x=5, z=10
Given letters, we can form the words "ax" (4+5), "bx" (4+5) and "cx" (4+5) with a score of 27.
Word "xxxz" only get a score of 25.

    Example 3:

    Input: words = ["leetcode"], letters = ["l","e","t","c","o","d"], score = [0,0,1,1,1,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,0,0,0,0,0,0]
Output: 0
Explanation:
Letter "e" can only be used once.

     
    Constraints:

    
        1 <= words.length <= 14
        1 <= words[i].length <= 15
        1 <= letters.length <= 100
        letters[i].length == 1
        score.length == 26
        0 <= score[i] <= 10
        words[i], letters[i] contains only lower case English
            letters.
-----------------

# 1274_Number_of_Ships_in_a_Rectangle
# 1274. Number of Ships in a Rectangle


-----------------

# 70_Climbing_Stairs
# 70. Climbing Stairs

You are climbing a stair case. It takes n steps to reach to the top.

    Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the
        top?

    Note: Given n will be a positive integer.

    Example 1:

    Input: 2
Output: 2
Explanation: There are two ways to climb to the top.
1. 1 step + 1 step
2. 2 steps

    Example 2:

    Input: 3
Output: 3
Explanation: There are three ways to climb to the top.
1. 1 step + 1 step + 1 step
2. 1 step + 2 steps
3. 2 steps + 1 step
-----------------

# 405_Convert_a_Number_to_Hexadecimal
# 405. Convert a Number to Hexadecimal

Given an integer, write an algorithm to convert it to hexadecimal. For negative integer, two’s
        complement method is used.
    

    Note:
    
        All letters in hexadecimal (a-f) must be in lowercase.
        The hexadecimal string must not contain extra leading 0s. If the number is
            zero, it is represented by a single zero character '0'; otherwise, the
            first character in the hexadecimal string will not be the zero character.
        
        The given number is guaranteed to fit within the range of a 32-bit signed integer.
        You must not use any method provided by the library which converts/formats
            the number to hex directly.
        
    
    

    Example 1:
    Input:
26

Output:
"1a"

    

    Example 2:
    Input:
-1

Output:
"ffffffff"
-----------------

# 1239_Maximum_Length_of_a_Concatenated_String_with_Unique_Characters
# 1239. Maximum Length of a Concatenated String with Unique Characters

Given an array of strings arr. String s is a concatenation of a
        sub-sequence of arr which have unique characters.

    Return the maximum possible length of s.

     
    Example 1:

    Input: arr = ["un","iq","ue"]
Output: 4
Explanation: All possible concatenations are "","un","iq","ue","uniq" and "ique".
Maximum length is 4.

    Example 2:

    Input: arr = ["cha","r","act","ers"]
Output: 6
Explanation: Possible solutions are "chaers" and "acters".

    Example 3:

    Input: arr = ["abcdefghijklmnopqrstuvwxyz"]
Output: 26

     
    Constraints:

    
        1 <= arr.length <= 16
        1 <= arr[i].length <= 26
        arr[i] contains only lower case English letters.
-----------------

# 1752_Check_if_Array_Is_Sorted_and_Rotated
# 1752. Check if Array Is Sorted and Rotated


-----------------

# 1057_Campus_Bikes
# 1057. Campus Bikes

On a campus represented as a 2D grid, there are N workers and M
        bikes, with N <= M. Each worker and bike is a 2D coordinate on this grid.
    

    Our goal is to assign a bike to each worker. Among the available bikes and workers, we choose
        the (worker, bike) pair with the shortest Manhattan distance between each other, and assign
        the bike to that worker. (If there are multiple (worker, bike) pairs with the same shortest
        Manhattan distance, we choose the pair with the smallest worker index; if there are multiple
        ways to do that, we choose the pair with the smallest bike index). We repeat this process
        until there are no available workers.

    The Manhattan distance between two points p1 and p2 is Manhattan(p1,
        p2) = |p1.x - p2.x| + |p1.y - p2.y|.

    Return a vector ans of length N, where ans[i] is the
        index (0-indexed) of the bike that the i-th worker is assigned to.

     

    Example 1:

    

    Input: workers = [[0,0],[2,1]], bikes = [[1,2],[3,3]]
Output: [1,0]
Explanation: 
Worker 1 grabs Bike 0 as they are closest (without ties), and Worker 0 is assigned Bike 1. So the output is [1, 0].

    Example 2:

    

    Input: workers = [[0,0],[1,1],[2,0]], bikes = [[1,0],[2,2],[2,1]]
Output: [0,2,1]
Explanation: 
Worker 0 grabs Bike 0 at first. Worker 1 and Worker 2 share the same distance to Bike 2, thus Worker 1 is assigned to Bike 2, and Worker 2 will take Bike 1. So the output is [0,2,1].

     

    Note:

    
        0 <= workers[i][j], bikes[i][j] < 1000
        All worker and bike locations are distinct.
        1 <= workers.length <= bikes.length <= 1000
-----------------

# 1847_Closest_Room
# 1847. Closest Room


-----------------

# 1760_Minimum_Limit_of_Balls_in_a_Bag
# 1760. Minimum Limit of Balls in a Bag


-----------------

# 966_Vowel_Spellchecker
# 966. Vowel Spellchecker

Given a wordlist, we want to implement a spellchecker that converts a query
        word into a correct word.

    For a given query word, the spell checker handles two categories of spelling
        mistakes:

    
        Capitalization: If the query matches a word in the wordlist
            (case-insensitive), then the query word is returned with the same case
            as the case in the wordlist.

            
                Example: wordlist = ["yellow"], query = "YellOw":
                    correct = "yellow"
                Example: wordlist = ["Yellow"], query = "yellow":
                    correct = "Yellow"
                Example: wordlist = ["yellow"], query = "yellow":
                    correct = "yellow"
            
        
        Vowel Errors: If after replacing the vowels ('a', 'e', 'i',
            'o', 'u') of the query word with any vowel individually, it matches a
            word in the wordlist (case-insensitive), then the query word is
            returned with the same case as the match in the wordlist.
            
                Example: wordlist = ["YellOw"], query = "yollow":
                    correct = "YellOw"
                Example: wordlist = ["YellOw"], query = "yeellow":
                    correct = "" (no match)
                
                Example: wordlist = ["YellOw"], query = "yllw":
                    correct = "" (no match)
                
            
        
    

    In addition, the spell checker operates under the following precedence rules:

    
        When the query exactly matches a word in the wordlist (case-sensitive),
            you should return the same word back.
        
        When the query matches a word up to capitlization, you should return the first such
            match in the wordlist.
        
        When the query matches a word up to vowel errors, you should return the first such match
            in the wordlist.
        
        If the query has no matches in the wordlist, you should return the empty string.
    

    Given some queries, return a list of words answer, where
        answer[i] is the correct word for query = queries[i].
    

     

    Example 1:

    Input: wordlist = ["KiTe","kite","hare","Hare"], queries = ["kite","Kite","KiTe","Hare","HARE","Hear","hear","keti","keet","keto"]
Output: ["kite","KiTe","KiTe","Hare","hare","","","KiTe","","KiTe"]

     

    Note:

    
        1 <= wordlist.length <= 5000
        1 <= queries.length <= 5000
        1 <= wordlist[i].length <= 7
        1 <= queries[i].length <= 7
        All strings in wordlist and queries consist only of english letters.
-----------------

# 741_Cherry_Pickup
# 741. Cherry Pickup

In a N x N grid representing a field of cherries, each cell is one of three
        possible integers.

     

    
        0 means the cell is empty, so you can pass through;
        1 means the cell contains a cherry, that you can pick up and pass through;
        -1 means the cell contains a thorn that blocks your way.
    

     

    Your task is to collect maximum number of cherries possible by following the rules below:

     

    
        Starting at the position (0, 0) and reaching (N-1, N-1) by moving right or down through
            valid path cells (cells with value 0 or 1);
        
        After reaching (N-1, N-1), returning to (0, 0) by moving left or up through valid path
            cells;
        
        When passing through a path cell containing a cherry, you pick it up and the cell
            becomes an empty cell (0);
        
        If there is no valid path between (0, 0) and (N-1, N-1), then no cherries can be
            collected.
        
    

     

     

    Example 1:

    Input: grid =
[[0, 1, -1],
 [1, 0, -1],
 [1, 1,  1]]
Output: 5
Explanation:
The player started at (0, 0) and went down, down, right right to reach (2, 2).
4 cherries were picked up during this single trip, and the matrix becomes [[0,1,-1],[0,0,-1],[0,0,0]].
Then, the player went left, up, up, left to return home, picking up one more cherry.
The total number of cherries picked up is 5, and this is the maximum possible.

     

    Note:

    
        grid is an N by N 2D array, with 1 <= N
            <= 50.
        
        Each grid[i][j] is an integer in the set {-1, 0, 1}.
        It is guaranteed that grid[0][0] and grid[N-1][N-1] are not -1.
-----------------

# 628_Maximum_Product_of_Three_Numbers
# 628. Maximum Product of Three Numbers

Given an integer array, find three numbers whose product is maximum and output the maximum
        product.

    Example 1:

    Input: [1,2,3]
Output: 6

     

    Example 2:

    Input: [1,2,3,4]
Output: 24

     

    Note:

    
        The length of the given array will be in range [3,104] and all elements are
            in the range [-1000, 1000].
        
        Multiplication of any three numbers in the input won't exceed the range of 32-bit
            signed integer.
-----------------

# 1416_Restore_The_Array
# 1416. Restore The Array


-----------------

# 1048_Longest_String_Chain
# 1048. Longest String Chain

Given a list of words, each word consists of English lowercase letters.

    Let's say word1 is a predecessor of word2 if and only if
        we can add exactly one letter anywhere in word1 to make it equal to
        word2.  For example, "abc" is a
        predecessor of "abac".

    A word chain is a sequence of words [word_1, word_2, ..., word_k] with
        k >= 1, where word_1 is a predecessor of
        word_2, word_2 is a predecessor of word_3, and so on.
    

    Return the longest possible length of a word chain with words chosen from the given list of
        words.

     

    Example 1:

    Input: ["a","b","ba","bca","bda","bdca"]
Output: 4
Explanation: one of the longest word chain is "a","ba","bda","bdca".

     

    Note:

    
        1 <= words.length <= 1000
        1 <= words[i].length <= 16
        words[i] only consists of English lowercase letters.
-----------------

# 766_Toeplitz_Matrix
# 766. Toeplitz Matrix

A matrix is Toeplitz if every diagonal from top-left to bottom-right has the same
        element.

    Now given an M x N matrix, return True if and only if the
        matrix is Toeplitz.
         

    Example 1:

    Input:
matrix = [
  [1,2,3,4],
  [5,1,2,3],
  [9,5,1,2]
]
Output: True
Explanation:
In the above grid, the diagonals are:
"[9]", "[5, 5]", "[1, 1, 1]", "[2, 2, 2]", "[3, 3]", "[4]".
In each diagonal all elements are the same, so the answer is True.

    Example 2:

    Input:
matrix = [
  [1,2],
  [2,2]
]
Output: False
Explanation:
The diagonal "[1, 2]" has different elements.

    
        Note:

    
        matrix will be a 2D array of integers.
        matrix will have a number of rows and columns in range [1, 20].
        
        matrix[i][j] will be integers in range [0, 99].
    

    
        Follow up:

    
        What if the matrix is stored on disk, and the memory is limited such that you can only
            load at most one row of the matrix into the memory at once?
        
        What if the matrix is so large that you can only load up a partial row into the memory
            at once?
-----------------

# 504_Base_7
# 504. Base 7

Given an integer, return its base 7 string representation.

    Example 1:
    Input: 100
Output: "202"

    

    Example 2:
    Input: -7
Output: "-10"

    

    Note:
        The input will be in range of [-1e7, 1e7].
-----------------

# 769_Max_Chunks_To_Make_Sorted
# 769. Max Chunks To Make Sorted

Given an array arr that is a permutation of [0, 1, ..., arr.length -
        1], we split the array into some number of "chunks" (partitions), and
        individually sort each chunk.  After concatenating them, the result equals the
        sorted array.

    What is the most number of chunks we could have made?

    Example 1:

    Input: arr = [4,3,2,1,0]
Output: 1
Explanation:
Splitting into two or more chunks will not return the required result.
For example, splitting into [4, 3], [2, 1, 0] will result in [3, 4, 0, 1, 2], which isn't sorted.

    Example 2:

    Input: arr = [1,0,2,3,4]
Output: 4
Explanation:
We can split into two chunks, such as [1, 0], [2, 3, 4].
However, splitting into [1, 0], [2], [3], [4] is the highest number of chunks possible.

    Note:

    
        arr will have length in range [1, 10].
        arr[i] will be a permutation of [0, 1, ..., arr.length - 1].
-----------------

# 946_Validate_Stack_Sequences
# 946. Validate Stack Sequences

Given two sequences pushed and popped with distinct
        values, return true if and only if this could have been the
        result of a sequence of push and pop operations on an initially empty stack.
-----------------

# 1832_Check_if_the_Sentence_Is_Pangram
# 1832. Check if the Sentence Is Pangram


-----------------

# 996_Number_of_Squareful_Arrays
# 996. Number of Squareful Arrays

Given an array A of non-negative integers, the array is squareful if
        for every pair of adjacent elements, their sum is a perfect square.

    Return the number of permutations of A that are squareful.  Two permutations
        A1 and A2 differ if and only if there is some index i
        such that A1[i] != A2[i].

     

    Example 1:

    Input: [1,17,8]
Output: 2
Explanation: 
[1,8,17] and [17,8,1] are the valid permutations.

    Example 2:

    Input: [2,2,2]
Output: 1

     

    Note:

    
        1 <= A.length <= 12
        0 <= A[i] <= 1e9
-----------------

# 1100_Find_K-Length_Substrings_With_No_Repeated_Characters
# 1100. Find K-Length Substrings With No Repeated Characters

Given a string S, return the number of substrings of length K with
        no repeated characters.

     

    Example 1:

    Input: S = "havefunonleetcode", K = 5
Output: 6
Explanation: 
There are 6 substrings they are : 'havef','avefu','vefun','efuno','etcod','tcode'.

    Example 2:

    Input: S = "home", K = 5
Output: 0
Explanation: 
Notice K can be larger than the length of S. In this case is not possible to find any substring.

     

    Note:

    
        1 <= S.length <= 10^4
        All characters of S are lowercase English letters.
        1 <= K <= 10^4
-----------------

# 618_Students_Report_By_Geography
# 618. Students Report By Geography

A U.S graduate school has students from Asia, Europe and America. The students' location
    information are stored in table student as below.
     

    | name   | continent |
|--------|-----------|
| Jack   | America   |
| Pascal | Europe    |
| Xi     | Asia      |
| Jane   | America   |

     
     Pivot the continent column in this
    table so that each name is sorted alphabetically and displayed underneath its corresponding
    continent. The output headers should be America, Asia and Europe respectively. It is guaranteed
    that the student number from America is no less than either Asia or Europe.

     
    For the sample input, the output is:

     

    | America | Asia | Europe |
|---------|------|--------|
| Jack    | Xi   | Pascal |
| Jane    |      |        |

     
    Follow-up: If it is unknown which continent has the most students, can you write a query
    to generate the student report?
-----------------

# 486_Predict_the_Winner
# 486. Predict the Winner

Given an array of scores that are non-negative integers. Player 1 picks one of the numbers
        from either end of the array followed by the player 2 and then player 1 and so on. Each time
        a player picks a number, that number will not be available for the next player. This
        continues until all the scores have been chosen. The player with the maximum score
        wins. 

    Given an array of scores, predict whether player 1 is the winner. You can assume each player
        plays to maximize his score. 

    Example 1:
    Input: [1, 5, 2]
Output: False
Explanation: Initially, player 1 can choose between 1 and 2. If he chooses 2 (or 1), then player 2 can choose from 1 (or 2) and 5. If player 2 chooses 5, then player 1 will be left with 1 (or 2). So, final score of player 1 is 1 + 2 = 3, and player 2 is 5. Hence, player 1 will never be the winner and you need to return False.

    

    Example 2:
    Input: [1, 5, 233, 7]
Output: True
Explanation: Player 1 first chooses 1. Then player 2 have to choose between 5 and 7. No matter which number player 2 choose, player 1 can choose 233.Finally, player 1 has more score (234) than player 2 (12), so you need to return True representing player1 can win.

    

    Note:
    
        1 <= length of the array <= 20.
        Any scores in the given array are non-negative integers and will not exceed
            10,000,000.
        
        If the scores of both players are equal, then player 1 is still the winner.
-----------------

# 1475_Final_Prices_With_a_Special_Discount_in_a_Shop
# 1475. Final Prices With a Special Discount in a Shop


-----------------

# 1834_Single-Threaded_CPU
# 1834. Single-Threaded CPU


-----------------

# 1030_Matrix_Cells_in_Distance_Order
# 1030. Matrix Cells in Distance Order

We are given a matrix with R rows and C columns has cells with
        integer coordinates (r, c), where 0 <= r < R and 0
            <= c < C.

    Additionally, we are given a cell in that matrix with coordinates (r0, c0).
    

    Return the coordinates of all cells in the matrix, sorted by their distance from (r0,
        c0) from smallest distance to largest distance.  Here, the distance
        between two cells (r1, c1) and (r2, c2) is the Manhattan distance, |r1
            - r2| + |c1 - c2|.  (You may return the answer in any order that satisfies
        this condition.)
-----------------

# 9_Palindrome_Number
# 9. Palindrome Number

Determine whether an integer is a palindrome. An integer is a palindrome when
        it reads the same backward as forward.

    Example 1:

    Input: 121
Output: true

    Example 2:

    Input: -121
Output: false
Explanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.

    Example 3:

    Input: 10
Output: false
Explanation: Reads 01 from right to left. Therefore it is not a palindrome.

    Follow up:

    Coud you solve it without converting the integer to a string?
-----------------

# 93_Restore_IP_Addresses
# 93. Restore IP Addresses

Given a string containing only digits, restore it by returning all possible valid IP address
        combinations.

    Example:

    Input: "25525511135"
Output: ["255.255.11.135", "255.255.111.35"]
-----------------

# 730_Count_Different_Palindromic_Subsequences
# 730. Count Different Palindromic Subsequences

Given a string S, find the number of different non-empty palindromic subsequences in S, and
        return that number modulo 10^9 + 7.
    
    
        A subsequence of a string S is obtained by deleting 0 or more characters from S.
    
    
        A sequence is palindromic if it is equal to the sequence reversed.
    
    
        Two sequences A_1, A_2, ... and B_1, B_2, ... are different if
        there is some i for which A_i != B_i.
    

    Example 1:
    Input:
S = 'bccb'
Output: 6
Explanation:
The 6 different non-empty palindromic subsequences are 'b', 'c', 'bb', 'cc', 'bcb', 'bccb'.
Note that 'bcb' is counted only once, even though it occurs twice.

    

    Example 2:
    Input:
S = 'abcdabcdabcdabcdabcdabcdabcdabcddcbadcbadcbadcbadcbadcbadcbadcba'
Output: 104860361
Explanation:
There are 3104860382 different non-empty palindromic subsequences, which is 104860361 modulo 10^9 + 7.

    

    Note:
    The length of S will be in the range [1, 1000].
    Each character S[i] will be in the set {'a', 'b', 'c', 'd'}.
-----------------

# 938_Range_Sum_of_BST
# 938. Range Sum of BST

Given the root node of a binary search tree, return the sum of values of all
        nodes with value between L and R (inclusive).

    The binary search tree is guaranteed to have unique values.
-----------------

# 381_Insert_Delete_GetRandom_O(1)_-_Duplicates_allowed
# 381. Insert Delete GetRandom O(1) - Duplicates allowed

Design a data structure that supports all following operations in average O(1)
        time.
    Note: Duplicate elements are allowed.
    
    
        insert(val): Inserts an item val to the collection.
        remove(val): Removes an item val from the collection if present.
        getRandom: Returns a random element from current collection of elements.
            The probability of each element being returned is linearly related to the number
            of same value the collection contains.
        
    
    

    Example:
    // Init an empty collection.
RandomizedCollection collection = new RandomizedCollection();

// Inserts 1 to the collection. Returns true as the collection did not contain 1.
collection.insert(1);

// Inserts another 1 to the collection. Returns false as the collection contained 1. Collection now contains [1,1].
collection.insert(1);

// Inserts 2 to the collection, returns true. Collection now contains [1,1,2].
collection.insert(2);

// getRandom should return 1 with the probability 2/3, and returns 2 with the probability 1/3.
collection.getRandom();

// Removes 1 from the collection, returns true. Collection now contains [1,2].
collection.remove(1);

// getRandom should return 1 and 2 both equally likely.
collection.getRandom();
-----------------

# 630_Course_Schedule_III
# 630. Course Schedule III

There are n different online courses numbered from 1 to
        n. Each course has some duration(course length) t and closed on
        dth day. A course should be taken continuously for
        t days and must be finished before or on the dth day.
        You will start at the 1st day.

    Given n online courses represented by pairs (t,d), your task is to
        find the maximal number of courses that can be taken.

    Example:

    Input: [[100, 200], [200, 1300], [1000, 1250], [2000, 3200]]
Output: 3
Explanation:
There're totally 4 courses, but you can take 3 courses at most:
First, take the 1st course, it costs 100 days so you will finish it on the 100th day, and ready to take the next course on the 101st day.
Second, take the 3rd course, it costs 1000 days so you will finish it on the 1100th day, and ready to take the next course on the 1101st day.
Third, take the 2nd course, it costs 200 days so you will finish it on the 1300th day.
The 4th course cannot be taken now, since you will finish it on the 3300th day, which exceeds the closed date.

     

    Note:

    
        The integer 1 <= d, t, n <= 10,000.
        You can't take two courses simultaneously.
-----------------

# 1156_Swap_For_Longest_Repeated_Character_Substring
# 1156. Swap For Longest Repeated Character Substring

Given a string text, we are allowed to swap two of the characters in the string.
        Find the length of the longest substring with repeated characters.

     
    Example 1:

    Input: text = "ababa"
Output: 3
Explanation: We can swap the first 'b' with the last 'a', or the last 'b' with the first 'a'. Then, the longest repeated character substring is "aaa", which its length is 3.

    Example 2:

    Input: text = "aaabaaa"
Output: 6
Explanation: Swap 'b' with the last 'a' (or the first 'a'), and we get longest repeated character substring "aaaaaa", which its length is 6.

    Example 3:

    Input: text = "aaabbaaa"
Output: 4

    Example 4:

    Input: text = "aaaaa"
Output: 5
Explanation: No need to swap, longest repeated character substring is "aaaaa", length is 5.

    Example 5:

    Input: text = "abcdef"
Output: 1

     
    Constraints:

    
        1 <= text.length <= 20000
        text consist of lowercase English characters only.
-----------------

# 686_Repeated_String_Match
# 686. Repeated String Match

Given two strings A and B, find the minimum number of times A has to be repeated such that B
        is a substring of it. If no such solution, return -1.

    For example, with A = "abcd" and B = "cdabcdab".

    Return 3, because by repeating A three times (“abcdabcdabcd”), B is a substring
        of it; and B is not a substring of A repeated two times ("abcdabcd").

    Note:
        The length of A and B will be between 1 and 10000.
-----------------

# 161_One_Edit_Distance
# 161. One Edit Distance

Given two strings s and t, determine if they are both one
        edit distance apart.

    Note: 

    There are 3 possiblities to satisify one edit distance apart:

    
        Insert a character into s to
            get t
        Delete a character from s to
            get t
        Replace a character of s to
            get t
    

    Example 1:

    Input: s = "ab", t = "acb"
Output: true
Explanation: We can insert 'c' into s to get t.

    Example 2:

    Input: s = "cab", t = "ad"
Output: false
Explanation: We cannot get t from s by only one step.

    Example 3:

    Input: s = "1203", t = "1213"
Output: true
Explanation: We can replace '0' with '1' to get t.
-----------------

# 460_LFU_Cache
# 460. LFU Cache

Design and implement a data structure for Least
        Frequently Used (LFU) cache. It should support the following operations:
        get and put.

    get(key) - Get the value (will always be positive) of the key if the key exists
        in the cache, otherwise return -1.
        put(key, value) - Set or insert the value if the key is not already present.
        When the cache reaches its capacity, it should invalidate the least frequently used item
        before inserting a new item. For the purpose of this problem, when there is a tie (i.e., two
        or more keys that have the same frequency), the least recently used key would be
        evicted.

    Note that the number of times an item is used is the number of calls to
        the get and put functions for that item since
        it was inserted. This number is set to zero when the item is removed.

     

    Follow up:
        Could you do both operations in O(1) time complexity?

     

    Example:

    LFUCache cache = new LFUCache( 2 /* capacity */ );

cache.put(1, 1);
cache.put(2, 2);
cache.get(1);       // returns 1
cache.put(3, 3);    // evicts key 2
cache.get(2);       // returns -1 (not found)
cache.get(3);       // returns 3.
cache.put(4, 4);    // evicts key 1.
cache.get(1);       // returns -1 (not found)
cache.get(3);       // returns 3
cache.get(4);       // returns 4
-----------------

# 1323_1323._Maximum_69_Number
# 1323. 1323. Maximum 69 Number


-----------------

# 1103_Distribute_Candies_to_People
# 1103. Distribute Candies to People

We distribute some number of candies, to a row of n = num_people people
        in the following way:

    We then give 1 candy to the first person, 2 candies to the second person, and so on until we
        give n candies to the last person.

    Then, we go back to the start of the row, giving n + 1 candies to the first
        person, n + 2 candies to the second person, and so on until we give 2
            * n candies to the last person.

    This process repeats (with us giving one more candy each time, and moving to the start of the
        row after we reach the end) until we run out of candies.  The last person will receive
        all of our remaining candies (not necessarily one more than the previous gift).

    Return an array (of length num_people and sum candies) that
        represents the final distribution of candies.

     
    Example 1:

    Input: candies = 7, num_people = 4
Output: [1,2,3,1]
Explanation:
On the first turn, ans[0] += 1, and the array is [1,0,0,0].
On the second turn, ans[1] += 2, and the array is [1,2,0,0].
On the third turn, ans[2] += 3, and the array is [1,2,3,0].
On the fourth turn, ans[3] += 1 (because there is only one candy left), and the final array is [1,2,3,1].

    Example 2:

    Input: candies = 10, num_people = 3
Output: [5,2,3]
Explanation: 
On the first turn, ans[0] += 1, and the array is [1,0,0].
On the second turn, ans[1] += 2, and the array is [1,2,0].
On the third turn, ans[2] += 3, and the array is [1,2,3].
On the fourth turn, ans[0] += 4, and the final array is [5,2,3].

     
    Constraints:

    
        1 <= candies <= 10^9
        1 <= num_people <= 1000
-----------------

# 947_Most_Stones_Removed_with_Same_Row_or_Column
# 947. Most Stones Removed with Same Row or Column

On a 2D plane, we place stones at some integer coordinate points.  Each coordinate point
        may have at most one stone.

    Now, a move consists of removing a stone that shares a column or row with
        another stone on the grid.

    What is the largest possible number of moves we can make?
-----------------

# 1534_Count_Good_Triplets
# 1534. Count Good Triplets


-----------------

# 95_Unique_Binary_Search_Trees_II
# 95. Unique Binary Search Trees II

Given an integer n, generate all structurally unique BST's
        (binary search trees) that store values 1 ... n.

    Example:

    Input: 3
Output:
[
  [1,null,3,2],
  [3,2,null,1],
  [3,1,null,null,2],
  [2,1,3],
  [1,null,2,null,3]
]
Explanation:
The above output corresponds to the 5 unique BST's shown below:

   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3
-----------------

# 1479_Sales_by_Day_of_the_Week
# 1479. Sales by Day of the Week


-----------------

# 215_Kth_Largest_Element_in_an_Array
# 215. Kth Largest Element in an Array

Find the kth largest element in an unsorted array. Note that it is the kth
        largest element in the sorted order, not the kth distinct element.

    Example 1:

    Input: [3,2,1,5,6,4] and k = 2
Output: 5

    Example 2:

    Input: [3,2,3,1,2,4,5,5,6] and k = 4
Output: 4

    Note: 
        You may assume k is always valid, 1 ≤ k ≤ array's length.
-----------------

# 1044_Longest_Duplicate_Substring
# 1044. Longest Duplicate Substring

Given a string S, consider all duplicated substrings: (contiguous)
        substrings of S that occur 2 or more times.  (The occurrences may overlap.)

    Return any duplicated substring that has the longest possible length. 
        (If S does not have a duplicated substring, the answer is
        "".)

     

    Example 1:

    Input: "banana"
Output: "ana"

    Example 2:

    Input: "abcd"
Output: ""

     

    Note:

    
        2 <= S.length <= 10^5
        S consists of lowercase English letters.
-----------------

# 386_Lexicographical_Numbers
# 386. Lexicographical Numbers

Given an integer n, return 1 - n in lexicographical order.

    For example, given 13, return: [1,10,11,12,13,2,3,4,5,6,7,8,9].

    Please optimize your algorithm to use less time and space. The input size may be as large as
        5,000,000.
-----------------

# 1188_Design_Bounded_Blocking_Queue
# 1188. Design Bounded Blocking Queue

Implement a thread safe bounded blocking queue that has the
        following methods:

    
        BoundedBlockingQueue(int capacity) The constructor initializes the queue
            with a maximum capacity.
        
        void enqueue(int element) Adds an element to the front of the
            queue. If the queue is full, the calling thread is blocked until the queue is no longer
            full.
        
        int dequeue() Returns the element at the rear of the queue and removes it.
            If the queue is empty, the calling thread is blocked until the queue is no longer empty.
        
        int size() Returns the number of elements currently in the queue.
    

    Your implementation will be tested using multiple threads at the same time. Each thread will
        either be a producer thread that only makes calls to the enqueue method
        or a consumer thread that only makes calls to the dequeue method. The size method
        will be called after every test case.

    Please do not use built-in implementations of bounded blocking queue as this will not be
        accepted in an interview.

     

    Example 1:

    Input:
1
1
["BoundedBlockingQueue","enqueue","dequeue","dequeue","enqueue","enqueue","enqueue","enqueue","dequeue"]
[[2],[1],[],[],[0],[2],[3],[4],[]]

Output:
[1,0,2,2]

Explanation:
Number of producer threads = 1
Number of consumer threads = 1

BoundedBlockingQueue queue = new BoundedBlockingQueue(2);   // initialize the queue with capacity = 2.

queue.enqueue(1);   // The producer thread enqueues 1 to the queue.
queue.dequeue();    // The consumer thread calls dequeue and returns 1 from the queue.
queue.dequeue();    // Since the queue is empty, the consumer thread is blocked.
queue.enqueue(0);   // The producer thread enqueues 0 to the queue. The consumer thread is unblocked and returns 0 from the queue.
queue.enqueue(2);   // The producer thread enqueues 2 to the queue.
queue.enqueue(3);   // The producer thread enqueues 3 to the queue.
queue.enqueue(4);   // The producer thread is blocked because the queue's capacity (2) is reached.
queue.dequeue();    // The consumer thread returns 2 from the queue. The producer thread is unblocked and enqueues 4 to the queue.
queue.size();       // 2 elements remaining in the queue. size() is always called at the end of each test case.

     

    Example 2:

    Input:
3
4
["BoundedBlockingQueue","enqueue","enqueue","enqueue","dequeue","dequeue","dequeue","enqueue"]
[[3],[1],[0],[2],[],[],[],[3]]

Output:
[1,0,2,1]

Explanation:
Number of producer threads = 3
Number of consumer threads = 4

BoundedBlockingQueue queue = new BoundedBlockingQueue(3);   // initialize the queue with capacity = 3.

queue.enqueue(1);   // Producer thread P1 enqueues 1 to the queue.
queue.enqueue(0);   // Producer thread P2 enqueues 0 to the queue.
queue.enqueue(2);   // Producer thread P3 enqueues 2 to the queue.
queue.dequeue();    // Consumer thread C1 calls dequeue.
queue.dequeue();    // Consumer thread C2 calls dequeue.
queue.dequeue();    // Consumer thread C3 calls dequeue.
queue.enqueue(3);   // One of the producer threads enqueues 3 to the queue.
queue.size();       // 1 element remaining in the queue.

Since the number of threads for producer/consumer is greater than 1, we do not know how the threads will be scheduled in the operating system, even though the input seems to imply the ordering. Therefore, any of the output [1,0,2] or [1,2,0] or [0,1,2] or [0,2,1] or [2,0,1] or [2,1,0] will be accepted.
-----------------

# 1192_Critical_Connections_in_a_Network
# 1192. Critical Connections in a Network

There are n servers numbered from 0 to n-1
        connected by undirected server-to-server connections forming a network
        where connections[i] = [a, b] represents a connection between servers
        a and b. Any server can reach any other server directly or
        indirectly through the network.

    A critical connection is a connection that, if removed, will make some server
        unable to reach some other server.

    Return all critical connections in the network in any order.

     
    Example 1:

    

    Input: n = 4, connections = [[0,1],[1,2],[2,0],[1,3]]
Output: [[1,3]]
Explanation: [[3,1]] is also accepted.

     
    Constraints:

    
        1 <= n <= 10^5
        n-1 <= connections.length <= 10^5
        connections[i][0] != connections[i][1]
        There are no repeated connections.
-----------------

# 1568_Minimum_Number_of_Days_to_Disconnect_Island
# 1568. Minimum Number of Days to Disconnect Island


-----------------

# 1806_Minimum_Number_of_Operations_to_Reinitialize_a_Permutation
# 1806. Minimum Number of Operations to Reinitialize a Permutation


-----------------

# 1003_Check_If_Word_Is_Valid_After_Substitutions
# 1003. Check If Word Is Valid After Substitutions

We are given that the string "abc" is valid.

    From any valid string V, we may split V into two pieces X
        and Y such that X + Y (X concatenated with
        Y) is equal to V.  (X or Y may be
        empty.)  Then, X + "abc" + Y is also valid.

    If for example S = "abc", then examples of valid strings are: "abc",
        "aabcbc", "abcabc", "abcabcababcc".  Examples of
        invalid strings are: "abccba", "ab",
        "cababc", "bac".

    Return true if and only if the given string S is valid.
    

     

    Example 1:

    Input: "aabcbc"
Output: true
Explanation: 
We start with the valid string "abc".
Then we can insert another "abc" between "a" and "bc", resulting in "a" + "abc" + "bc" which is "aabcbc".
-----------------

# 644_Maximum_Average_Subarray_II
# 644. Maximum Average Subarray II

Given an array consisting of n integers, find the contiguous subarray whose length
        is greater than or equal to k that has the maximum average value. And you
        need to output the maximum average value.
    

    Example 1:
    Input: [1,12,-5,-6,50,3], k = 4
Output: 12.75
Explanation:
when length is 5, maximum average value is 10.8,
when length is 6, maximum average value is 9.16667.
Thus return 12.75.

    

    Note:
    
        1 <= k <= n <= 10,000.
        Elements of the given array will be in range [-10,000, 10,000].
        The answer with the calculation error less than 10-5 will be accepted.
-----------------

# 1592_Rearrange_Spaces_Between_Words
# 1592. Rearrange Spaces Between Words


-----------------

# 446_Arithmetic_Slices_II_-_Subsequence
# 446. Arithmetic Slices II - Subsequence

A sequence of numbers is called arithmetic if it consists of at least three elements and if
        the difference between any two consecutive elements is the same.

    For example, these are arithmetic sequences:

    1, 3, 5, 7, 9
7, 7, 7, 7
3, -1, -5, -9

    The following sequence is not arithmetic.

    1, 1, 2, 5, 7
     

    A zero-indexed array A consisting of N numbers is given. A subsequence slice of that
        array is any sequence of integers (P0, P1, ..., Pk) such
        that 0 ≤ P0 < P1 < ... < Pk < N.

    A subsequence slice (P0, P1, ..., Pk) of array A is
        called arithmetic if the sequence A[P0], A[P1], ..., A[Pk-1],
        A[Pk] is arithmetic. In particular, this means that k ≥ 2.

    The function should return the number of arithmetic subsequence slices in the array A.

    The input contains N integers. Every integer is in the range of -231 and
        231-1 and 0 ≤ N ≤ 1000. The output is guaranteed to be less than
        231-1.
     

    Example:

    Input: [2, 4, 6, 8, 10]

Output: 7

Explanation:
All arithmetic subsequence slices are:
[2,4,6]
[4,6,8]
[6,8,10]
[2,4,6,8]
[4,6,8,10]
[2,4,6,8,10]
[2,6,10]
-----------------

# 1729_Find_Followers_Count
# 1729. Find Followers Count


-----------------

# 847_Shortest_Path_Visiting_All_Nodes
# 847. Shortest Path Visiting All Nodes

An undirected, connected graph of N nodes (labeled 0, 1, 2, ..., N-1) is
        given as graph.

    graph.length = N, and j != i is in the list graph[i] exactly
        once, if and only if nodes i and j are connected.

    Return the length of the shortest path that visits every node. You may start and stop at any
        node, you may revisit nodes multiple times, and you may reuse edges.

     

    
    

    Example 1:

    Input: [[1,2,3],[0],[0],[0]]
Output: 4
Explanation: One possible path is [1,0,2,0,3]

    Example 2:

    Input: [[1],[0,2,4],[1,3,4],[2],[1,2]]
Output: 4
Explanation: One possible path is [0,1,4,2,3]

     

    Note:

    
        1 <= graph.length <= 12
        0 <= graph[i].length < graph.length
-----------------

# 1811_Find_Interview_Candidates
# 1811. Find Interview Candidates


-----------------

# 1075_Project_Employees_I
# 1075. Project Employees I

Table: Project

    +-------------+---------+
| Column Name | Type    |
+-------------+---------+
| project_id  | int     |
| employee_id | int     |
+-------------+---------+
(project_id, employee_id) is the primary key of this table.
employee_id is a foreign key to Employee table.

    Table: Employee

    +------------------+---------+
| Column Name      | Type    |
+------------------+---------+
| employee_id      | int     |
| name             | varchar |
| experience_years | int     |
+------------------+---------+
employee_id is the primary key of this table.

     

    Write an SQL query that reports the average experience years of all the
        employees for each project, rounded to 2 digits.

    The query result format is in the following example:

    Project table:
+-------------+-------------+
| project_id  | employee_id |
+-------------+-------------+
| 1           | 1           |
| 1           | 2           |
| 1           | 3           |
| 2           | 1           |
| 2           | 4           |
+-------------+-------------+

Employee table:
+-------------+--------+------------------+
| employee_id | name   | experience_years |
+-------------+--------+------------------+
| 1           | Khaled | 3                |
| 2           | Ali    | 2                |
| 3           | John   | 1                |
| 4           | Doe    | 2                |
+-------------+--------+------------------+

Result table:
+-------------+---------------+
| project_id  | average_years |
+-------------+---------------+
| 1           | 2.00          |
| 2           | 2.50          |
+-------------+---------------+
The average experience years for the first project is (3 + 2 + 1) / 3 = 2.00 and for the second project is (3 + 2) / 2 = 2.50
-----------------

# 1761_Minimum_Degree_of_a_Connected_Trio_in_a_Graph
# 1761. Minimum Degree of a Connected Trio in a Graph


-----------------

# 1296_Divide_Array_in_Sets_of_K_Consecutive_Numbers
# 1296. Divide Array in Sets of K Consecutive Numbers


-----------------

# 1366_Rank_Teams_by_Votes
# 1366. Rank Teams by Votes


-----------------

# 484_Find_Permutation
# 484. Find Permutation

By now, you are given a secret signature consisting of character 'D' and 'I'. 'D'
        represents a decreasing relationship between two numbers, 'I' represents an increasing
        relationship between two numbers. And our secret signature was constructed by a
        special integer array, which contains uniquely all the different number from 1 to n (n is
        the length of the secret signature plus 1). For example, the secret signature "DI" can be
        constructed by array [2,1,3] or [3,1,2], but won't be constructed by array [3,2,4] or
        [2,1,3,4], which are both illegal constructing special string that can't represent the "DI"
        secret signature.
    

    
        On the other hand, now your job is to find the lexicographically smallest permutation of [1,
        2, ... n] could refer to the given secret signature in the input.
    

    Example 1:
    Input: "I"
Output: [1,2]
Explanation: [1,2] is the only legal initial spectial string can construct secret signature "I", where the number 1 and 2 construct an increasing relationship.

    

    Example 2:
    Input: "DI"
Output: [2,1,3]
Explanation: Both [2,1,3] and [3,1,2] can construct the secret signature "DI", but since we want to find the one with the smallest lexicographical permutation, you need to output [2,1,3]

    

    Note:
    The input string will only contain the character 'D' and 'I'.
    The length of input string is a positive integer and will not exceed 10,000
-----------------

# 593_Valid_Square
# 593. Valid Square

Given the coordinates of four points in 2D space, return whether the four points could
        construct a square.

    The coordinate (x,y) of a point is represented by an integer array with two integers.

    Example:

    Input: p1 = [0,0], p2 = [1,1], p3 = [1,0], p4 = [0,1]
Output: True

     

    Note:

    
        All the input integers are in the range [-10000, 10000].
        A valid square has four equal sides with positive length and four equal angles
            (90-degree angles).
        
        Input points have no order.
-----------------

# 539_Minimum_Time_Difference
# 539. Minimum Time Difference

Given a list of 24-hour clock time points in "Hour:Minutes" format, find the minimum
    minutes difference between any two time points in the list.

    Example 1:
    Input: ["23:59","00:00"]
Output: 1

    

    Note:
    
        The number of time points in the given list is at least 2 and won't exceed 20000.
        The input time is legal and ranges from 00:00 to 23:59.
-----------------

# 1607_Sellers_With_No_Sales
# 1607. Sellers With No Sales


-----------------

# 816_Ambiguous_Coordinates
# 816. Ambiguous Coordinates

We had some 2-dimensional coordinates, like "(1, 3)" or "(2,
        0.5)".  Then, we removed all commas, decimal points, and spaces, and
        ended up with the string S.  Return a list of strings representing all
        possibilities for what our original coordinates could have been.

    Our original representation never had extraneous zeroes, so we never started with numbers
        like "00", "0.0", "0.00", "1.0", "001",
        "00.01", or any other number that can be represented with less digits. 
        Also, a decimal point within a number never occurs without at least one digit occuring
        before it, so we never started with numbers like ".1".

    The final answer list can be returned in any order.  Also note that all coordinates in
        the final answer have exactly one space between them (occurring after the comma.)

    Example 1:
Input: "(123)"
Output: ["(1, 23)", "(12, 3)", "(1.2, 3)", "(1, 2.3)"]

    Example 2:
Input: "(00011)"
Output:  ["(0.001, 1)", "(0, 0.011)"]
Explanation:
0.0, 00, 0001 or 00.01 are not allowed.

    Example 3:
Input: "(0123)"
Output: ["(0, 123)", "(0, 12.3)", "(0, 1.23)", "(0.1, 23)", "(0.1, 2.3)", "(0.12, 3)"]

    Example 4:
Input: "(100)"
Output: [(10, 0)]
Explanation:
1.0 is not allowed.

     

    Note: 

    
        4 <= S.length <= 12.
        S[0] = "(", S[S.length - 1] = ")", and the
            other elements in S are digits.
-----------------

# 43_Multiply_Strings
# 43. Multiply Strings

Given two non-negative integers num1 and num2 represented as
        strings, return the product of num1 and num2, also represented as
        a string.

    Example 1:

    Input: num1 = "2", num2 = "3"
Output: "6"

    Example 2:

    Input: num1 = "123", num2 = "456"
Output: "56088"

    Note:

    
        The length of both num1 and num2 is < 110.
        Both num1 and num2 contain only digits 0-9.
        
        Both num1 and num2 do not contain any leading zero,
            except the number 0 itself.
        
        You must not use any built-in BigInteger library or convert the
            inputs to integer directly.
-----------------

# 554_Brick_Wall
# 554. Brick Wall

There is a brick wall in front of you. The wall is rectangular and has several rows of
        bricks. The bricks have the same height but different width. You want to draw a vertical
        line from the top to the bottom and cross the least bricks.

    The brick wall is represented by a list of rows. Each row is a list of integers representing
        the width of each brick in this row from left to right.

    If your line go through the edge of a brick, then the brick is not considered as crossed. You
        need to find out how to draw the line to cross the least bricks and return the number of
        crossed bricks.

    You cannot draw a line just along one of the two vertical edges of the wall, in which case
        the line will obviously cross no bricks. 

     

    Example:

    Input: [[1,2,2,1],
        [3,1,2],
        [1,3,2],
        [2,4],
        [3,1,2],
        [1,3,1,1]]

Output: 2

Explanation:

     

    Note:

    
        The width sum of bricks in different rows are the same and won't exceed INT_MAX.
        
        The number of bricks in each row is in range [1,10,000]. The height of wall is in range
            [1,10,000]. Total number of bricks of the wall won't exceed 20,000.
-----------------

# 1114_Print_in_Order
# 1114. Print in Order

Suppose we have a class:

    public class Foo {
  public void first() { print("first"); }
  public void second() { print("second"); }
  public void third() { print("third"); }
}

    The same instance of Foo will be passed to three different threads. Thread A
        will call first(), thread B will call second(), and thread C will
        call third(). Design a mechanism and modify the program to ensure that second() is
        executed after first(), and third() is executed after second().
    

     

    Example 1:

    Input: [1,2,3]
Output: "firstsecondthird"
Explanation: There are three threads being fired asynchronously. The input [1,2,3] means thread A calls first(), thread B calls second(), and thread C calls third(). "firstsecondthird" is the correct output.

    Example 2:

    Input: [1,3,2]
Output: "firstsecondthird"
Explanation: The input [1,3,2] means thread A calls first(), thread B calls third(), and thread C calls second(). "firstsecondthird" is the correct output.

     

    Note:

    We do not know how the threads will be scheduled in the operating system, even though the
        numbers in the input seems to imply the ordering. The input format you see is mainly to
        ensure our tests' comprehensiveness.
-----------------

# 493_Reverse_Pairs
# 493. Reverse Pairs

Given an array nums, we call (i, j) an important reverse
        pair if i < j and nums[i] > 2*nums[j].

    You need to return the number of important reverse pairs in the given array.

    Example1:
    Input: [1,3,2,3,1]
Output: 2

    

    Example2:
    Input: [2,4,3,5,1]
Output: 3

    

    Note:
    
        The length of the given array will not exceed 50,000.
        All the numbers in the input array are in the range of 32-bit integer.
-----------------

# 1275_Find_Winner_on_a_Tic_Tac_Toe_Game
# 1275. Find Winner on a Tic Tac Toe Game


-----------------

# 1110_Delete_Nodes_And_Return_Forest
# 1110. Delete Nodes And Return Forest

Given the root of a binary tree, each node in the tree has a distinct
        value.

    After deleting all nodes with a value in to_delete, we are left with a
        forest (a disjoint union of trees).

    Return the roots of the trees in the remaining forest.  You may return the result in any
        order.

     
    Example 1:

    

    Input: root = [1,2,3,4,5,6,7], to_delete = [3,5]
Output: [[1,2,null,4],[6],[7]]

     
    Constraints:

    
        The number of nodes in the given tree is at most 1000.
        Each node has a distinct value between 1 and 1000.
        to_delete.length <= 1000
        to_delete contains distinct values between 1 and
            1000.
-----------------

# 1776_Car_Fleet_II
# 1776. Car Fleet II


-----------------

# 97_Interleaving_String
# 97. Interleaving String

Given s1, s2, s3, find whether s3 is formed by the
        interleaving of s1 and s2.

    Example 1:

    Input: s1 = "aabcc", s2 = "dbbca", s3 = "aadbbcbcac"
Output: true

    Example 2:

    Input: s1 = "aabcc", s2 = "dbbca", s3 = "aadbbbaccc"
Output: false
-----------------

# 124_Binary_Tree_Maximum_Path_Sum
# 124. Binary Tree Maximum Path Sum

Given a non-empty binary tree, find the maximum path sum.

    For this problem, a path is defined as any sequence of nodes from some starting node to any
        node in the tree along the parent-child connections. The path must contain at least
            one node and does not need to go through the root.

    Example 1:

    Input: [1,2,3]

       1
      / \
     2   3

Output: 6

    Example 2:

    Input: [-10,9,20,null,null,15,7]

   -10
   / \
  9  20
    /  \
   15   7

Output: 42
-----------------

# 312_Burst_Balloons
# 312. Burst Balloons

Given n balloons, indexed from 0 to n-1. Each balloon
        is painted with a number on it represented by array nums. You are asked to
        burst all the balloons. If the you burst balloon i you will get nums[left]
            * nums[i] * nums[right] coins. Here left and right are
        adjacent indices of i. After the burst, the left and
        right then becomes adjacent.

    Find the maximum coins you can collect by bursting the balloons wisely.

    Note:

    
        You may imagine nums[-1] = nums[n] = 1. They are not real therefore you can
            not burst them.
        
        0 ≤ n ≤ 500, 0 ≤ nums[i] ≤ 100
    

    Example:

    Input: [3,1,5,8]
Output: 167
Explanation: nums = [3,1,5,8] --> [3,5,8] -->   [3,8]   -->  [8]  --> []
             coins =  3*1*5      +  3*5*8    +  1*3*8      + 1*8*1   = 167
-----------------

# 1741_Find_Total_Time_Spent_by_Each_Employee
# 1741. Find Total Time Spent by Each Employee


-----------------

# 1633_Percentage_of_Users_Attended_a_Contest
# 1633. Percentage of Users Attended a Contest


-----------------

# 1643_Kth_Smallest_Instructions
# 1643. Kth Smallest Instructions


-----------------

# 1358_Number_of_Substrings_Containing_All_Three_Characters
# 1358. Number of Substrings Containing All Three Characters


-----------------

# 961_N-Repeated_Element_in_Size_2N_Array
# 961. N-Repeated Element in Size 2N Array

In a array A of size 2N, there are N+1 unique
        elements, and exactly one of these elements is repeated N times.

    Return the element repeated N times.
-----------------

# 1640_Check_Array_Formation_Through_Concatenation
# 1640. Check Array Formation Through Concatenation


-----------------

# 304_Range_Sum_Query_2D_-_Immutable
# 304. Range Sum Query 2D - Immutable

Given a 2D matrix matrix, find the sum of the elements inside the rectangle defined by
        its upper left corner (row1, col1) and lower right corner (row2,
        col2).

    
        
        The above rectangle (with the red border) is defined by (row1, col1) = (2, 1)
            and (row2, col2) = (4, 3), which contains sum = 8.
        
    

    Example:
    Given matrix = [
  [3, 0, 1, 4, 2],
  [5, 6, 3, 2, 1],
  [1, 2, 0, 1, 5],
  [4, 1, 0, 1, 7],
  [1, 0, 3, 0, 5]
]

sumRegion(2, 1, 4, 3) -> 8
sumRegion(1, 1, 2, 2) -> 11
sumRegion(1, 2, 2, 4) -> 12

    

    Note:
    
        You may assume that the matrix does not change.
        There are many calls to sumRegion function.
        You may assume that row1 ≤ row2 and col1 ≤ col2.
-----------------

# 871_Minimum_Number_of_Refueling_Stops
# 871. Minimum Number of Refueling Stops

A car travels from a starting position to a destination which is target miles
        east of the starting position.

    Along the way, there are gas stations.  Each station[i] represents a
        gas station that is station[i][0] miles east of the starting position, and has
        station[i][1] liters of gas.

    The car starts with an infinite tank of gas, which initially has startFuel liters
        of fuel in it.  It uses 1 liter of gas per 1 mile that it drives.

    When the car reaches a gas station, it may stop and refuel, transferring all the gas
        from the station into the car.

    What is the least number of refueling stops the car must make in order to reach its
        destination?  If it cannot reach the destination, return -1.

    Note that if the car reaches a gas station with 0 fuel left, the car can still refuel there. 
        If the car reaches the destination with 0 fuel left, it is still considered to have
        arrived.
-----------------

# 1334_Find_the_City_With_the_Smallest_Number_of_Neighbors_at_a_Threshold_Distance
# 1334. Find the City With the Smallest Number of Neighbors at a Threshold Distance


-----------------

# 956_Tallest_Billboard
# 956. Tallest Billboard

You are installing a billboard and want it to have the largest height.  The billboard
        will have two steel supports, one on each side.  Each steel support must be an equal
        height.

    You have a collection of rods which can be welded together.  For example,
        if you have rods of lengths 1, 2, and 3, you can weld them together to make a support of
        length 6.

    Return the largest possible height of your billboard installation.  If you cannot
        support the billboard, return 0.

     

    Example 1:

    Input: [1,2,3,6]
Output: 6
Explanation: We have two disjoint subsets {1,2,3} and {6}, which have the same sum = 6.
-----------------

# 1271_Hexspeak
# 1271. Hexspeak


-----------------

# 792_Number_of_Matching_Subsequences
# 792. Number of Matching Subsequences

Given string S and a dictionary of words words, find the
        number of words[i] that is a subsequence of S.

    Example :
Input:
S = "abcde"
words = ["a", "bb", "acd", "ace"]
Output: 3
Explanation: There are three words in words that are a subsequence of S: "a", "acd", "ace".

    Note:

    
        All words in words and S will only consists of lowercase
            letters.
        
        The length of S will be in the range of [1, 50000].
        The length of words will be in the range of [1, 5000].
        
        The length of words[i] will be in the range of [1, 50].
-----------------

# 88_Merge_Sorted_Array
# 88. Merge Sorted Array

Given two sorted integer arrays nums1 and nums2, merge nums2 into
        nums1 as one sorted array.

    Note:

    
        The number of elements initialized in nums1 and nums2 are m
            and n respectively.
        
        You may assume that nums1 has enough space (size that is greater or equal to
            m + n) to hold additional elements from nums2.
        
    

    Example:

    Input:
nums1 = [1,2,3,0,0,0], m = 3
nums2 = [2,5,6],       n = 3

Output: [1,2,2,3,5,6]
-----------------

# 1095_Find_in_Mountain_Array
# 1095. Find in Mountain Array

(This problem is an interactive problem.)

    You may recall that an array A is a mountain array if and only if:
    

    
        A.length >= 3
        There exists some i with 0 < i < A.length -
            1 such that:
            
                A[0] < A[1] < ... A[i-1] < A[i]
                A[i] > A[i+1] > ... > A[A.length - 1]
            
        
    

    Given a mountain array mountainArr, return the minimum index
        such that mountainArr.get(index) == target.  If such an index doesn't
        exist, return -1.

    You can't access the mountain array directly.  You may only access
        the array using a MountainArray interface:

    
        MountainArray.get(k) returns the element of the array at index
            k (0-indexed).
        
        MountainArray.length() returns the length of the array.
    

    Submissions making more than 100 calls to MountainArray.get will
        be judged Wrong Answer.  Also, any solutions that attempt to circumvent the
        judge will result in disqualification.

    
    

     
    Example 1:

    Input: array = [1,2,3,4,5,3,1], target = 3
Output: 2
Explanation: 3 exists in the array, at index=2 and index=5. Return the minimum index, which is 2.

    Example 2:

    Input: array = [0,1,2,4,2,1], target = 3
Output: -1
Explanation: 3 does not exist in the array, so we return -1.

     
    Constraints:

    
        3 <= mountain_arr.length() <= 10000
        0 <= target <= 10^9
        0 <= mountain_arr.get(index) <= 10^9
-----------------

# 69_Sqrt(x)
# 69. Sqrt(x)

Implement int sqrt(int x).

    Compute and return the square root of x, where x is guaranteed to
        be a non-negative integer.

    Since the return type is an integer, the decimal digits are truncated and only the
        integer part of the result is returned.

    Example 1:

    Input: 4
Output: 2

    Example 2:

    Input: 8
Output: 2
Explanation: The square root of 8 is 2.82842..., and since
             the decimal part is truncated, 2 is returned.
-----------------

# 832_Flipping_an_Image
# 832. Flipping an Image

Given a binary matrix A, we want to flip the image horizontally, then invert it,
        and return the resulting image.

    To flip an image horizontally means that each row of the image is reversed.  For
        example, flipping [1, 1, 0] horizontally results in [0, 1,
            1].

    To invert an image means that each 0 is replaced by 1, and
        each 1 is replaced by 0. For example, inverting [0,
            1, 1] results in [1, 0, 0].

    Example 1:

    Input: [[1,1,0],[1,0,1],[0,0,0]]
Output: [[1,0,0],[0,1,0],[1,1,1]]
Explanation: First reverse each row: [[0,1,1],[1,0,1],[0,0,0]].
Then, invert the image: [[1,0,0],[0,1,0],[1,1,1]]

    Example 2:

    Input: [[1,1,0,0],[1,0,0,1],[0,1,1,1],[1,0,1,0]]
Output: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]
Explanation: First reverse each row: [[0,0,1,1],[1,0,0,1],[1,1,1,0],[0,1,0,1]].
Then invert the image: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]

    Notes:

    
        1 <= A.length = A[0].length <= 20
        0 <= A[i][j] <= 1
-----------------

# 478_Generate_Random_Point_in_a_Circle
# 478. Generate Random Point in a Circle

Given the radius and x-y positions of the center of a circle, write a function randPoint which generates
        a uniform random point in the circle.

    Note:

    
        input and output values are in floating-point.
        
        radius and x-y position of the center of the circle is passed into the class
            constructor.
        
        a point on the circumference of the circle is considered to be in the circle.
        randPoint returns a size 2 array containing x-position and
            y-position of the random point, in that order.
-----------------

# 1261_Find_Elements_in_a_Contaminated_Binary_Tree
# 1261. Find Elements in a Contaminated Binary Tree


-----------------

# 606_Construct_String_from_Binary_Tree
# 606. Construct String from Binary Tree

You need to construct a string consists of parenthesis and integers from a binary tree with
        the preorder traversing way.

    The null node needs to be represented by empty parenthesis pair "()". And you need to omit
        all the empty parenthesis pairs that don't affect the one-to-one mapping relationship
        between the string and the original binary tree.

    Example 1:
    Input: Binary tree: [1,2,3,4]
       1
     /   \
    2     3
   /
  4

Output: "1(2(4))(3)"
Explanation: Originallay it needs to be "1(2(4)())(3()())", but you need to omit all the unnecessary empty parenthesis pairs. And it will be "1(2(4))(3)".

    

    Example 2:
    Input: Binary tree: [1,2,3,null,4]
       1
     /   \
    2     3
     \
      4

Output: "1(2()(4))(3)"
Explanation: Almost the same as the first example, except we can't omit the first parenthesis pair to break the one-to-one mapping relationship between the input and the output.
-----------------

# 1343_Number_of_Sub-arrays_of_Size_K_and_Average_Greater_than_or_Equal_to_Threshold
# 1343. Number of Sub-arrays of Size K and Average Greater than or Equal to Threshold


-----------------

# 1427_Perform_String_Shifts
# 1427. Perform String Shifts


-----------------

# 417_Pacific_Atlantic_Water_Flow
# 417. Pacific Atlantic Water Flow

Given an m x n matrix of non-negative integers representing the height of each
        unit cell in a continent, the "Pacific ocean" touches the left and top edges of
        the matrix and the "Atlantic ocean" touches the right and bottom edges.

    Water can only flow in four directions (up, down, left, or right) from a cell to another one
        with height equal or lower.

    Find the list of grid coordinates where water can flow to both the Pacific and Atlantic
        ocean.

    Note:

    
        The order of returned grid coordinates does not matter.
        Both m and n are less than 150.
    

     

    Example:

    Given the following 5x5 matrix:

  Pacific ~   ~   ~   ~   ~
       ~  1   2   2   3  (5) *
       ~  3   2   3  (4) (4) *
       ~  2   4  (5)  3   1  *
       ~ (6) (7)  1   4   5  *
       ~ (5)  1   1   2   4  *
          *   *   *   *   * Atlantic

Return:

[[0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0]] (positions with parentheses in above matrix).
-----------------

# 1145_Binary_Tree_Coloring_Game
# 1145. Binary Tree Coloring Game

Two players play a turn based game on a binary tree.  We are given the
        root of this binary tree, and the number of nodes n in the
        tree.  n is odd, and each node has a distinct value from
        1 to n.

    Initially, the first player names a value x with 1 <= x <= n,
        and the second player names a value y with 1 <= y <= n and
        y != x.  The first player colors the node with value x red,
        and the second player colors the node with value y blue.

    Then, the players take turns starting with the first player.  In each turn, that player
        chooses a node of their color (red if player 1, blue if player 2) and colors an uncolored
        neighbor of the chosen node (either the left child, right child, or parent of the chosen
        node.)

    If (and only if) a player cannot choose such a node in this way, they must pass their
        turn.  If both players pass their turn, the game ends, and the winner is the player
        that colored more nodes.

    You are the second player.  If it is possible to choose such a y to
        ensure you win the game, return true.  If it is not possible, return
        false.

     
    Example 1:
    
    Input: root = [1,2,3,4,5,6,7,8,9,10,11], n = 11, x = 3
Output: true
Explanation: The second player can choose the node with value 2.

     
    Constraints:

    
        root is the root of a binary tree with n nodes and distinct
            node values from 1 to n.
        
        n is odd.
        1 <= x <= n <= 100
-----------------

# 1503_Last_Moment_Before_All_Ants_Fall_Out_of_a_Plank
# 1503. Last Moment Before All Ants Fall Out of a Plank


-----------------

# 806_Number_of_Lines_To_Write_String
# 806. Number of Lines To Write String

We are to write the letters of a given string S, from left to right into lines.
        Each line has maximum width 100 units, and if writing a letter would cause the width of the
        line to exceed 100 units, it is written on the next line. We are given an array widths,
        an array where widths[0] is the width of 'a', widths[1] is the width of 'b',
        ..., and widths[25] is the width of 'z'.

    Now answer two questions: how many lines have at least one character from S, and
        what is the width used by the last such line? Return your answer as an integer list of
        length 2.

     

    Example :
Input:
widths = [10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10]
S = "abcdefghijklmnopqrstuvwxyz"
Output: [3, 60]
Explanation: 
All letters have the same length of 10. To write all 26 letters,
we need two full lines and one line with 60 units.

    Example :
Input:
widths = [4,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10]
S = "bbbcccdddaaa"
Output: [2, 4]
Explanation: 
All letters except 'a' have the same length of 10, and
"bbbcccdddaa" will cover 9 * 10 + 2 * 4 = 98 units.
For the last 'a', it is written on the second line because
there is only 2 units left in the first line.
So the answer is 2 lines, plus 4 units in the second line.

     

    Note:

    
        The length of S will be in the range [1, 1000].
        S will only contain lowercase letters.
        widths is an array of length 26.
        widths[i] will be in the range of [2, 10].
-----------------

# 999_Available_Captures_for_Rook
# 999. Available Captures for Rook

On an 8 x 8 chessboard, there is one white rook.  There also may be empty squares, white
        bishops, and black pawns.  These are given as characters 'R', '.',
        'B', and 'p' respectively. Uppercase characters represent white pieces, and
        lowercase characters represent black pieces.

    The rook moves as in the rules of Chess: it chooses one of four cardinal directions (north,
        east, west, and south), then moves in that direction until it chooses to stop, reaches the
        edge of the board, or captures an opposite colored pawn by moving to the same square it
        occupies.  Also, rooks cannot move into the same square as other friendly bishops.

    Return the number of pawns the rook can capture in one move.

     

    Example 1:

    

    Input: [[".",".",".",".",".",".",".","."],[".",".",".","p",".",".",".","."],[".",".",".","R",".",".",".","p"],[".",".",".",".",".",".",".","."],[".",".",".",".",".",".",".","."],[".",".",".","p",".",".",".","."],[".",".",".",".",".",".",".","."],[".",".",".",".",".",".",".","."]]
Output: 3
Explanation: 
In this example the rook is able to capture all the pawns.

    Example 2:

    

    Input: [[".",".",".",".",".",".",".","."],[".","p","p","p","p","p",".","."],[".","p","p","B","p","p",".","."],[".","p","B","R","B","p",".","."],[".","p","p","B","p","p",".","."],[".","p","p","p","p","p",".","."],[".",".",".",".",".",".",".","."],[".",".",".",".",".",".",".","."]]
Output: 0
Explanation: 
Bishops are blocking the rook to capture any pawn.

    Example 3:

    

    Input: [[".",".",".",".",".",".",".","."],[".",".",".","p",".",".",".","."],[".",".",".","p",".",".",".","."],["p","p",".","R",".","p","B","."],[".",".",".",".",".",".",".","."],[".",".",".","B",".",".",".","."],[".",".",".","p",".",".",".","."],[".",".",".",".",".",".",".","."]]
Output: 3
Explanation: 
The rook can capture the pawns at positions b5, d6 and f5.

     

    Note:

    
        board.length == board[i].length == 8
        board[i][j] is either 'R', '.',
            'B', or 'p'
        There is exactly one cell with board[i][j] == 'R'
-----------------

# 1345_Jump_Game_IV
# 1345. Jump Game IV


-----------------

# 1074_Number_of_Submatrices_That_Sum_to_Target
# 1074. Number of Submatrices That Sum to Target

Given a matrix, and a target, return the number of non-empty
        submatrices that sum to target.

    A submatrix x1, y1, x2, y2 is the set of all cells matrix[x][y]
        with x1 <= x <= x2 and y1 <= y <= y2.

    Two submatrices (x1, y1, x2, y2) and (x1', y1', x2',
        y2') are different if they have some coordinate that is different: for
        example, if x1 != x1'.

     

    Example 1:

    Input: matrix = [[0,1,0],[1,1,1],[0,1,0]], target = 0
Output: 4
Explanation: The four 1x1 submatrices that only contain 0.
-----------------

# 600_Non-negative_Integers_without_Consecutive_Ones
# 600. Non-negative Integers without Consecutive Ones

Given a positive integer n, find the number of non-negative integers less than or
        equal to n, whose binary representations do NOT contain consecutive ones.

    Example 1:
    Input: 5
Output: 5
Explanation:
Here are the non-negative integers <= 5 with their corresponding binary representations:
0 : 0
1 : 1
2 : 10
3 : 11
4 : 100
5 : 101
Among them, only integer 3 disobeys the rule (two consecutive ones) and the other 5 satisfy the rule.

    

    Note:
        1 <= n <= 109
-----------------

# 1852_Distinct_Numbers_in_Each_Subarray
# 1852. Distinct Numbers in Each Subarray


-----------------

# 889_Construct_Binary_Tree_from_Preorder_and_Postorder_Traversal
# 889. Construct Binary Tree from Preorder and Postorder Traversal

Return any binary tree that matches the given preorder and postorder traversals.

    Values in the traversals pre and post are distinct positive
        integers.
-----------------

# 954_Array_of_Doubled_Pairs
# 954. Array of Doubled Pairs

Given an array of integers A with even length, return true if
        and only if it is possible to reorder it such that A[2 * i + 1] = 2 * A[2 * i]
        for every 0 <= i < len(A) / 2.
-----------------

# 1819_Number_of_Different_Subsequences_GCDs
# 1819. Number of Different Subsequences GCDs


-----------------

# 1273_Delete_Tree_Nodes
# 1273. Delete Tree Nodes


-----------------

# 1009_Complement_of_Base_10_Integer
# 1009. Complement of Base 10 Integer

Every non-negative integer N has a binary representation.  For
        example, 5 can be represented as "101" in
        binary, 11 as "1011" in binary, and so on. 
        Note that except for N = 0, there are no leading zeroes in any binary
        representation.

    The complement of a binary representation is the number in binary you get
        when changing every 1 to a 0 and 0 to a
        1.  For example, the complement of "101" in binary
        is "010" in binary.

    For a given number N in base-10, return the complement of it's binary
        representation as a base-10 integer.
-----------------

# 1195_Fizz_Buzz_Multithreaded
# 1195. Fizz Buzz Multithreaded

Write a program that outputs the string representation of numbers from 1 to n,
        however:

    
        If the number is divisible by 3, output "fizz".
        If the number is divisible by 5, output "buzz".
        If the number is divisible by both 3 and 5, output "fizzbuzz".
    

    For example, for n = 15, we output: 1, 2, fizz, 4, buzz, fizz,
        7, 8, fizz, buzz, 11, fizz, 13, 14, fizzbuzz.

    Suppose you are given the following code:

    class FizzBuzz {
  public FizzBuzz(int n) { ... }               // constructor
  public void fizz(printFizz) { ... }          // only output "fizz"
  public void buzz(printBuzz) { ... }          // only output "buzz"
  public void fizzbuzz(printFizzBuzz) { ... }  // only output "fizzbuzz"
  public void number(printNumber) { ... }      // only output the numbers
}

    Implement a multithreaded version of FizzBuzz with four
        threads. The same instance of FizzBuzz will be passed to four different
        threads:

    
        Thread A will call fizz() to check for divisibility of 3 and
            outputs fizz.
        
        Thread B will call buzz() to check for divisibility of 5 and
            outputs buzz.
        
        Thread C will call fizzbuzz() to check for divisibility of 3 and 5 and
            outputs fizzbuzz.
        
        Thread D will call number() which should only output the numbers.
-----------------

# 1468_Calculate_Salaries
# 1468. Calculate Salaries


-----------------

# 510_Inorder_Successor_in_BST_II
# 510. Inorder Successor in BST II

Given a binary search tree and a node in it, find the in-order successor of that node in the
        BST.

    The successor of a node p is the node with the smallest key greater than p.val.
    

    You will have direct access to the node but not to the root of the tree. Each node will have
        a reference to its parent node.

     

    Example 1:
    
    Input: 
root = {"$id":"1","left":{"$id":"2","left":null,"parent":{"$ref":"1"},"right":null,"val":1},"parent":null,"right":{"$id":"3","left":null,"parent":{"$ref":"1"},"right":null,"val":3},"val":2}
p = 1
Output: 2
Explanation: 1's in-order successor node is 2. Note that both p and the return value is of Node type.

    Example 2:
    
    Input: 
root = {"$id":"1","left":{"$id":"2","left":{"$id":"3","left":{"$id":"4","left":null,"parent":{"$ref":"3"},"right":null,"val":1},"parent":{"$ref":"2"},"right":null,"val":2},"parent":{"$ref":"1"},"right":{"$id":"5","left":null,"parent":{"$ref":"2"},"right":null,"val":4},"val":3},"parent":null,"right":{"$id":"6","left":null,"parent":{"$ref":"1"},"right":null,"val":6},"val":5}
p = 6
Output: null
Explanation: There is no in-order successor of the current node, so the answer is null.

    Example 3:
    
    Input: 
root = {"$id":"1","left":{"$id":"2","left":{"$id":"3","left":{"$id":"4","left":null,"parent":{"$ref":"3"},"right":null,"val":2},"parent":{"$ref":"2"},"right":{"$id":"5","left":null,"parent":{"$ref":"3"},"right":null,"val":4},"val":3},"parent":{"$ref":"1"},"right":{"$id":"6","left":null,"parent":{"$ref":"2"},"right":{"$id":"7","left":{"$id":"8","left":null,"parent":{"$ref":"7"},"right":null,"val":9},"parent":{"$ref":"6"},"right":null,"val":13},"val":7},"val":6},"parent":null,"right":{"$id":"9","left":{"$id":"10","left":null,"parent":{"$ref":"9"},"right":null,"val":17},"parent":{"$ref":"1"},"right":{"$id":"11","left":null,"parent":{"$ref":"9"},"right":null,"val":20},"val":18},"val":15}
p = 15
Output: 17

    Example 4:
    
    Input: 
root = {"$id":"1","left":{"$id":"2","left":{"$id":"3","left":{"$id":"4","left":null,"parent":{"$ref":"3"},"right":null,"val":2},"parent":{"$ref":"2"},"right":{"$id":"5","left":null,"parent":{"$ref":"3"},"right":null,"val":4},"val":3},"parent":{"$ref":"1"},"right":{"$id":"6","left":null,"parent":{"$ref":"2"},"right":{"$id":"7","left":{"$id":"8","left":null,"parent":{"$ref":"7"},"right":null,"val":9},"parent":{"$ref":"6"},"right":null,"val":13},"val":7},"val":6},"parent":null,"right":{"$id":"9","left":{"$id":"10","left":null,"parent":{"$ref":"9"},"right":null,"val":17},"parent":{"$ref":"1"},"right":{"$id":"11","left":null,"parent":{"$ref":"9"},"right":null,"val":20},"val":18},"val":15}
p = 13
Output: 15

     

    Note:

    
        If the given node has no in-order successor in the tree, return null.
        It's guaranteed that the values of the tree are unique.
        Remember that we are using the Node type instead of TreeNode
            type so their string representation are different.
        
    

     

    Follow up:

    Could you solve it without looking up any of the node's values?
-----------------

# 1031_Maximum_Sum_of_Two_Non-Overlapping_Subarrays
# 1031. Maximum Sum of Two Non-Overlapping Subarrays

Given an array A of non-negative integers, return the maximum sum of elements in
        two non-overlapping (contiguous) subarrays, which have lengths L and
        M.  (For clarification, the L-length subarray could occur
        before or after the M-length subarray.)

    Formally, return the largest V for which V = (A[i] + A[i+1] +
        ... + A[i+L-1]) + (A[j] + A[j+1] + ... + A[j+M-1]) and either:

    
        0 <= i < i + L - 1 < j < j + M - 1 < A.length,
            or
        0 <= j < j + M - 1 < i < i + L - 1 < A.length.
-----------------

# 807_Max_Increase_to_Keep_City_Skyline
# 807. Max Increase to Keep City Skyline

In a 2 dimensional array grid, each value grid[i][j] represents the
        height of a building located there. We are allowed to increase the height of any number of
        buildings, by any amount (the amounts can be different for different buildings). Height 0
        is considered to be a building as well. 

    At the end, the "skyline" when viewed from all four directions of the grid,
        i.e. top, bottom, left, and right, must be the same as the skyline of the
        original grid. A city's skyline is the outer contour of the rectangles formed by all the
        buildings when viewed from a distance. See the following example.

    What is the maximum total sum that the height of the buildings can be increased?

    Example:
Input: grid = [[3,0,8,4],[2,4,5,7],[9,2,6,3],[0,3,1,0]]
Output: 35
Explanation:
The grid is:
[ [3, 0, 8, 4],
  [2, 4, 5, 7],
  [9, 2, 6, 3],
  [0, 3, 1, 0] ]

The skyline viewed from top or bottom is: [9, 4, 8, 7]
The skyline viewed from left or right is: [8, 7, 9, 3]

The grid after increasing the height of buildings without affecting skylines is:

gridNew = [ [8, 4, 8, 7],
            [7, 4, 7, 7],
            [9, 4, 8, 7],
            [3, 3, 3, 3] ]

    Notes: 

    
        1 < grid.length = grid[0].length <= 50.
        All heights grid[i][j] are in the range [0, 100].
        All buildings in grid[i][j] occupy the entire grid cell: that is, they are
            a 1 x 1 x grid[i][j] rectangular prism.
-----------------

# 1484_Group_Sold_Products_By_The_Date
# 1484. Group Sold Products By The Date


-----------------

# 39_Combination_Sum
# 39. Combination Sum

Given a set of candidate numbers (candidates) (without
        duplicates) and a target number (target), find all unique combinations
        in candidates where the candidate numbers sums to target.

    The same repeated number may be chosen from candidates unlimited
        number of times.

    Note:

    
        All numbers (including target) will be positive integers.
        The solution set must not contain duplicate combinations.
    

    Example 1:

    Input: candidates = [2,3,6,7], target = 7,
A solution set is:
[
  [7],
  [2,2,3]
]

    Example 2:

    Input: candidates = [2,3,5], target = 8,
A solution set is:
[
  [2,2,2,2],
  [2,3,3],
  [3,5]
]
-----------------

# 1697_Checking_Existence_of_Edge_Length_Limited_Paths
# 1697. Checking Existence of Edge Length Limited Paths


-----------------

# 1657_Determine_if_Two_Strings_Are_Close
# 1657. Determine if Two Strings Are Close


-----------------

# 1355_Activity_Participants
# 1355. Activity Participants


-----------------

# 1027_Longest_Arithmetic_Sequence
# 1027. Longest Arithmetic Sequence

Given an array A of integers, return the length of the longest
        arithmetic subsequence in A.

    Recall that a subsequence of A is a list A[i_1], A[i_2], ...,
        A[i_k] with 0 <= i_1 < i_2 < ... < i_k <= A.length - 1,
        and that a sequence B is arithmetic if B[i+1] - B[i]
        are all the same value (for 0 <= i < B.length - 1).

     

    Example 1:

    Input: [3,6,9,12]
Output: 4
Explanation: 
The whole array is an arithmetic sequence with steps of length = 3.
-----------------

# 1101_The_Earliest_Moment_When_Everyone_Become_Friends
# 1101. The Earliest Moment When Everyone Become Friends

In a social group, there are N people, with unique integer ids from
        0 to N-1.

    We have a list of logs, where each logs[i] = [timestamp, id_A,
        id_B] contains a non-negative integer timestamp, and the ids of two different
        people.

    Each log represents the time in which two different people became friends.  Friendship
        is symmetric: if A is friends with B, then B is friends with A.

    Let's say that person A is acquainted with person B if A is friends with B, or A is a
        friend of someone acquainted with B.

    Return the earliest time for which every person became acquainted with every other person.
        Return -1 if there is no such earliest time.

     

    Example 1:

    Input: logs = [[20190101,0,1],[20190104,3,4],[20190107,2,3],[20190211,1,5],[20190224,2,4],[20190301,0,3],[20190312,1,2],[20190322,4,5]], N = 6
Output: 20190301
Explanation: 
The first event occurs at timestamp = 20190101 and after 0 and 1 become friends we have the following friendship groups [0,1], [2], [3], [4], [5].
The second event occurs at timestamp = 20190104 and after 3 and 4 become friends we have the following friendship groups [0,1], [2], [3,4], [5].
The third event occurs at timestamp = 20190107 and after 2 and 3 become friends we have the following friendship groups [0,1], [2,3,4], [5].
The fourth event occurs at timestamp = 20190211 and after 1 and 5 become friends we have the following friendship groups [0,1,5], [2,3,4].
The fifth event occurs at timestamp = 20190224 and as 2 and 4 are already friend anything happens.
The sixth event occurs at timestamp = 20190301 and after 0 and 3 become friends we have that all become friends.

     

    Note:

    
        2 <= N <= 100
        1 <= logs.length <= 10^4
        0 <= logs[i][0] <= 10^9
        0 <= logs[i][1], logs[i][2] <= N - 1
        It's guaranteed that all timestamps in logs[i][0] are different.
        logs are not necessarily ordered by some criteria.
        logs[i][1] != logs[i][2]
-----------------

# 285_Inorder_Successor_in_BST
# 285. Inorder Successor in BST

Given a binary search tree and a node in it, find the in-order successor of that node in the
        BST.

    The successor of a node p is the node with the smallest key greater
        than p.val.

     

    Example 1:
    
    Input: root = [2,1,3], p = 1
Output: 2
Explanation: 1's in-order successor node is 2. Note that both p and the return value is of TreeNode type.

    Example 2:
    
    Input: root = [5,3,6,2,4,null,null,1], p = 6
Output: null
Explanation: There is no in-order successor of the current node, so the answer is null.

     

    Note:

    
        If the given node has no in-order successor in the tree, return null.
        It's guaranteed that the values of the tree are unique.
-----------------

# 918_Maximum_Sum_Circular_Subarray
# 918. Maximum Sum Circular Subarray

Given a circular array C of integers represented
        by A, find the maximum possible sum of a non-empty subarray of
        C.

    Here, a circular array means the end of the array connects to the
        beginning of the array.  (Formally, C[i] = A[i] when 0 <= i <
            A.length, and C[i+A.length] = C[i] when i >=
            0.)

    Also, a subarray may only include each element of the fixed buffer A at most
        once.  (Formally, for a subarray C[i], C[i+1], ..., C[j], there does not
        exist i <= k1, k2 <= j with k1 % A.length = k2 %
            A.length.)
-----------------

# 1240_Tiling_a_Rectangle_with_the_Fewest_Squares
# 1240. Tiling a Rectangle with the Fewest Squares

Given a rectangle of size n x m, find the minimum number of integer-sided squares that
        tile the rectangle.

     
    Example 1:

    

    Input: n = 2, m = 3
Output: 3
Explanation: 3 squares are necessary to cover the rectangle.
2 (squares of 1x1)
1 (square of 2x2)

    Example 2:

    

    Input: n = 5, m = 8
Output: 5

    Example 3:

    

    Input: n = 11, m = 13
Output: 6

     
    Constraints:

    
        1 <= n <= 13
        1 <= m <= 13
-----------------

# 1378_Replace_Employee_ID_With_The_Unique_Identifier
# 1378. Replace Employee ID With The Unique Identifier


-----------------

# 1384_Total_Sales_Amount_by_Year
# 1384. Total Sales Amount by Year


-----------------

# 412_Fizz_Buzz
# 412. Fizz Buzz

Write a program that outputs the string representation of numbers from 1 to n.

    But for multiples of three it should output “Fizz” instead of the number and for the
        multiples of five output “Buzz”. For numbers which are multiples of both three and five
        output “FizzBuzz”.

    Example:
    n = 15,

Return:
[
    "1",
    "2",
    "Fizz",
    "4",
    "Buzz",
    "Fizz",
    "7",
    "8",
    "Fizz",
    "Buzz",
    "11",
    "Fizz",
    "13",
    "14",
    "FizzBuzz"
]
-----------------

# 943_Find_the_Shortest_Superstring
# 943. Find the Shortest Superstring

Given an array A of strings, find any smallest string that contains each string in
        A as a substring.

    We may assume that no string in A is substring of another string in
        A.
-----------------

# 524_Longest_Word_in_Dictionary_through_Deleting
# 524. Longest Word in Dictionary through Deleting

Given a string and a string dictionary, find the longest string in the dictionary that can
        be formed by deleting some characters of the given string. If there are more than one
        possible results, return the longest word with the smallest lexicographical order. If there
        is no possible result, return the empty string.
    
    Example 1:
    Input:
s = "abpcplea", d = ["ale","apple","monkey","plea"]

Output:
"apple"

    

    
    Example 2:
    Input:
s = "abpcplea", d = ["a","b","c"]

Output:
"a"

    

    Note:
    
        All the strings in the input will only contain lower-case letters.
        The size of the dictionary won't exceed 1,000.
        The length of all the strings in the input won't exceed 1,000.
-----------------

# 1081_Smallest_Subsequence_of_Distinct_Characters
# 1081. Smallest Subsequence of Distinct Characters

Return the lexicographically smallest subsequence of text that contains all the
        distinct characters of text exactly once.

     

    Example 1:

    Input: "cdadabcc"
Output: "adbc"
-----------------

# 1243_Array_Transformation
# 1243. Array Transformation

Given an initial array arr, every day you produce a new array using the array of
        the previous day.

    On the i-th day, you do the following operations on the array of day i-1 to
        produce the array of day i:

    
        If an element is smaller than both its left neighbor and its right neighbor, then this
            element is incremented.
        
        If an element is bigger than both its left neighbor and its right neighbor, then this
            element is decremented.
        
        The first and last elements never change.
    

    After some days, the array does not change. Return that final array.

     
    Example 1:

    Input: arr = [6,2,3,4]
Output: [6,3,3,4]
Explanation: 
On the first day, the array is changed from [6,2,3,4] to [6,3,3,4].
No more operations can be done to this array.

    Example 2:

    Input: arr = [1,6,3,4,3,5]
Output: [1,4,4,4,4,5]
Explanation: 
On the first day, the array is changed from [1,6,3,4,3,5] to [1,5,4,3,4,5].
On the second day, the array is changed from [1,5,4,3,4,5] to [1,4,4,4,4,5].
No more operations can be done to this array.

     
    Constraints:

    
        1 <= arr.length <= 100
        1 <= arr[i] <= 100
-----------------

# 251_Flatten_2D_Vector
# 251. Flatten 2D Vector

Design and implement an iterator to flatten a 2d vector. It should support the following
        operations: next and hasNext.

     

    Example:

    Vector2D iterator = new Vector2D([[1,2],[3],[4]]);

iterator.next(); // return 1
iterator.next(); // return 2
iterator.next(); // return 3
iterator.hasNext(); // return true
iterator.hasNext(); // return true
iterator.next(); // return 4
iterator.hasNext(); // return false

     

    Notes:

    
        Please remember to RESET your class variables declared in Vector2D, as
            static/class variables are persisted across multiple test cases. Please see here for more details.
        
        You may assume that next() call will always be valid, that is, there will
            be at least a next element in the 2d vector when next() is called.
        
    

     

    Follow up:

    As an added challenge, try to code it using only iterators
        in C++ or iterators in Java.
-----------------

# 1826_Faulty_Sensor
# 1826. Faulty Sensor


-----------------

# 488_Zuma_Game
# 488. Zuma Game

Think about Zuma Game. You have a row of balls on the table, colored red(R), yellow(Y),
        blue(B), green(G), and white(W). You also have several balls in your hand.
    
        Each time, you may choose a ball in your hand, and insert it into the row (including the
        leftmost place and rightmost place). Then, if there is a group of 3 or more balls in the
        same color touching, remove these balls. Keep doing this until no more balls can be
        removed.
    
        Find the minimal balls you have to insert to remove all the balls on the table. If you
        cannot remove all the balls, output -1.
    
    Examples:
Input: "WRRBBW", "RB"
Output: -1
Explanation: WRRBBW -> WRR[R]BBW -> WBBW -> WBB[B]W -> WW

Input: "WWRRBBWW", "WRBRW"
Output: 2
Explanation: WWRRBBWW -> WWRR[R]BBWW -> WWBBWW -> WWBB[B]WW -> WWWW -> empty

Input:"G", "GGGGG"
Output: 2
Explanation: G -> G[G] -> GG[G] -> empty

Input: "RBYYBBRRB", "YRBGB"
Output: 3
Explanation: RBYYBBRRB -> RBYY[Y]BBRRB -> RBBBRRB -> RRRB -> B -> B[B] -> BB[B] -> empty

    

    Note:
    
        You may assume that the initial row of balls on the table won’t have any 3 or more
            consecutive balls with the same color.
        
        The number of balls on the table won't exceed 20, and the string represents these balls
            is called "board" in the input.
        
        The number of balls in your hand won't exceed 5, and the string represents these balls
            is called "hand" in the input.
        
        Both input strings will be non-empty and only contain characters 'R','Y','B','G','W'.
-----------------

# 851_Loud_and_Rich
# 851. Loud and Rich

In a group of N people (labelled 0, 1, 2, ..., N-1), each person has different
        amounts of money, and different levels of quietness.

    For convenience, we'll call the person with label x, simply "person
        x".

    We'll say that richer[i] = [x, y] if person x definitely
        has more money than person y.  Note that richer may
        only be a subset of valid observations.

    Also, we'll say quiet[x] = q if person x has
        quietness q.

    Now, return answer, where answer[x] = y if y is the
        least quiet person (that is, the person y with the smallest value of quiet[y]),
        among all people who definitely have equal to or more money than person
        x.
-----------------

# 860_Lemonade_Change
# 860. Lemonade Change

At a lemonade stand, each lemonade costs $5. 

    Customers are standing in a queue to buy from you, and order one at a time (in the order
        specified by bills).

    Each customer will only buy one lemonade and pay with either a $5, $10,
        or $20 bill.  You must provide the correct change to each customer, so
        that the net transaction is that the customer pays $5.

    Note that you don't have any change in hand at first.

    Return true if and only if you can provide every customer with correct
        change.
-----------------

# 738_Monotone_Increasing_Digits
# 738. Monotone Increasing Digits

Given a non-negative integer N, find the largest number that is less than or
        equal to N with monotone increasing digits.
    
    
        (Recall that an integer has monotone increasing digits if and only if each pair of
        adjacent digits x and y satisfy x <= y.)
    
    

    Example 1:
    Input: N = 10
Output: 9

    

    Example 2:
    Input: N = 1234
Output: 1234

    

    Example 3:
    Input: N = 332
Output: 299

    

    Note:
        N is an integer in the range [0, 10^9].
-----------------

# 565_Array_Nesting
# 565. Array Nesting

A zero-indexed array A of length N contains all integers from 0 to N-1. Find and return the
        longest length of set S, where S[i] = {A[i], A[A[i]], A[A[A[i]]], ... } subjected to the
        rule below.

    Suppose the first element in S starts with the selection of element A[i] of index = i, the
        next element in S should be A[A[i]], and then A[A[A[i]]]… By that analogy, we stop
        adding right before a duplicate element occurs in S.

     

    Example 1:

    Input: A = [5,4,0,3,1,6,2]
Output: 4
Explanation:
A[0] = 5, A[1] = 4, A[2] = 0, A[3] = 3, A[4] = 1, A[5] = 6, A[6] = 2.

One of the longest S[K]:
S[0] = {A[0], A[5], A[6], A[2]} = {5, 6, 2, 0}

     

    Note:

    
        N is an integer within the range [1, 20,000].
        The elements of A are all distinct.
        Each element of A is an integer within the range [0, N-1].
-----------------

# 231_Power_of_Two
# 231. Power of Two

Given an integer, write a function to determine if it is a power of two.

    Example 1:

    Input: 1
Output: true
Explanation: 20 = 1

    Example 2:

    Input: 16
Output: true
Explanation: 24 = 16

    Example 3:

    Input: 218
Output: false
-----------------

# 1669_Merge_In_Between_Linked_Lists
# 1669. Merge In Between Linked Lists


-----------------

# 59_Spiral_Matrix_II
# 59. Spiral Matrix II

Given a positive integer n, generate a square matrix filled with elements from 1 to
        n2 in spiral order.

    Example:

    Input: 3
Output:
[
 [ 1, 2, 3 ],
 [ 8, 9, 4 ],
 [ 7, 6, 5 ]
]
-----------------

# 1053_Previous_Permutation_With_One_Swap
# 1053. Previous Permutation With One Swap

Given an array A of positive integers (not necessarily distinct), return the
        lexicographically largest permutation that is smaller than A, that can be
        made with one swap (A swap exchanges the positions of two numbers
        A[i] and A[j]).  If it cannot be done, then return the same
        array.

     

    Example 1:

    Input: [3,2,1]
Output: [3,1,2]
Explanation: Swapping 2 and 1.

    Example 2:

    Input: [1,1,5]
Output: [1,1,5]
Explanation: This is already the smallest permutation.

    Example 3:

    Input: [1,9,4,6,7]
Output: [1,7,4,6,9]
Explanation: Swapping 9 and 7.

    Example 4:

    Input: [3,1,1,3]
Output: [1,3,1,3]
Explanation: Swapping 1 and 3.

     

    Note:

    
        1 <= A.length <= 10000
        1 <= A[i] <= 10000
-----------------

# 1222_Queens_That_Can_Attack_the_King
# 1222. Queens That Can Attack the King

On an 8x8 chessboard, there can be multiple Black Queens and one White King.
    

    Given an array of integer coordinates queens that represents the positions of
        the Black Queens, and a pair of coordinates king that represent the position of
        the White King, return the coordinates of all the queens (in any order) that can attack the
        King.

     
    Example 1:

    

    Input: queens = [[0,1],[1,0],[4,0],[0,4],[3,3],[2,4]], king = [0,0]
Output: [[0,1],[1,0],[3,3]]
Explanation: 
The queen at [0,1] can attack the king cause they're in the same row.
The queen at [1,0] can attack the king cause they're in the same column.
The queen at [3,3] can attack the king cause they're in the same diagnal.
The queen at [0,4] can't attack the king cause it's blocked by the queen at [0,1].
The queen at [4,0] can't attack the king cause it's blocked by the queen at [1,0].
The queen at [2,4] can't attack the king cause it's not in the same row/column/diagnal as the king.

    Example 2:

    

    Input: queens = [[0,0],[1,1],[2,2],[3,4],[3,5],[4,4],[4,5]], king = [3,3]
Output: [[2,2],[3,4],[4,4]]

    Example 3:

    

    Input: queens = [[5,6],[7,7],[2,1],[0,7],[1,6],[5,1],[3,7],[0,3],[4,0],[1,2],[6,3],[5,0],[0,4],[2,2],[1,1],[6,4],[5,4],[0,0],[2,6],[4,5],[5,2],[1,4],[7,5],[2,3],[0,5],[4,2],[1,0],[2,7],[0,1],[4,6],[6,1],[0,6],[4,3],[1,7]], king = [3,4]
Output: [[2,3],[1,4],[1,6],[3,7],[4,3],[5,4],[4,5]]

     
    Constraints:

    
        1 <= queens.length <= 63
        queens[0].length == 2
        0 <= queens[i][j] < 8
        king.length == 2
        0 <= king[0], king[1] < 8
        At most one piece is allowed in a cell.
-----------------

# 472_Concatenated_Words
# 472. Concatenated Words

Given a list of words (without duplicates), please write a program that returns all
    concatenated words in the given list of words.
    A concatenated word is defined as a string that is comprised entirely of at least two shorter
        words in the given array.

    Example:
    Input: ["cat","cats","catsdogcats","dog","dogcatsdog","hippopotamuses","rat","ratcatdogcat"]

Output: ["catsdogcats","dogcatsdog","ratcatdogcat"]

Explanation: "catsdogcats" can be concatenated by "cats", "dog" and "cats";  "dogcatsdog" can be concatenated by "dog", "cats" and "dog"; "ratcatdogcat" can be concatenated by "rat", "cat", "dog" and "cat".

    

    Note:
    
        The number of elements of the given array will not exceed 10,000 
        The length sum of elements in the given array will not exceed 600,000.
        All the input string will only include lower case letters.
        The returned elements order does not matter.
-----------------

# 117_Populating_Next_Right_Pointers_in_Each_Node_II
# 117. Populating Next Right Pointers in Each Node II

Given a binary tree

    struct Node {
  int val;
  Node *left;
  Node *right;
  Node *next;
}

    Populate each next pointer to point to its next right node. If there is no next right node,
        the next pointer should be set to NULL.

    Initially, all next pointers are set to NULL.

     

    Example:

    

    Input: {"$id":"1","left":{"$id":"2","left":{"$id":"3","left":null,"next":null,"right":null,"val":4},"next":null,"right":{"$id":"4","left":null,"next":null,"right":null,"val":5},"val":2},"next":null,"right":{"$id":"5","left":null,"next":null,"right":{"$id":"6","left":null,"next":null,"right":null,"val":7},"val":3},"val":1}

Output: {"$id":"1","left":{"$id":"2","left":{"$id":"3","left":null,"next":{"$id":"4","left":null,"next":{"$id":"5","left":null,"next":null,"right":null,"val":7},"right":null,"val":5},"right":null,"val":4},"next":{"$id":"6","left":null,"next":null,"right":{"$ref":"5"},"val":3},"right":{"$ref":"4"},"val":2},"next":null,"right":{"$ref":"6"},"val":1}

Explanation: Given the above binary tree (Figure A), your function should populate each next pointer to point to its next right node, just like in Figure B.

     

    Note:

    
        You may only use constant extra space.
        Recursive approach is fine, implicit stack space does not count as extra space for this
            problem.
-----------------

# 102_Binary_Tree_Level_Order_Traversal
# 102. Binary Tree Level Order Traversal

Given a binary tree, return the level order traversal of its nodes' values. (ie, from
        left to right, level by level).

    
        For example:
        Given binary tree [3,9,20,null,null,15,7],
        3
   / \
  9  20
    /  \
   15   7

    
    
        return its level order traversal as:
    [
  [3],
  [9,20],
  [15,7]
]
-----------------

# 1700_Number_of_Students_Unable_to_Eat_Lunch
# 1700. Number of Students Unable to Eat Lunch


-----------------

# 1597_Build_Binary_Expression_Tree_From_Infix_Expression
# 1597. Build Binary Expression Tree From Infix Expression


-----------------

# 1284_Minimum_Number_of_Flips_to_Convert_Binary_Matrix_to_Zero_Matrix
# 1284. Minimum Number of Flips to Convert Binary Matrix to Zero Matrix


-----------------

# 1546_Maximum_Number_of_Non-Overlapping_Subarrays_With_Sum_Equals_Target
# 1546. Maximum Number of Non-Overlapping Subarrays With Sum Equals Target


-----------------

# 530_Minimum_Absolute_Difference_in_BST
# 530. Minimum Absolute Difference in BST

Given a binary search tree with non-negative values, find the minimum absolute difference between
        values of any two nodes.

    Example:

    Input:

   1
    \
     3
    /
   2

Output:
1

Explanation:
The minimum absolute difference is 1, which is the difference between 2 and 1 (or between 2 and 3).

     

    Note: There are at least two nodes in this BST.
-----------------

# 1719_Number_Of_Ways_To_Reconstruct_A_Tree
# 1719. Number Of Ways To Reconstruct A Tree


-----------------

# 689_Maximum_Sum_of_3_Non-Overlapping_Subarrays
# 689. Maximum Sum of 3 Non-Overlapping Subarrays

In a given array nums of positive integers, find three non-overlapping subarrays
        with maximum sum.

    Each subarray will be of size k, and we want to maximize the sum of all 3*k
        entries.

    Return the result as a list of indices representing the starting position of each interval
        (0-indexed). If there are multiple answers, return the lexicographically smallest one.

    Example:

    Input: [1,2,1,2,6,7,5,1], 2
Output: [0, 3, 5]
Explanation: Subarrays [1, 2], [2, 6], [7, 5] correspond to the starting indices [0, 3, 5].
We could have also taken [2, 1], but an answer of [1, 3, 5] would be lexicographically larger.

     

    Note:

    
        nums.length will be between 1 and 20000.
        nums[i] will be between 1 and 65535.
        k will be between 1 and floor(nums.length / 3).
-----------------

# 206_Reverse_Linked_List
# 206. Reverse Linked List

Reverse a singly linked list.

    Example:

    Input: 1->2->3->4->5->NULL
Output: 5->4->3->2->1->NULL

    Follow up:

    A linked list can be reversed either iteratively or recursively. Could you implement
        both?
-----------------

# 44_Wildcard_Matching
# 44. Wildcard Matching

Given an input string (s) and a pattern (p), implement wildcard
        pattern matching with support for '?' and '*'.

    '?' Matches any single character.
'*' Matches any sequence of characters (including the empty sequence).

    The matching should cover the entire input string (not partial).

    Note:

    
        s could be empty and contains only lowercase letters a-z.
        
        p could be empty and contains only lowercase letters a-z, and
            characters like ? or *.
        
    

    Example 1:

    Input:
s = "aa"
p = "a"
Output: false
Explanation: "a" does not match the entire string "aa".

    Example 2:

    Input:
s = "aa"
p = "*"
Output: true
Explanation: '*' matches any sequence.

    Example 3:

    Input:
s = "cb"
p = "?a"
Output: false
Explanation: '?' matches 'c', but the second letter is 'a', which does not match 'b'.

    Example 4:

    Input:
s = "adceb"
p = "*a*b"
Output: true
Explanation: The first '*' matches the empty sequence, while the second '*' matches the substring "dce".

    Example 5:

    Input:
s = "acdcb"
p = "a*c?b"
Output: false
-----------------

# 182_Duplicate_Emails
# 182. Duplicate Emails

Write a SQL query to find all duplicate emails in a table named Person.

    +----+---------+
| Id | Email   |
+----+---------+
| 1  | a@b.com |
| 2  | c@d.com |
| 3  | a@b.com |
+----+---------+

    For example, your query should return the following for the above table:

    +---------+
| Email   |
+---------+
| a@b.com |
+---------+

    Note: All emails are in lowercase.
-----------------

# 1839_Longest_Substring_Of_All_Vowels_in_Order
# 1839. Longest Substring Of All Vowels in Order


-----------------

# 712_Minimum_ASCII_Delete_Sum_for_Two_Strings
# 712. Minimum ASCII Delete Sum for Two Strings

Given two strings s1, s2, find the lowest ASCII sum of deleted characters to
        make two strings equal.

    Example 1:
    Input: s1 = "sea", s2 = "eat"
Output: 231
Explanation: Deleting "s" from "sea" adds the ASCII value of "s" (115) to the sum.
Deleting "t" from "eat" adds 116 to the sum.
At the end, both strings are equal, and 115 + 116 = 231 is the minimum sum possible to achieve this.

    

    Example 2:
    Input: s1 = "delete", s2 = "leet"
Output: 403
Explanation: Deleting "dee" from "delete" to turn the string into "let",
adds 100[d]+101[e]+101[e] to the sum.  Deleting "e" from "leet" adds 101[e] to the sum.
At the end, both strings are equal to "let", and the answer is 100+101+101+101 = 403.
If instead we turned both strings into "lee" or "eet", we would get answers of 433 or 417, which are higher.

    

    Note:
    0 < s1.length, s2.length <= 1000.
    All elements of each string will have an ASCII value in [97, 122].
-----------------

# 1733_Minimum_Number_of_People_to_Teach
# 1733. Minimum Number of People to Teach


-----------------

# 788_Rotated_Digits
# 788. Rotated Digits

X is a good number if after rotating each digit individually by 180 degrees, we get a valid
        number that is different from X.  Each digit must be rotated - we cannot choose to
        leave it alone.

    A number is valid if each digit remains a digit after rotation. 0, 1, and 8 rotate to
        themselves; 2 and 5 rotate to each other; 6 and 9 rotate to each other, and the rest of the
        numbers do not rotate to any other number and become invalid.

    Now given a positive number N, how many numbers X from 1 to
        N are good?

    Example:
Input: 10
Output: 4
Explanation:
There are four good numbers in the range [1, 10] : 2, 5, 6, 9.
Note that 1 and 10 are not good numbers, since they remain unchanged after rotating.

    Note:

    
        N  will be in range [1, 10000].
-----------------

# 1163_Last_Substring_in_Lexicographical_Order
# 1163. Last Substring in Lexicographical Order

Given a string s, return the last substring of s in lexicographical
        order.

     

    Example 1:

    Input: "abab"
Output: "bab"
Explanation: The substrings are ["a", "ab", "aba", "abab", "b", "ba", "bab"]. The lexicographically maximum substring is "bab".

    Example 2:

    Input: "leetcode"
Output: "tcode"

     

    Note:

    
        1 <= s.length <= 4 * 10^5
        s contains only lowercase English letters.
-----------------

# 739_Daily_Temperatures
# 739. Daily Temperatures

Given a list of daily temperatures T, return a list such that, for each day in
        the input, tells you how many days you would have to wait until a warmer temperature. If
        there is no future day for which this is possible, put 0 instead.
    
    
        For example, given the list of temperatures T = [73, 74, 75, 71, 69, 72, 76,
        73], your output should be [1, 1, 4, 2, 1, 1, 0, 0].
    

    Note:
        The length of temperatures will be in the range [1, 30000].
        Each temperature will be an integer in the range [30, 100].
-----------------

# 525_Contiguous_Array
# 525. Contiguous Array

Given a binary array, find the maximum length of a contiguous subarray with equal number of 0
        and 1. 

    Example 1:
    Input: [0,1]
Output: 2
Explanation: [0, 1] is the longest contiguous subarray with equal number of 0 and 1.

    

    Example 2:
    Input: [0,1,0]
Output: 2
Explanation: [0, 1] (or [1, 0]) is a longest contiguous subarray with equal number of 0 and 1.

    

    Note:
        The length of the given binary array will not exceed 50,000.
-----------------

# 1586_Binary_Search_Tree_Iterator_II
# 1586. Binary Search Tree Iterator II


-----------------

# 323_Number_of_Connected_Components_in_an_Undirected_Graph
# 323. Number of Connected Components in an Undirected Graph

Given n nodes labeled from 0 to n - 1 and a list of
        undirected edges (each edge is a pair of nodes), write a function to find the number of
        connected components in an undirected graph.

    Example 1:

    Input: n = 5 and edges = [[0, 1], [1, 2], [3, 4]]

     0          3
     |          |
     1 --- 2    4

Output: 2

    Example 2:

    Input: n = 5 and edges = [[0, 1], [1, 2], [2, 3], [3, 4]]

     0           4
     |           |
     1 --- 2 --- 3

Output:  1

    Note:
        You can assume that no duplicate edges will appear in edges. Since all edges
        are undirected, [0, 1] is the same as [1, 0] and thus will not
        appear together in edges.
-----------------

# 1785_Minimum_Elements_to_Add_to_Form_a_Given_Sum
# 1785. Minimum Elements to Add to Form a Given Sum


-----------------

# 1509_Minimum_Difference_Between_Largest_and_Smallest_Value_in_Three_Moves
# 1509. Minimum Difference Between Largest and Smallest Value in Three Moves


-----------------

# 1184_Distance_Between_Bus_Stops
# 1184. Distance Between Bus Stops

A bus has n stops numbered from 0 to n - 1 that
        form a circle. We know the distance between all pairs of neighboring stops where distance[i]
        is the distance between the stops number i and (i + 1) % n.
    

    The bus goes along both directions i.e. clockwise and counterclockwise.

    Return the shortest distance between the given start and destination stops.
    

     
    Example 1:

    

    Input: distance = [1,2,3,4], start = 0, destination = 1
Output: 1
Explanation: Distance between 0 and 1 is 1 or 9, minimum is 1.

     

    Example 2:

    

    Input: distance = [1,2,3,4], start = 0, destination = 2
Output: 3
Explanation: Distance between 0 and 2 is 3 or 7, minimum is 3.

     

    Example 3:

    

    Input: distance = [1,2,3,4], start = 0, destination = 3
Output: 4
Explanation: Distance between 0 and 3 is 6 or 4, minimum is 4.

     
    Constraints:

    
        1 <= n <= 10^4
        distance.length == n
        0 <= start, destination < n
        0 <= distance[i] <= 10^4
-----------------

# 1662_Check_If_Two_String_Arrays_are_Equivalent
# 1662. Check If Two String Arrays are Equivalent


-----------------

# 202_Happy_Number
# 202. Happy Number

Write an algorithm to determine if a number is "happy".

    A happy number is a number defined by the following process: Starting with any positive
        integer, replace the number by the sum of the squares of its digits, and repeat the process
        until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does
        not include 1. Those numbers for which this process ends in 1 are happy numbers.

    Example: 

    Input: 19
Output: true
Explanation:
12 + 92 = 82
82 + 22 = 68
62 + 82 = 100
12 + 02 + 02 = 1
-----------------

# 541_Reverse_String_II
# 541. Reverse String II

Given a string and an integer k, you need to reverse the first k characters for every 2k
    characters counting from the start of the string. If there are less than k characters left,
    reverse all of them. If there are less than 2k but greater than or equal to k characters, then
    reverse the first k characters and left the other as original.
    

    Example:
    Input: s = "abcdefg", k = 2
Output: "bacdfeg"

    

    Restrictions: 
    
         The string consists of lower English letters only.
         Length of the given string and k will in the range [1, 10000]
-----------------

# 61_Rotate_List
# 61. Rotate List

Given a linked list, rotate the list to the right by k places, where k
        is non-negative.

    Example 1:

    Input: 1->2->3->4->5->NULL, k = 2
Output: 4->5->1->2->3->NULL
Explanation:
rotate 1 steps to the right: 5->1->2->3->4->NULL
rotate 2 steps to the right: 4->5->1->2->3->NULL

    Example 2:

    Input: 0->1->2->NULL, k = 4
Output: 2->0->1->NULL
Explanation:
rotate 1 steps to the right: 2->0->1->NULL
rotate 2 steps to the right: 1->2->0->NULL
rotate 3 steps to the right: 0->1->2->NULL
rotate 4 steps to the right: 2->0->1->NULL
-----------------

# 1353_Maximum_Number_of_Events_That_Can_Be_Attended
# 1353. Maximum Number of Events That Can Be Attended


-----------------

# 596_Classes_More_Than_5_Students
# 596. Classes More Than 5 Students

There is a table courses with columns: student and class

    Please list out all classes which have more than or equal to 5 students.

    For example, the table:

    +---------+------------+
| student | class      |
+---------+------------+
| A       | Math       |
| B       | English    |
| C       | Math       |
| D       | Biology    |
| E       | Math       |
| F       | Computer   |
| G       | Math       |
| H       | Math       |
| I       | Math       |
+---------+------------+

    Should output:

    +---------+
| class   |
+---------+
| Math    |
+---------+

     

    Note:
        The students should not be counted duplicate in each course.
-----------------

# 1006_Clumsy_Factorial
# 1006. Clumsy Factorial

Normally, the factorial of a positive integer n is the product of all
        positive integers less than or equal to n.  For example, factorial(10)
            = 10 * 9 * 8 * 7 * 6 * 5 * 4 * 3 * 2 * 1.

    We instead make a clumsy factorial: using the integers in decreasing order, we swap
        out the multiply operations for a fixed rotation of operations: multiply (*), divide
        (/), add (+) and subtract (-) in this order.

    For example, clumsy(10) = 10 * 9 / 8 + 7 - 6 * 5 / 4 + 3 - 2 * 1.  However,
        these operations are still applied using the usual order of operations of arithmetic: we do
        all multiplication and division steps before any addition or subtraction steps, and
        multiplication and division steps are processed left to right.

    Additionally, the division that we use is floor division such that 10
        * 9 / 8 equals 11.  This guarantees the result is an
        integer.

    Implement the clumsy function as
        defined above: given an integer N, it returns the clumsy factorial of
        N.

     

    Example 1:

    Input: 4
Output: 7
Explanation: 7 = 4 * 3 / 2 + 1

    Example 2:

    Input: 10
Output: 12
Explanation: 12 = 10 * 9 / 8 + 7 - 6 * 5 / 4 + 3 - 2 * 1

     

    Note:

    
        1 <= N <= 10000
        -2^31 <= answer <= 2^31 - 1  (The answer is guaranteed to fit
            within a 32-bit integer.)
-----------------

# 1429_First_Unique_Number
# 1429. First Unique Number


-----------------

# 1040_Moving_Stones_Until_Consecutive_II
# 1040. Moving Stones Until Consecutive II

On an infinite number line, the position of the i-th stone is given by stones[i]. 
        Call a stone an endpoint stone if it has the smallest or largest position.

    Each turn, you pick up an endpoint stone and move it to an unoccupied position so that it is
        no longer an endpoint stone.

    In particular, if the stones are at say, stones = [1,2,5], you cannot
        move the endpoint stone at position 5, since moving it to any position (such as 0, or 3)
        will still keep that stone as an endpoint stone.

    The game ends when you cannot make any more moves, ie. the stones are in consecutive
        positions.

    When the game ends, what is the minimum and maximum number of moves that you could have made? 
        Return the answer as an length 2 array: answer = [minimum_moves,
            maximum_moves]

     

    Example 1:

    Input: [7,4,9]
Output: [1,2]
Explanation: 
We can move 4 -> 8 for one move to finish the game.
Or, we can move 9 -> 5, 4 -> 6 for two moves to finish the game.
-----------------

# 406_Queue_Reconstruction_by_Height
# 406. Queue Reconstruction by Height

Suppose you have a random list of people standing in a queue. Each person is described by a
        pair of integers (h, k), where h is the height of the person and
        k is the number of people in front of this person who have a height greater
        than or equal to h. Write an algorithm to reconstruct the queue.

    Note:
        The number of people is less than 1,100.
     

    Example

    Input:
[[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]

Output:
[[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]]
-----------------

# 440_K-th_Smallest_in_Lexicographical_Order
# 440. K-th Smallest in Lexicographical Order

Given integers n and k, find the lexicographically k-th smallest
        integer in the range from 1 to n.

    Note: 1 ≤ k ≤ n ≤ 109.

    Example:
    Input:
n: 13   k: 2

Output:
10

Explanation:
The lexicographical order is [1, 10, 11, 12, 13, 2, 3, 4, 5, 6, 7, 8, 9], so the second smallest number is 10.
-----------------

# 1325_1325._Delete_Leaves_With_a_Given_Value
# 1325. 1325. Delete Leaves With a Given Value


-----------------

# 109_Convert_Sorted_List_to_Binary_Search_Tree
# 109. Convert Sorted List to Binary Search Tree

Given a singly linked list where elements are sorted in ascending order, convert it to a
        height balanced BST.

    For this problem, a height-balanced binary tree is defined as a binary tree in which the
        depth of the two subtrees of every node never differ by more than 1.

    Example:

    Given the sorted linked list: [-10,-3,0,5,9],

One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST:

      0
     / \
   -3   9
   /   /
 -10  5
-----------------

# 1696_Jump_Game_VI
# 1696. Jump Game VI


-----------------

# 268_Missing_Number
# 268. Missing Number

Given an array containing n distinct numbers taken from 0, 1, 2, ..., n,
        find the one that is missing from the array.

    Example 1:

    Input: [3,0,1]
Output: 2

    Example 2:

    Input: [9,6,4,2,3,5,7,0,1]
Output: 8

    Note:
        Your algorithm should run in linear runtime complexity. Could you implement it using only
        constant extra space complexity?
-----------------

# 1769_Minimum_Number_of_Operations_to_Move_All_Balls_to_Each_Box
# 1769. Minimum Number of Operations to Move All Balls to Each Box


-----------------

# 722_Remove_Comments
# 722. Remove Comments

Given a C++ program, remove comments from it. The program source is an array
        where source[i] is the i-th line of the source code. This
        represents the result of splitting the original source code string by the newline character
        \n.

    In C++, there are two types of comments, line comments, and block comments.
    
        The string // denotes a line comment, which represents that it and rest of the
        characters to the right of it in the same line should be ignored.
    
    
        The string /* denotes a block comment, which represents that all characters
        until the next (non-overlapping) occurrence of */ should be ignored. (Here,
        occurrences happen in reading order: line by line from left to right.) To be clear, the
        string /*/ does not yet end the block comment, as the ending would be
        overlapping the beginning.
    
    
        The first effective comment takes precedence over others: if the string //
        occurs in a block comment, it is ignored. Similarly, if the string /* occurs in
        a line or block comment, it is also ignored.
    
    
        If a certain line of code is empty after removing comments, you must not output that line:
        each string in the answer list will be non-empty.
    
    
        There will be no control characters, single quote, or double quote characters. For example,
        source = "string s = "/* Not a comment. */";" will not be a test case. (Also,
        nothing else such as defines or macros will interfere with the comments.)
    
    
        It is guaranteed that every open block comment will eventually be closed, so /*
        outside of a line or block comment always starts a new comment.
    
    
        Finally, implicit newline characters can be deleted by block comments. Please see the
        examples below for details.
    

    After removing the comments from the source code, return the source code in the same
        format.

    Example 1:
    Input:
source = ["/*Test program */", "int main()", "{ ", "  // variable declaration ", "int a, b, c;", "/* This is a test", "   multiline  ", "   comment for ", "   testing */", "a = b + c;", "}"]

The line by line code is visualized as below:
/*Test program */
int main()
{
  // variable declaration
int a, b, c;
/* This is a test
   multiline
   comment for
   testing */
a = b + c;
}

Output: ["int main()","{ ","  ","int a, b, c;","a = b + c;","}"]

The line by line code is visualized as below:
int main()
{

int a, b, c;
a = b + c;
}

Explanation:
The string /* denotes a block comment, including line 1 and lines 6-9. The string // denotes line 4 as comments.

    

    Example 2:
    Input:
source = ["a/*comment", "line", "more_comment*/b"]
Output: ["ab"]
Explanation: The original source string is "a/*comment\nline\nmore_comment*/b", where we have bolded the newline characters.  After deletion, the implicit newline characters are deleted, leaving the string "ab", which when delimited by newline characters becomes ["ab"].

    

    Note:
    The length of source is in the range [1, 100].
    The length of source[i] is in the range [0, 80].
    Every open block comment is eventually closed.
    There are no single-quote, double-quote, or control characters in the source code.
-----------------

# 937_Reorder_Data_in_Log_Files
# 937. Reorder Data in Log Files

You have an array of logs.  Each log is a space delimited string of words.
    

    For each log, the first word in each log is an alphanumeric identifier.  Then,
        either:

    
        Each word after the identifier will consist only of lowercase letters, or;
        Each word after the identifier will consist only of digits.
    

    We will call these two varieties of logs letter-logs and digit-logs. 
        It is guaranteed that each log has at least one word after its identifier.

    Reorder the logs so that all of the letter-logs come before any digit-log.  The
        letter-logs are ordered lexicographically ignoring identifier, with the identifier used in
        case of ties.  The digit-logs should be put in their original order.

    Return the final order of the logs.

     
    Example 1:
    Input: logs = ["dig1 8 1 5 1","let1 art can","dig2 3 6","let2 own kit dig","let3 art zero"]
Output: ["let1 art can","let3 art zero","let2 own kit dig","dig1 8 1 5 1","dig2 3 6"]

     
    Constraints:

    
        0 <= logs.length <= 100
        3 <= logs[i].length <= 100
        logs[i] is guaranteed to have an identifier, and a word after the
            identifier.
-----------------

# 616_Add_Bold_Tag_in_String
# 616. Add Bold Tag in String

Given a string s and a list of strings dict, you need to add a closed pair of bold
    tag <b> and </b> to wrap the substrings in s that exist in
    dict. If two such substrings overlap, you need to wrap them together by only one pair of closed
    bold tag. Also, if two substrings wrapped by bold tags are consecutive, you need to combine
    them.

    Example 1:
    Input:
s = "abcxyz123"
dict = ["abc","123"]
Output:
"<b>abc</b>xyz<b>123</b>"

    

    Example 2:
    Input:
s = "aaabbcc"
dict = ["aaa","aab","bc"]
Output:
"<b>aaabbc</b>c"

    

    Note:
    
        The given dict won't contain duplicates, and its length won't exceed 100.
        All the strings in input have length in range [1, 1000].
-----------------

# 1789_Primary_Department_for_Each_Employee
# 1789. Primary Department for Each Employee


-----------------

# 1565_Unique_Orders_and_Customers_Per_Month
# 1565. Unique Orders and Customers Per Month


-----------------

# 1067_Digit_Count_in_Range
# 1067. Digit Count in Range

Given an integer d between 0 and 9, and two positive
    integers low and high as lower and upper bounds, respectively. Return
    the number of times that d occurs as a digit in all integers between
    low and high, including the bounds low and
    high.
     

    Example 1:

    Input: d = 1, low = 1, high = 13
Output: 6
Explanation: 
The digit d=1 occurs 6 times in 1,10,11,12,13. Note that the digit d=1 occurs twice in the number 11.
-----------------

# 591_Tag_Validator
# 591. Tag Validator

Given a string representing a code snippet, you need to implement a tag validator to parse
        the code and return whether it is valid. A code snippet is valid if all the following rules
        hold:
    
    
        The code must be wrapped in a valid closed tag. Otherwise, the code is invalid.
        
        A closed tag (not necessarily valid) has exactly the following format : <TAG_NAME>TAG_CONTENT</TAG_NAME>.
            Among them, <TAG_NAME> is the start tag, and
            </TAG_NAME> is the end tag. The TAG_NAME in start and end tags should
            be the same. A closed tag is valid if and only if the TAG_NAME and TAG_CONTENT
            are valid.
        
        A valid TAG_NAME only contain upper-case letters, and has
            length in range [1,9]. Otherwise, the TAG_NAME is invalid.
        
        A valid TAG_CONTENT may contain other valid closed tags, cdata
            and any characters (see note1) EXCEPT unmatched <, unmatched
            start and end tag, and unmatched or closed tags with invalid TAG_NAME. Otherwise, the
            TAG_CONTENT is invalid.
        
        A start tag is unmatched if no end tag exists with the same TAG_NAME, and vice versa.
            However, you also need to consider the issue of unbalanced when tags are nested.
        
        A < is unmatched if you cannot find a subsequent >. And
            when you find a < or </, all the subsequent characters
            until the next > should be parsed as TAG_NAME (not necessarily valid).
        
        The cdata has the following format : <![CDATA[CDATA_CONTENT]]>. The
            range of CDATA_CONTENT is defined as the characters between <![CDATA[
            and the first subsequent ]]>.
        
        CDATA_CONTENT may contain any characters. The function of cdata is
            to forbid the validator to parse CDATA_CONTENT, so even it has some
            characters that can be parsed as tag (no matter valid or invalid), you should treat it
            as regular characters.
        
    

    Valid Code Examples:
    Input: "<DIV>This is the first line <![CDATA[<div>]]></DIV>"
Output: True
Explanation: 
The code is wrapped in a closed tag : <DIV> and </DIV>. 
The TAG_NAME is valid, the TAG_CONTENT consists of some characters and cdata. 
Although CDATA_CONTENT has unmatched start tag with invalid TAG_NAME, it should be considered as plain text, not parsed as tag.
So TAG_CONTENT is valid, and then the code is valid. Thus return true.

Input: "<DIV>>>  ![cdata[]] <![CDATA[<div>]>]]>]]>>]</DIV>"
Output: True
Explanation:
We first separate the code into : start_tag|tag_content|end_tag.
start_tag -> "<DIV>"
end_tag -> "</DIV>"
tag_content could also be separated into : text1|cdata|text2.
text1 -> ">>  ![cdata[]] "
cdata -> "<![CDATA[<div>]>]]>", where the CDATA_CONTENT is "<div>]>"
text2 -> "]]>>]"

The reason why start_tag is NOT "<DIV>>>" is because of the rule 6.
The reason why cdata is NOT "<![CDATA[<div>]>]]>]]>" is because of the rule 7.

    

    Invalid Code Examples:
    Input: "<A>  <B> </A>   </B>"
Output: False
Explanation: Unbalanced. If "<A>" is closed, then "<B>" must be unmatched, and vice versa.

Input: "<DIV>  div tag is not closed  <DIV>"
Output: False

Input: "<DIV>  unmatched <  </DIV>"
Output: False

Input: "<DIV> closed tags with invalid tag name  <b>123</b> </DIV>"
Output: False

Input: "<DIV> unmatched tags with invalid tag name  </1234567890> and <CDATA[[]]>  </DIV>"
Output: False

Input: "<DIV>  unmatched start tag <B>  and unmatched end tag </C>  </DIV>"
Output: False

    

    Note:
    
        For simplicity, you could assume the input code (including the any characters
            mentioned above) only contain letters, digits,
            '<','>','/','!','[',']'
            and ' '.
-----------------

# 1551_Minimum_Operations_to_Make_Array_Equal
# 1551. Minimum Operations to Make Array Equal


-----------------

# 642_Design_Search_Autocomplete_System
# 642. Design Search Autocomplete System

Design a search autocomplete system for a search engine. Users may input a sentence (at least
        one word and end with a special character '#'). For each
            character they type except '#', you need to return the top 3
        historical hot sentences that have prefix the same as the part of sentence already typed.
        Here are the specific rules:

    
        The hot degree for a sentence is defined as the number of times a user typed the exactly
            same sentence before.
        
        The returned top 3 hot sentences should be sorted by hot degree (The first is the
            hottest one). If several sentences have the same degree of hot, you need to use
            ASCII-code order (smaller one appears first).
        
        If less than 3 hot sentences exist, then just return as many as you can.
        When the input is a special character, it means the sentence ends, and in this case, you
            need to return an empty list.
        
    

    Your job is to implement the following functions:

    The constructor function:

    AutocompleteSystem(String[] sentences, int[] times): This is the constructor.
        The input is historical data. Sentences is a string array consists of
        previously typed sentences. Times is the corresponding times a sentence has
        been typed. Your system should record these historical data.

    Now, the user wants to input a new sentence. The following function will provide the next
        character the user types:

    List<String> input(char c): The input c is the next character
        typed by the user. The character will only be lower-case letters ('a'
        to 'z'), blank space (' ') or a special character
        ('#'). Also, the previously typed sentence should be recorded in your
        system. The output will be the top 3 historical hot sentences that have prefix the
        same as the part of sentence already typed.
     

    Example:
        Operation: AutocompleteSystem(["i love you", "island","ironman",
        "i love leetcode"], [5,3,2,2])
        The system have already tracked down the following sentences and their corresponding
        times:
        "i love you" : 5 times
        "island" : 3 times
        "ironman" : 2 times
        "i love leetcode" : 2 times
        Now, the user begins another search:
        
        Operation: input('i')
        Output: ["i love you", "island","i love leetcode"]
        Explanation:
        There are four sentences that have prefix "i". Among them, "ironman"
        and "i love leetcode" have same hot degree. Since ' ' has
        ASCII code 32 and 'r' has ASCII code 114, "i love leetcode"
        should be in front of "ironman". Also we only need to output top 3 hot sentences,
        so "ironman" will be ignored.
        
        Operation: input(' ')
        Output: ["i love you","i love leetcode"]
        Explanation:
        There are only two sentences that have prefix "i ".
        
        Operation: input('a')
        Output: []
        Explanation:
        There are no sentences that have prefix "i a".
        
        Operation: input('#')
        Output: []
        Explanation:
        The user finished the input, the sentence "i a" should be saved as a
        historical sentence in system. And the following input will be counted as a new search.
     

    Note:

    
        The input sentence will always start with a letter and end with '#', and only
            one blank space will exist between two words.
        
        The number of complete sentences that to be searched won't exceed 100. The
            length of each sentence including those in the historical data won't exceed 100.
        
        Please use double-quote instead of single-quote when you write test cases even for a
            character input.
        
        Please remember to RESET your class variables declared in class
            AutocompleteSystem, as static/class variables are persisted across multiple test
                cases. Please see here
            for more details.
-----------------

# 1217_Play_with_Chips
# 1217. Play with Chips

There are some chips, and the i-th chip is at position chips[i].

    You can perform any of the two following types of moves any number of times
        (possibly zero) on any chip:

    
        Move the i-th chip by 2 units to the left or to the right with a
            cost of 0.
        
        Move the i-th chip by 1 unit to the left or to the right
            with a cost of 1.
        
    

    There can be two or more chips at the same position initially.

    Return the minimum cost needed to move all the chips to the same position (any
        position).

     
    Example 1:

    Input: chips = [1,2,3]
Output: 1
Explanation: Second chip will be moved to positon 3 with cost 1. First chip will be moved to position 3 with cost 0. Total cost is 1.

    Example 2:

    Input: chips = [2,2,2,3,3]
Output: 2
Explanation: Both fourth and fifth chip will be moved to position two with cost 1. Total minimum cost will be 2.

     
    Constraints:

    
        1 <= chips.length <= 100
        1 <= chips[i] <= 10^9
-----------------

# 1362_Closest_Divisors
# 1362. Closest Divisors


-----------------

# 1109_Corporate_Flight_Bookings
# 1109. Corporate Flight Bookings

There are n flights, and they are labeled from 1 to
        n.

    We have a list of flight bookings.  The i-th booking bookings[i]
        = [i, j, k] means that we booked k seats from flights labeled
        i to j inclusive.

    Return an array answer of length n, representing the number of
        seats booked on each flight in order of their label.

     
    Example 1:

    Input: bookings = [[1,2,10],[2,3,20],[2,5,25]], n = 5
Output: [10,55,45,25,25]

     
    Constraints:

    
        1 <= bookings.length <= 20000
        1 <= bookings[i][0] <= bookings[i][1] <= n <= 20000
        1 <= bookings[i][2] <= 10000
-----------------

# 80_Remove_Duplicates_from_Sorted_Array_II
# 80. Remove Duplicates from Sorted Array II

Given a sorted array nums, remove the duplicates in-place such that duplicates appeared at most twice
        and return the new length.

    Do not allocate extra space for another array, you must do this by modifying the
        input array in-place
        with O(1) extra memory.

    Example 1:

    Given nums = [1,1,1,2,2,3],

Your function should return length = 5, with the first five elements of nums being 1, 1, 2, 2 and 3 respectively.

It doesn't matter what you leave beyond the returned length.

    Example 2:

    Given nums = [0,0,1,1,1,1,2,3,3],

Your function should return length = 7, with the first seven elements of nums being modified to 0, 0, 1, 1, 2, 3 and 3 respectively.

It doesn't matter what values are set beyond the returned length.

    Clarification:

    Confused why the returned value is an integer but your answer is an array?

    Note that the input array is passed in by reference, which means
        modification to the input array will be known to the caller as well.

    Internally you can think of this:

    // nums is passed in by reference. (i.e., without making a copy)
int len = removeDuplicates(nums);

// any modification to nums in your function would be known by the caller.
// using the length returned by your function, it prints the first len elements.
for (int i = 0; i < len; i++) {
    print(nums[i]);
}
-----------------

# 945_Minimum_Increment_to_Make_Array_Unique
# 945. Minimum Increment to Make Array Unique

Given an array of integers A, a move consists of choosing any A[i], and
        incrementing it by 1.

    Return the least number of moves to make every value in A unique.

     

    Example 1:

    Input: [1,2,2]
Output: 1
Explanation:  After 1 move, the array could be [1, 2, 3].
-----------------

# 527_Word_Abbreviation
# 527. Word Abbreviation

Given an array of n distinct non-empty strings, you need to generate minimal possible
        abbreviations for every word following rules below.

    
        Begin with the first character and then the number of characters abbreviated, which
            followed by the last character.
        
        If there are any conflict, that is more than one words share the same abbreviation, a
            longer prefix is used instead of only the first character until making the map from word
            to abbreviation become unique. In other words, a final abbreviation cannot map to more
            than one original words.
        
         If the abbreviation doesn't make the word shorter, then keep it as original.
    

    Example:
    Input: ["like", "god", "internal", "me", "internet", "interval", "intension", "face", "intrusion"]
Output: ["l2e","god","internal","me","i6t","interval","inte4n","f2e","intr4n"]

    

    Note:
    
         Both n and the length of each word will not exceed 400.
         The length of each word is greater than 1.
         The words consist of lowercase English letters only.
         The return answers should be in the same order as the original array.
-----------------

# 809_Expressive_Words
# 809. Expressive Words

Sometimes people repeat letters to represent extra feeling, such as "hello" ->
        "heeellooo", "hi" -> "hiiii".  In these strings like
        "heeellooo", we have groups of adjacent letters that are all the same: 
        "h", "eee", "ll", "ooo".

    For some given string S, a query word is stretchy if it can be made to
        be equal to S by any number of applications of the following extension
        operation: choose a group consisting of characters c, and add some number
        of characters c to the group so that the size of the group is 3 or more.

    For example, starting with "hello", we could do an extension on the group "o"
        to get "hellooo", but we cannot get "helloo" since the group "oo"
        has size less than 3.  Also, we could do another extension like "ll" ->
        "lllll" to get "helllllooo".  If S =
            "helllllooo", then the query word "hello" would be stretchy
        because of these two extension operations: query = "hello" -> "hellooo"
            -> "helllllooo" = S.

    Given a list of query words, return the number of words that are stretchy. 

     

    Example:
Input:
S = "heeellooo"
words = ["hello", "hi", "helo"]
Output: 1
Explanation:
We can extend "e" and "o" in the word "hello" to get "heeellooo".
We can't extend "helo" to get "heeellooo" because the group "ll" is not size 3 or more.

     

    Notes: 

    
        0 <= len(S) <= 100.
        0 <= len(words) <= 100.
        0 <= len(words[i]) <= 100.
        S and all words in words consist only of lowercase
            letters
-----------------

# 711_Number_of_Distinct_Islands_II
# 711. Number of Distinct Islands II

Given a non-empty 2D array grid of 0's and 1's, an island is a group of
        1's (representing land) connected 4-directionally (horizontal or vertical.) You
        may assume all four edges of the grid are surrounded by water.

    Count the number of distinct islands. An island is considered to be the same as
        another if they have the same shape, or have the same shape after rotation (90, 180,
        or 270 degrees only) or reflection (left/right direction or up/down direction).

    Example 1:
    11000
10000
00001
00011

    Given the above grid map, return 1.
    
    Notice that:
    11
1

    and
     1
11

    are considered same island shapes. Because if we make a 180 degrees clockwise rotation on
    the first island, then two islands will have the same shapes.
    

    Example 2:
    11100
10001
01001
01110
    Given the above grid map, return 2.
    
    Here are the two distinct islands:
    111
1

    and
    1
1

    
    Notice that:
    111
1

    and
    1
111

    are considered same island shapes. Because if we flip the first array in the up/down
    direction, then they have the same shapes.
    

    Note:
        The length of each dimension in the given grid does not exceed 50.
-----------------

# 863_All_Nodes_Distance_K_in_Binary_Tree
# 863. All Nodes Distance K in Binary Tree

We are given a binary tree (with root node root), a target
        node, and an integer value K.

    Return a list of the values of all nodes that have a distance K from the
        target node.  The answer can be returned in any order.
-----------------

# 1533_Find_the_Index_of_the_Large_Integer
# 1533. Find the Index of the Large Integer


-----------------

# 1018_Binary_Prefix_Divisible_By_5
# 1018. Binary Prefix Divisible By 5

Given an array A of 0s and 1s, consider
        N_i: the i-th subarray from A[0] to A[i] interpreted as
        a binary number (from most-significant-bit to least-significant-bit.)

    Return a list of booleans answer, where answer[i] is true if
        and only if N_i is divisible by 5.

    Example 1:

    Input: [0,1,1]
Output: [true,false,false]
Explanation: 
The input numbers in binary are 0, 01, 011; which are 0, 1, and 3 in base-10.  Only the first number is divisible by 5, so answer[0] is true.

    Example 2:

    Input: [1,1,1]
Output: [false,false,false]

    Example 3:

    Input: [0,1,1,1,1,1]
Output: [true,false,false,false,true,false]

    Example 4:

    Input: [1,1,1,0,1]
Output: [false,false,false,false,false]

     

    Note:

    
        1 <= A.length <= 30000
        A[i] is 0 or 1
-----------------

# 1445_Apples_&_Oranges
# 1445. Apples & Oranges


-----------------

# 1016_Binary_String_With_Substrings_Representing_1_To_N
# 1016. Binary String With Substrings Representing 1 To N

Given a binary string S (a string consisting only of '0' and '1's)
        and a positive integer N, return true if and only if for every integer X from 1
        to N, the binary representation of X is a substring of S.

     

    Example 1:

    Input: S = "0110", N = 3
Output: true

    Example 2:

    Input: S = "0110", N = 4
Output: false

     

    Note:

    
        1 <= S.length <= 1000
        1 <= N <= 10^9
-----------------

# 23_Merge_k_Sorted_Lists
# 23. Merge k Sorted Lists

Merge k sorted linked lists and return it as one sorted list. Analyze and describe
        its complexity.

    Example:

    Input:
[
  1->4->5,
  1->3->4,
  2->6
]
Output: 1->1->2->3->4->4->5->6
-----------------

# 238_Product_of_Array_Except_Self
# 238. Product of Array Except Self

Given an array nums of n integers where n > 1,  return
        an array output such that output[i] is equal to the product of all
        the elements of nums except nums[i].

    Example:

    Input:  [1,2,3,4]
Output: [24,12,8,6]

    Note: Please solve it without division and in O(n).
    

    Follow up:
        Could you solve it with constant space complexity? (The output array does
            not count as extra space for the purpose of space complexity analysis.)
-----------------

# 1630_Arithmetic_Subarrays
# 1630. Arithmetic Subarrays


-----------------

# 1234_Replace_the_Substring_for_Balanced_String
# 1234. Replace the Substring for Balanced String

You are given a string containing only 4 kinds of characters 'Q',
        'W', 'E' and 'R'.

    A string is said to be balanced if each of its characters
        appears n/4 times where n is the length of the string.

    Return the minimum length of the substring that can be replaced with any
        other string of the same length to make the original string s balanced.
    

    Return 0 if the string is already balanced.

     
    Example 1:

    Input: s = "QWER"
Output: 0
Explanation: s is already balanced.

    Example 2:

    Input: s = "QQWE"
Output: 1
Explanation: We need to replace a 'Q' to 'R', so that "RQWE" (or "QRWE") is balanced.

    Example 3:

    Input: s = "QQQW"
Output: 2
Explanation: We can replace the first "QQ" to "ER".

    Example 4:

    Input: s = "QQQQ"
Output: 3
Explanation: We can replace the last 3 'Q' to make s = "QWER".

     
    Constraints:

    
        1 <= s.length <= 10^5
        s.length is a multiple of 4
        s contains only 'Q', 'W',
            'E' and 'R'.
-----------------

# 840_Magic_Squares_In_Grid
# 840. Magic Squares In Grid

A 3 x 3 magic square is a 3 x 3 grid filled with distinct numbers from 1 to
        9 such that each row, column, and both diagonals all have the same sum.

    Given an grid of integers, how many 3 x 3 "magic square" subgrids
        are there?  (Each subgrid is contiguous).

     

    Example 1:

    Input: [[4,3,8,4],
        [9,5,1,9],
        [2,7,6,2]]
Output: 1
Explanation: 
The following subgrid is a 3 x 3 magic square:
438
951
276

while this one is not:
384
519
762

In total, there is only one magic square inside the given grid.

    Note:

    
        1 <= grid.length <= 10
        1 <= grid[0].length <= 10
        0 <= grid[i][j] <= 15
-----------------

# 941_Valid_Mountain_Array
# 941. Valid Mountain Array

Given an array A of integers, return true if and only if it is a
        valid mountain array.

    Recall that A is a mountain array if and only if:

    
        A.length >= 3
        There exists some i with 0 < i < A.length - 1 such
            that:
            
                A[0] < A[1] < ... A[i-1] < A[i] 
                A[i] > A[i+1] > ... > A[A.length - 1]
            
        
    

     

    Example 1:

    Input: [2,1]
Output: false
-----------------

# 1332_Remove_Palindromic_Subsequences
# 1332. Remove Palindromic Subsequences


-----------------

# 1082_Sales_Analysis_I
# 1082. Sales Analysis I

Table: Product

    +--------------+---------+
| Column Name  | Type    |
+--------------+---------+
| product_id   | int     |
| product_name | varchar |
| unit_price   | int     |
+--------------+---------+
product_id is the primary key of this table.

    Table: Sales

    +-------------+---------+
| Column Name | Type    |
+-------------+---------+
| seller_id   | int     |
| product_id  | int     |
| buyer_id    | int     |
| sale_date   | date    |
| quantity    | int     |
| price       | int     |
+------ ------+---------+
This table has no primary key, it can have repeated rows.
product_id is a foreign key to Product table.

     

    Write an SQL query that reports the best seller by total sales
        price, If there is a tie, report them all.

    The query result format is in the following example:

    Product table:
+------------+--------------+------------+
| product_id | product_name | unit_price |
+------------+--------------+------------+
| 1          | S8           | 1000       |
| 2          | G4           | 800        |
| 3          | iPhone       | 1400       |
+------------+--------------+------------+

Sales table:
+-----------+------------+----------+------------+----------+-------+
| seller_id | product_id | buyer_id | sale_date  | quantity | price |
+-----------+------------+----------+------------+----------+-------+
| 1         | 1          | 1        | 2019-01-21 | 2        | 2000  |
| 1         | 2          | 2        | 2019-02-17 | 1        | 800   |
| 2         | 2          | 3        | 2019-06-02 | 1        | 800   |
| 3         | 3          | 4        | 2019-05-13 | 2        | 2800  |
+-----------+------------+----------+------------+----------+-------+

Result table:
+-------------+
| seller_id   |
+-------------+
| 1           |
| 3           |
+-------------+
Both sellers with id 1 and 3 sold products with the most total price of 2800.
-----------------

# 1842_Next_Palindrome_Using_Same_Digits
# 1842. Next Palindrome Using Same Digits


-----------------

# 866_Prime_Palindrome
# 866. Prime Palindrome

Find the smallest prime palindrome greater than or equal to N.

    Recall that a number is prime if it's only divisors are 1 and itself, and
        it is greater than 1. 

    For example, 2,3,5,7,11 and 13 are primes.

    Recall that a number is a palindrome if it reads the same from left to right as it
        does from right to left. 

    For example, 12321 is a palindrome.
-----------------

# 1392_Longest_Happy_Prefix
# 1392. Longest Happy Prefix


-----------------

# 1665_Minimum_Initial_Energy_to_Finish_Tasks
# 1665. Minimum Initial Energy to Finish Tasks


-----------------

# 234_Palindrome_Linked_List
# 234. Palindrome Linked List

Given a singly linked list, determine if it is a palindrome.

    Example 1:

    Input: 1->2
Output: false

    Example 2:

    Input: 1->2->2->1
Output: true

    Follow up:
        Could you do it in O(n) time and O(1) space?
-----------------

# 171_Excel_Sheet_Column_Number
# 171. Excel Sheet Column Number

Given a column title as appear in an Excel sheet, return its corresponding column number.

    For example:

        A -> 1
    B -> 2
    C -> 3
    ...
    Z -> 26
    AA -> 27
    AB -> 28
    ...

    Example 1:

    Input: "A"
Output: 1

    Example 2:

    Input: "AB"
Output: 28

    Example 3:

    Input: "ZY"
Output: 701
-----------------

# 912_Sort_an_Array
# 912. Sort an Array

Given an array of integers nums, sort the array in ascending order.

     

    
    

    Example 1:

    Input: [5,2,3,1]
Output: [1,2,3,5]

    Example 2:

    Input: [5,1,1,2,0,0]
Output: [0,0,1,1,2,5]

     

    Note:

    
        1 <= A.length <= 10000
        -50000 <= A[i] <= 50000
-----------------

# 1268_Search_Suggestions_System
# 1268. Search Suggestions System


-----------------

# 1531_String_Compression_II
# 1531. String Compression II


-----------------

# 319_Bulb_Switcher
# 319. Bulb Switcher

There are n bulbs that are initially off. You first turn on all the bulbs. Then, you
        turn off every second bulb. On the third round, you toggle every third bulb (turning on if
        it's off or turning off if it's on). For the i-th round, you toggle every i
        bulb. For the n-th round, you only toggle the last bulb. Find how many bulbs are on
        after n rounds.

    Example:

    Input: 3
Output: 1
Explanation:
At first, the three bulbs are [off, off, off].
After first round, the three bulbs are [on, on, on].
After second round, the three bulbs are [on, off, on].
After third round, the three bulbs are [on, off, off].

So you should return 1, because there is only one bulb is on.
-----------------

# 1462_Course_Schedule_IV
# 1462. Course Schedule IV


-----------------

# 1228_Missing_Number_In_Arithmetic_Progression
# 1228. Missing Number In Arithmetic Progression

In some array arr, the values were in arithmetic progression: the
        values arr[i+1] - arr[i] are all equal for every 0
            <= i < arr.length - 1.

    Then, a value from arr was removed that was not the first or
        last value in the array.

    Return the removed value.

     
    Example 1:

    Input: arr = [5,7,11,13]
Output: 9
Explanation: The previous array was [5,7,9,11,13].

    Example 2:

    Input: arr = [15,13,12]
Output: 14
Explanation: The previous array was [15,14,13,12].

     
    Constraints:

    
        3 <= arr.length <= 1000
        0 <= arr[i] <= 10^5
-----------------

# 1091_Shortest_Path_in_Binary_Matrix
# 1091. Shortest Path in Binary Matrix

In an N by N square grid, each cell is either empty (0) or blocked (1).

    A clear path from top-left to bottom-right has length k
        if and only if it is composed of cells C_1, C_2, ..., C_k such that:

    
        Adjacent cells C_i and C_{i+1} are connected 8-directionally
            (ie., they are different and share an edge or corner)
        
        C_1 is at location (0, 0) (ie. has value
            grid[0][0])
        
        C_k is at location (N-1, N-1) (ie. has value grid[N-1][N-1])
        
        If C_i is located at (r, c), then grid[r][c]
            is empty (ie. grid[r][c] == 0).
        
    

    Return the length of the shortest such clear path from top-left to bottom-right.  If
        such a path does not exist, return -1.

     

    Example 1:

    Input: [[0,1],[1,0]]

Output: 2
-----------------

# 1212_Team_Scores_in_Football_Tournament
# 1212. Team Scores in Football Tournament

Table: Teams

    +---------------+----------+
| Column Name   | Type     |
+---------------+----------+
| team_id       | int      |
| team_name     | varchar  |
+---------------+----------+
team_id is the primary key of this table.
Each row of this table represents a single football team.

    Table: Matches

    +---------------+---------+
| Column Name   | Type    |
+---------------+---------+
| match_id      | int     |
| host_team     | int     |
| guest_team    | int     |
| host_goals    | int     |
| guest_goals   | int     |
+---------------+---------+
match_id is the primary key of this table.
Each row is a record of a finished match between two different teams.
Teams host_team and guest_team are represented by their IDs in the teams table (team_id) and they scored host_goals and guest_goals goals respectively.

     
    You would like to compute the scores of all teams after all matches. Points are awarded as
    follows:

    
        A team receives three points if they win a match (Score strictly more goals
            than the opponent team).
        
        A team receives one point if they draw a match (Same number of goals as the
            opponent team).
        
        A team receives no points if they lose a match (Score less goals than the opponent
            team).
        
    

    Write an SQL query that selects the team_id, team_name and
        num_points of each team in the tournament after all described matches.
        Result table should be ordered by num_points (decreasing order). In case of
        a tie, order the records by team_id (increasing order).

    The query result format is in the following example:

    Teams table:
+-----------+--------------+
| team_id   | team_name    |
+-----------+--------------+
| 10        | Leetcode FC  |
| 20        | NewYork FC   |
| 30        | Atlanta FC   |
| 40        | Chicago FC   |
| 50        | Toronto FC   |
+-----------+--------------+

Matches table:
+------------+--------------+---------------+-------------+--------------+
| match_id   | host_team    | guest_team    | host_goals  | guest_goals  |
+------------+--------------+---------------+-------------+--------------+
| 1          | 10           | 20            | 3           | 0            |
| 2          | 30           | 10            | 2           | 2            |
| 3          | 10           | 50            | 5           | 1            |
| 4          | 20           | 30            | 1           | 0            |
| 5          | 50           | 30            | 1           | 0            |
+------------+--------------+---------------+-------------+--------------+

Result table:
+------------+--------------+---------------+
| team_id    | team_name    | num_points    |
+------------+--------------+---------------+
| 10         | Leetcode FC  | 7             |
| 20         | NewYork FC   | 3             |
| 50         | Toronto FC   | 3             |
| 30         | Atlanta FC   | 1             |
| 40         | Chicago FC   | 0             |
+------------+--------------+---------------+
-----------------

# 673_Number_of_Longest_Increasing_Subsequence
# 673. Number of Longest Increasing Subsequence

Given an unsorted array of integers, find the number of longest increasing subsequence.
    

    Example 1:
    Input: [1,3,5,4,7]
Output: 2
Explanation: The two longest increasing subsequence are [1, 3, 4, 7] and [1, 3, 5, 7].

    

    Example 2:
    Input: [2,2,2,2,2]
Output: 5
Explanation: The length of longest continuous increasing subsequence is 1, and there are 5 subsequences' length is 1, so output 5.

    

    Note:
        Length of the given array will be not exceed 2000 and the answer is guaranteed to be fit in
        32-bit signed int.
-----------------

# 704_Binary_Search
# 704. Binary Search

Given a sorted (in ascending order) integer array nums of
        n elements and a target value, write a function to search target
        in nums. If target exists, then return its index, otherwise return
        -1.

    
        Example 1:

    Input: nums = [-1,0,3,5,9,12], target = 9
Output: 4
Explanation: 9 exists in nums and its index is 4

    Example 2:

    Input: nums = [-1,0,3,5,9,12], target = 2
Output: -1
Explanation: 2 does not exist in nums so return -1

     

    Note:

    
        You may assume that all elements in nums are unique.
        n will be in the range [1, 10000].
        The value of each element in nums will be in the range [-9999,
            9999].
-----------------

# 1125_Smallest_Sufficient_Team
# 1125. Smallest Sufficient Team

In a project, you have a list of required skills req_skills, and a list of
        people.  The i-th person people[i] contains a list of
        skills that person has.

    Consider a sufficient team: a set of people such that for every required skill in
        req_skills, there is at least one person in the team who has that skill. 
        We can represent these teams by the index of each person: for example, team = [0, 1,
            3] represents the people with skills people[0],
        people[1], and people[3].

    Return any sufficient team of the smallest possible size, represented
        by the index of each person.

    You may return the answer in any order.  It is guaranteed an answer exists.

     
    Example 1:
    Input: req_skills = ["java","nodejs","reactjs"], people = [["java"],["nodejs"],["nodejs","reactjs"]]
Output: [0,2]

    Example 2:
    Input: req_skills = ["algorithms","math","java","reactjs","csharp","aws"], people = [["algorithms","math","java"],["algorithms","math","reactjs"],["java","csharp","aws"],["reactjs","csharp"],["csharp","math"],["aws","java"]]
Output: [1,2]

     
    Constraints:

    
        1 <= req_skills.length <= 16
        1 <= people.length <= 60
        1 <= people[i].length, req_skills[i].length, people[i][j].length <=
            16
        Elements of req_skills and people[i] are (respectively)
            distinct.
        
        req_skills[i][j], people[i][j][k] are lowercase English letters.
        Every skill in people[i] is a skill in req_skills.
        It is guaranteed a sufficient team exists.
-----------------

# 1757_Recyclable_and_Low_Fat_Products
# 1757. Recyclable and Low Fat Products


-----------------

# 5_Longest_Palindromic_Substring
# 5. Longest Palindromic Substring

Given a string s, find the longest palindromic substring in
        s. You may assume that the maximum length of s is 1000.
    

    Example 1:

    Input: "babad"
Output: "bab"
Note: "aba" is also a valid answer.

    Example 2:

    Input: "cbbd"
Output: "bb"
-----------------

# 298_Binary_Tree_Longest_Consecutive_Sequence
# 298. Binary Tree Longest Consecutive Sequence

Given a binary tree, find the length of the longest consecutive sequence path.

    The path refers to any sequence of nodes from some starting node to any node in the tree
        along the parent-child connections. The longest consecutive path need to be from parent to
        child (cannot be the reverse).

    Example 1:

    Input:

   1
    \
     3
    / \
   2   4
        \
         5

Output: 3

Explanation: Longest consecutive sequence path is 3-4-5, so return 3.

    Example 2:

    Input:

   2
    \
     3
    /
   2
  /
 1

Output: 2

Explanation: Longest consecutive sequence path is 2-3, not 3-2-1, so return 2.
-----------------

# 521_Longest_Uncommon_Subsequence_I
# 521. Longest Uncommon Subsequence I

Given a group of two strings, you need to find the longest uncommon subsequence of this
        group of two strings.
        The longest uncommon subsequence is defined as the longest subsequence of one of these
        strings and this subsequence should not be any subsequence of the other strings.
    

    
        A subsequence is a sequence that can be derived from one sequence by deleting some
        characters without changing the order of the remaining elements. Trivially, any string is a
        subsequence of itself and an empty string is a subsequence of any string.
    

    
        The input will be two strings, and the output needs to be the length of the longest uncommon
        subsequence. If the longest uncommon subsequence doesn't exist, return -1.
    

    Example 1:
    Input: "aba", "cdc"
Output: 3
Explanation: The longest uncommon subsequence is "aba" (or "cdc"), because "aba" is a subsequence of "aba", but not a subsequence of any other strings in the group of two strings.

    

    Note:
    
        Both strings' lengths will not exceed 100.
        Only letters from a ~ z will appear in input strings.
-----------------

# 1064_Fixed_Point
# 1064. Fixed Point

Given an array A of distinct integers sorted in ascending order, return the
        smallest index i that satisfies A[i] == i.  Return
        -1 if no such i exists.

     

    Example 1:

    Input: [-10,-5,0,3,7]
Output: 3
Explanation: 
For the given array, A[0] = -10, A[1] = -5, A[2] = 0, A[3] = 3, thus the output is 3.

    Example 2:

    Input: [0,2,5,8,17]
Output: 0
Explanation: 
A[0] = 0, thus the output is 0.

    Example 3:

    Input: [-10,-5,3,4,7,9]
Output: -1
Explanation: 
There is no such i that A[i] = i, thus the output is -1.

     

    Note:

    
        1 <= A.length < 10^4
        -10^9 <= A[i] <= 10^9
-----------------

# 1232_Check_If_It_Is_a_Straight_Line
# 1232. Check If It Is a Straight Line

You are given an array coordinates, coordinates[i] = [x, y],
        where [x, y] represents the coordinate of a point. Check if these points make
        a straight line in the XY plane.

     

     
    Example 1:

    

    Input: coordinates = [[1,2],[2,3],[3,4],[4,5],[5,6],[6,7]]
Output: true

    Example 2:

    

    Input: coordinates = [[1,1],[2,2],[3,4],[4,5],[5,6],[7,7]]
Output: false

     
    Constraints:

    
        2 <= coordinates.length <= 1000
        coordinates[i].length == 2
        -10^4 <= coordinates[i][0], coordinates[i][1] <= 10^4
        coordinates contains no duplicate point.
-----------------

# 250_Count_Univalue_Subtrees
# 250. Count Univalue Subtrees

Given a binary tree, count the number of uni-value subtrees.

    A Uni-value subtree means all nodes of the subtree have the same value.

    Example :

    Input:  root = [5,1,5,5,5,null,5]

              5
             / \
            1   5
           / \   \
          5   5   5

Output: 4
-----------------

# 1737_Change_Minimum_Characters_to_Satisfy_One_of_Three_Conditions
# 1737. Change Minimum Characters to Satisfy One of Three Conditions


-----------------

# 3_Longest_Substring_Without_Repeating_Characters
# 3. Longest Substring Without Repeating Characters

Given a string, find the length of the longest substring without repeating characters.
-----------------

# 1596_The_Most_Frequently_Ordered_Products_for_Each_Customer
# 1596. The Most Frequently Ordered Products for Each Customer


-----------------

# 1495_Friendly_Movies_Streamed_Last_Month
# 1495. Friendly Movies Streamed Last Month


-----------------

# 857_Minimum_Cost_to_Hire_K_Workers
# 857. Minimum Cost to Hire K Workers

There are N workers.  The i-th worker has a
        quality[i] and a minimum wage expectation wage[i].

    Now we want to hire exactly K workers to form a paid group. 
        When hiring a group of K workers, we must pay them according to the following rules:

    
        Every worker in the paid group should be paid in the ratio of their quality compared to
            other workers in the paid group.
        
        Every worker in the paid group must be paid at least their minimum wage expectation.
        
    

    Return the least amount of money needed to form a paid group satisfying the above
        conditions.
-----------------

# 72_Edit_Distance
# 72. Edit Distance

Given two words word1 and word2, find the minimum number of operations
        required to convert word1 to word2.

    You have the following 3 operations permitted on a word:

    
        Insert a character
        Delete a character
        Replace a character
    

    Example 1:

    Input: word1 = "horse", word2 = "ros"
Output: 3
Explanation:
horse -> rorse (replace 'h' with 'r')
rorse -> rose (remove 'r')
rose -> ros (remove 'e')

    Example 2:

    Input: word1 = "intention", word2 = "execution"
Output: 5
Explanation:
intention -> inention (remove 't')
inention -> enention (replace 'i' with 'e')
enention -> exention (replace 'n' with 'x')
exention -> exection (replace 'n' with 'c')
exection -> execution (insert 'u')
-----------------

# 1808_Maximize_Number_of_Nice_Divisors
# 1808. Maximize Number of Nice Divisors


-----------------

# 881_Boats_to_Save_People
# 881. Boats to Save People

The i-th person has weight people[i], and each boat can carry a
        maximum weight of limit.

    Each boat carries at most 2 people at the same time, provided the sum of the weight of
        those people is at most limit.

    Return the minimum number of boats to carry every given person.  (It is guaranteed each
        person can be carried by a boat.)
-----------------

# 930_Binary_Subarrays_With_Sum
# 930. Binary Subarrays With Sum

In an array A of 0s and 1s, how many
        non-empty subarrays have sum S?

     

    Example 1:

    Input: A = [1,0,1,0,1], S = 2
Output: 4
Explanation: 
The 4 subarrays are bolded below:
[1,0,1,0,1]
[1,0,1,0,1]
[1,0,1,0,1]
[1,0,1,0,1]

     

    Note:

    
        A.length <= 30000
        0 <= S <= A.length
        A[i] is either 0 or 1.
-----------------

# 728_Self_Dividing_Numbers
# 728. Self Dividing Numbers

A self-dividing number is a number that is divisible by every digit it contains.
    
    
        For example, 128 is a self-dividing number because 128 % 1 == 0, 128 % 2
        == 0, and 128 % 8 == 0.
    
    
        Also, a self-dividing number is not allowed to contain the digit zero.
    
    
        Given a lower and upper number bound, output a list of every possible self dividing number,
        including the bounds if possible.
    
    Example 1:
    Input:
left = 1, right = 22
Output: [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15, 22]

    

    Note:
    The boundaries of each input argument are 1 <= left <= right <= 10000.
-----------------

# 336_Palindrome_Pairs
# 336. Palindrome Pairs

Given a list of unique words, find all pairs of distinct indices (i,
        j) in the given list, so that the concatenation of the two words, i.e. words[i]
        + words[j] is a palindrome.

    Example 1:
-----------------

# 970_Powerful_Integers
# 970. Powerful Integers

Given two positive integers x and y, an integer is
        powerful if it is equal to x^i + y^j for some integers
        i >= 0 and j >= 0.

    Return a list of all powerful integers that have value less than or equal to bound.
    

    You may return the answer in any order.  In your answer, each value should occur at most
        once.
-----------------

# 987_Vertical_Order_Traversal_of_a_Binary_Tree
# 987. Vertical Order Traversal of a Binary Tree

Given a binary tree, return the vertical order traversal of its nodes values.
    

    For each node at position (X, Y), its left and right children respectively will
        be at positions (X-1, Y-1) and (X+1, Y-1).

    Running a vertical line from X = -infinity to X = +infinity,
        whenever the vertical line touches some nodes, we report the values of the nodes in order
        from top to bottom (decreasing Y coordinates).

    If two nodes have the same position, then the value of the node that is reported first is the
        value that is smaller.

    Return an list of non-empty reports in order of X coordinate.  Every
        report will have a list of values of nodes.

     

    Example 1:
-----------------

# 886_Possible_Bipartition
# 886. Possible Bipartition

Given a set of N people (numbered 1, 2, ..., N), we would like
        to split everyone into two groups of any size.

    Each person may dislike some other people, and they should not go into the same
        group. 

    Formally, if dislikes[i] = [a, b], it means it is not allowed to put the people
        numbered a and b into the same group.

    Return true if and only if it is possible to split everyone into two groups
        in this way.
-----------------

# 1823_Find_the_Winner_of_the_Circular_Game
# 1823. Find the Winner of the Circular Game


-----------------

# 1762_Buildings_With_an_Ocean_View
# 1762. Buildings With an Ocean View


-----------------

# 402_Remove_K_Digits
# 402. Remove K Digits

Given a non-negative integer num represented as a string, remove k digits from
        the number so that the new number is the smallest possible.
    

    Note:
    
        The length of num is less than 10002 and will be ≥ k.
        The given num does not contain any leading zero.
    
    
    

    Example 1:
    Input: num = "1432219", k = 3
Output: "1219"
Explanation: Remove the three digits 4, 3, and 2 to form the new number 1219 which is the smallest.

    

    Example 2:
    Input: num = "10200", k = 1
Output: "200"
Explanation: Remove the leading 1 and the number is 200. Note that the output must not contain leading zeroes.

    

    Example 3:
    Input: num = "10", k = 2
Output: "0"
Explanation: Remove all the digits from the number and it is left with nothing which is 0.
-----------------

# 827_Making_A_Large_Island
# 827. Making A Large Island

In a 2D grid of 0s and 1s, we change at most one 0 to
        a 1.

    After, what is the size of the largest island? (An island is a 4-directionally connected
        group of 1s).

    Example 1:

    Input: [[1, 0], [0, 1]]
Output: 3
Explanation: Change one 0 to 1 and connect two 1s, then we get an island with area = 3.

    Example 2:

    Input: [[1, 1], [1, 0]]
Output: 4
Explanation: Change the 0 to 1 and make the island bigger, only one island with area = 4.

    Example 3:

    Input: [[1, 1], [1, 1]]
Output: 4
Explanation: Can't change any 0 to 1, only one island with area = 4.

     

    Notes:

    
        1 <= grid.length = grid[0].length <= 50.
        0 <= grid[i][j] <= 1.
-----------------

# 75_Sort_Colors
# 75. Sort Colors

Given an array with n objects colored red, white or blue, sort them in-place so
        that objects of the same color are adjacent, with the colors in the order red, white and
        blue.

    Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue
        respectively.

    Note: You are not suppose to use the library's sort function for
        this problem.

    Example:

    Input: [2,0,2,1,1,0]
Output: [0,0,1,1,2,2]

    Follow up:

    
        A rather straight forward solution is a two-pass algorithm using counting sort.
            First, iterate the array counting number of 0's, 1's, and 2's, then
            overwrite array with total number of 0's, then 1's and followed by 2's.
        
        Could you come up with a one-pass algorithm using only constant space?
-----------------

# 894_All_Possible_Full_Binary_Trees
# 894. All Possible Full Binary Trees

A full binary tree is a binary tree where each node has exactly 0 or 2 children.
    

    Return a list of all possible full binary trees with N nodes.  Each element
        of the answer is the root node of one possible tree.

    Each node of each tree in the answer must have node.val
        = 0.

    You may return the final list of trees in any order.

     

    Example 1:

    Input: 7
Output: [[0,0,0,null,null,0,0,null,null,0,0],[0,0,0,null,null,0,0,0,0],[0,0,0,0,0,0,0],[0,0,0,0,0,null,null,null,null,0,0],[0,0,0,0,0,null,null,0,0]]
Explanation:

     

    Note:

    
        1 <= N <= 20
-----------------

# 1779_Find_Nearest_Point_That_Has_the_Same_X_or_Y_Coordinate
# 1779. Find Nearest Point That Has the Same X or Y Coordinate


-----------------

# 601_Human_Traffic_of_Stadium
# 601. Human Traffic of Stadium

X city built a new stadium, each day many people visit it and the stats are saved as these
        columns: id, visit_date, people

    Please write a query to display the records which have 3 or more consecutive rows and the
        amount of people more than 100(inclusive).
    For example, the table stadium:

    +------+------------+-----------+
| id   | visit_date | people    |
+------+------------+-----------+
| 1    | 2017-01-01 | 10        |
| 2    | 2017-01-02 | 109       |
| 3    | 2017-01-03 | 150       |
| 4    | 2017-01-04 | 99        |
| 5    | 2017-01-05 | 145       |
| 6    | 2017-01-06 | 1455      |
| 7    | 2017-01-07 | 199       |
| 8    | 2017-01-08 | 188       |
+------+------------+-----------+

    For the sample data above, the output is:

    +------+------------+-----------+
| id   | visit_date | people    |
+------+------------+-----------+
| 5    | 2017-01-05 | 145       |
| 6    | 2017-01-06 | 1455      |
| 7    | 2017-01-07 | 199       |
| 8    | 2017-01-08 | 188       |
+------+------------+-----------+

    Note:
        Each day only have one row record, and the dates are increasing with id increasing.
-----------------

# 1829_Maximum_XOR_for_Each_Query
# 1829. Maximum XOR for Each Query


-----------------

# 316_Remove_Duplicate_Letters
# 316. Remove Duplicate Letters

Given a string which contains only lowercase letters, remove duplicate letters so that every
        letter appears once and only once. You must make sure your result is the smallest in
        lexicographical order among all possible results.

    Example 1:

    Input: "bcabc"
Output: "abc"

    Example 2:

    Input: "cbacdcbc"
Output: "acdb"
-----------------

# 435_Non-overlapping_Intervals
# 435. Non-overlapping Intervals

Given a collection of intervals, find the minimum number of intervals you need to remove to
        make the rest of the intervals non-overlapping.

    
    

     

    Example 1:

    Input: [[1,2],[2,3],[3,4],[1,3]]
Output: 1
Explanation: [1,3] can be removed and the rest of intervals are non-overlapping.

    Example 2:

    Input: [[1,2],[1,2],[1,2]]
Output: 2
Explanation: You need to remove two [1,2] to make the rest of intervals non-overlapping.

    Example 3:

    Input: [[1,2],[2,3]]
Output: 0
Explanation: You don't need to remove any of the intervals since they're already non-overlapping.

     

    Note:

    
        You may assume the interval's end point is always bigger than its start point.
        Intervals like [1,2] and [2,3] have borders "touching" but they don't
            overlap each other.
-----------------

# 320_Generalized_Abbreviation
# 320. Generalized Abbreviation

Write a function to generate the generalized abbreviations of a word. 

    Note: The order of the output does not matter.

    Example:

    Input: "word"
Output:
["word", "1ord", "w1rd", "wo1d", "wor1", "2rd", "w2d", "wo2", "1o1d", "1or1", "w1r1", "1o2", "2r1", "3d", "w3", "4"]
-----------------

# 1079_Letter_Tile_Possibilities
# 1079. Letter Tile Possibilities

You have a set of tiles, where each tile has one letter tiles[i]
        printed on it.  Return the number of possible non-empty sequences of letters you can
        make.

     

    Example 1:

    Input: "AAB"
Output: 8
Explanation: The possible sequences are "A", "B", "AA", "AB", "BA", "AAB", "ABA", "BAA".
-----------------

# 829_Consecutive_Numbers_Sum
# 829. Consecutive Numbers Sum

Given a positive integer N, how many ways can we write it as a sum of consecutive
        positive integers?

    Example 1:

    Input: 5
Output: 2
Explanation: 5 = 5 = 2 + 3

    Example 2:

    Input: 9
Output: 3
Explanation: 9 = 9 = 4 + 5 = 2 + 3 + 4

    Example 3:

    Input: 15
Output: 4
Explanation: 15 = 15 = 8 + 7 = 4 + 5 + 6 = 1 + 2 + 3 + 4 + 5

    Note: 1 <= N <= 10 ^ 9.
-----------------

# 200_Number_of_Islands
# 200. Number of Islands

Given a 2d grid map of '1's (land) and '0's
        (water), count the number of islands. An island is surrounded by water and is formed by
        connecting adjacent lands horizontally or vertically. You may assume all four edges of the
        grid are all surrounded by water.

    Example 1:

    Input:
11110
11010
11000
00000

Output: 1

    Example 2:

    Input:
11000
11000
00100
00011

Output: 3
-----------------

# 1850_Minimum_Adjacent_Swaps_to_Reach_the_Kth_Smallest_Number
# 1850. Minimum Adjacent Swaps to Reach the Kth Smallest Number


-----------------

# 53_Maximum_Subarray
# 53. Maximum Subarray

Given an integer array nums, find the contiguous subarray (containing at
        least one number) which has the largest sum and return its sum.

    Example:

    Input: [-2,1,-3,4,-1,2,1,-5,4],
Output: 6
Explanation: [4,-1,2,1] has the largest sum = 6.

    Follow up:

    If you have figured out the O(n) solution, try coding another solution using the
        divide and conquer approach, which is more subtle.
-----------------

# 225_Implement_Stack_using_Queues
# 225. Implement Stack using Queues

Implement the following operations of a stack using queues.

    
        push(x) -- Push element x onto stack.
        pop() -- Removes the element on top of the stack.
        top() -- Get the top element.
        empty() -- Return whether the stack is empty.
    

    Example:

    MyStack stack = new MyStack();

stack.push(1);
stack.push(2);
stack.top();   // returns 2
stack.pop();   // returns 2
stack.empty(); // returns false

    Notes:

    
        You must use only standard operations of a queue -- which means only push
            to back, peek/pop from front, size, and is
            empty operations are valid.
        
        Depending on your language, queue may not be supported natively. You may simulate a
            queue by using a list or deque (double-ended queue), as long as you use only standard
            operations of a queue.
        
        You may assume that all operations are valid (for example, no pop or top operations will
            be called on an empty stack).
-----------------

# 1094_Car_Pooling
# 1094. Car Pooling

You are driving a vehicle that has capacity empty seats initially available
        for passengers.  The vehicle only drives east (ie. it
        cannot turn around and drive west.)

    Given a list of trips, trip[i] = [num_passengers, start_location,
        end_location] contains information about the i-th trip: the number
        of passengers that must be picked up, and the locations to pick them up and drop them off. 
        The locations are given as the number of kilometers due east from your vehicle's
        initial location.

    Return true if and only if it is possible to pick up and drop off all
        passengers for all the given trips. 

     

    Example 1:

    Input: trips = [[2,1,5],[3,3,7]], capacity = 4
Output: false
-----------------

# 1289_Minimum_Falling_Path_Sum_II
# 1289. Minimum Falling Path Sum II


-----------------

# 205_Isomorphic_Strings
# 205. Isomorphic Strings

Given two strings s and t, determine if they are isomorphic.

    Two strings are isomorphic if the characters in s can be replaced to get t.
    

    All occurrences of a character must be replaced with another character while preserving the
        order of characters. No two characters may map to the same character but a character may map
        to itself.

    Example 1:

    Input: s = "egg", t = "add"
Output: true

    Example 2:

    Input: s = "foo", t = "bar"
Output: false

    Example 3:

    Input: s = "paper", t = "title"
Output: true

    Note:
        You may assume both s and t have the same length.
-----------------

# 1732_Find_the_Highest_Altitude
# 1732. Find the Highest Altitude


-----------------

# 103_Binary_Tree_Zigzag_Level_Order_Traversal
# 103. Binary Tree Zigzag Level Order Traversal

Given a binary tree, return the zigzag level order traversal of its nodes' values.
        (ie, from left to right, then right to left for the next level and alternate between).

    
        For example:
        Given binary tree [3,9,20,null,null,15,7],
        3
   / \
  9  20
    /  \
   15   7

    
    
        return its zigzag level order traversal as:
    [
  [3],
  [20,9],
  [15,7]
]
-----------------

# 670_Maximum_Swap
# 670. Maximum Swap

Given a non-negative integer, you could swap two digits at most once to get the
        maximum valued number. Return the maximum valued number you could get.
    

    Example 1:
    Input: 2736
Output: 7236
Explanation: Swap the number 2 and the number 7.

    

    Example 2:
    Input: 9973
Output: 9973
Explanation: No swap.

    

    Note:
    
        The given number is in the range [0, 108]
-----------------

# 1069_Product_Sales_Analysis_II
# 1069. Product Sales Analysis II

Table: Sales

    +-------------+-------+
| Column Name | Type  |
+-------------+-------+
| sale_id     | int   |
| product_id  | int   |
| year        | int   |
| quantity    | int   |
| price       | int   |
+-------------+-------+
sale_id is the primary key of this table.
product_id is a foreign key to Product table.
Note that the price is per unit.

    Table: Product

    +--------------+---------+
| Column Name  | Type    |
+--------------+---------+
| product_id   | int     |
| product_name | varchar |
+--------------+---------+
product_id is the primary key of this table.

     

    Write an SQL query that reports the total quantity sold for every product id.

    The query result format is in the following example:

    Sales table:
+---------+------------+------+----------+-------+
| sale_id | product_id | year | quantity | price |
+---------+------------+------+----------+-------+
| 1       | 100        | 2008 | 10       | 5000  |
| 2       | 100        | 2009 | 12       | 5000  |
| 7       | 200        | 2011 | 15       | 9000  |
+---------+------------+------+----------+-------+

Product table:
+------------+--------------+
| product_id | product_name |
+------------+--------------+
| 100        | Nokia        |
| 200        | Apple        |
| 300        | Samsung      |
+------------+--------------+

Result table:
+--------------+----------------+
| product_id   | total_quantity |
+--------------+----------------+
| 100          | 22             |
| 200          | 15             |
+--------------+----------------+
-----------------

# 1386_Cinema_Seat_Allocation
# 1386. Cinema Seat Allocation


-----------------

# 163_Missing_Ranges
# 163. Missing Ranges

Given a sorted integer array nums, where the range of elements are
        in the inclusive range [lower, upper],
        return its missing ranges.

    Example:

    Input: nums = [0, 1, 3, 50, 75], lower = 0 and upper = 99,
Output: ["2", "4->49", "51->74", "76->99"]
-----------------

# 1561_Maximum_Number_of_Coins_You_Can_Get
# 1561. Maximum Number of Coins You Can Get


-----------------

# 281_Zigzag_Iterator
# 281. Zigzag Iterator

Given two 1d vectors, implement an iterator to return their elements alternately.

    Example:

    Input:
v1 = [1,2]
v2 = [3,4,5,6]

Output: [1,3,2,4,5,6]

Explanation: By calling next repeatedly until hasNext returns false,
             the order of elements returned by next should be: [1,3,2,4,5,6].

    Follow up: What if you are given k 1d vectors? How well can your code be
        extended to such cases?

    Clarification for the follow up question:
        The "Zigzag" order is not clearly defined and is ambiguous for k >
            2 cases. If "Zigzag" does not look right to you, replace "Zigzag"
        with "Cyclic". For example:

    Input:
[1,2,3]
[4,5,6,7]
[8,9]

Output: [1,4,8,2,5,9,3,6,7].
-----------------

# 8_String_to_Integer_(atoi)
# 8. String to Integer (atoi)

Implement atoi which converts a string to an integer.

    The function first discards as many whitespace characters as necessary until the first
        non-whitespace character is found. Then, starting from this character, takes an optional
        initial plus or minus sign followed by as many numerical digits as possible, and interprets
        them as a numerical value.

    The string can contain additional characters after those that form the integral number, which
        are ignored and have no effect on the behavior of this function.

    If the first sequence of non-whitespace characters in str is not a valid integral number, or
        if no such sequence exists because either str is empty or it contains only whitespace
        characters, no conversion is performed.

    If no valid conversion could be performed, a zero value is returned.

    Note:

    
        Only the space character ' ' is considered as whitespace character.
        
        Assume we are dealing with an environment which could only store integers within the
            32-bit signed integer range: [−231,  231 −
            1]. If the numerical value is out of the range of representable values, INT_MAX (231 −
            1) or INT_MIN (−231) is returned.
        
    

    Example 1:

    Input: "42"
Output: 42

    Example 2:

    Input: "   -42"
Output: -42
Explanation: The first non-whitespace character is '-', which is the minus sign.
             Then take as many numerical digits as possible, which gets 42.

    Example 3:

    Input: "4193 with words"
Output: 4193
Explanation: Conversion stops at digit '3' as the next character is not a numerical digit.

    Example 4:

    Input: "words and 987"
Output: 0
Explanation: The first non-whitespace character is 'w', which is not a numerical
             digit or a +/- sign. Therefore no valid conversion could be performed.

    Example 5:

    Input: "-91283472332"
Output: -2147483648
Explanation: The number "-91283472332" is out of the range of a 32-bit signed integer.
             Thefore INT_MIN (−231) is returned.
-----------------

# 1703_Minimum_Adjacent_Swaps_for_K_Consecutive_Ones
# 1703. Minimum Adjacent Swaps for K Consecutive Ones


-----------------

# 1673_Find_the_Most_Competitive_Subsequence
# 1673. Find the Most Competitive Subsequence


-----------------

# 648_Replace_Words
# 648. Replace Words

In English, we have a concept called root, which can be followed by some other
        words to form another longer word - let's call this word successor. For
        example, the root an, followed by other, which can form another
        word another.

    Now, given a dictionary consisting of many roots and a sentence. You need to replace all the
        successor in the sentence with the root forming it. If a successor
        has many roots can form it, replace it with the root with the shortest length.
    

    You need to output the sentence after the replacement.

    Example 1:

    Input: dict = ["cat", "bat", "rat"]
sentence = "the cattle was rattled by the battery"
Output: "the cat was rat by the bat"

     

    Note:

    
        The input will only have lower-case letters.
        1 <= dict words number <= 1000
        1 <= sentence words number <= 1000
        1 <= root length <= 100
        1 <= sentence words length <= 1000
-----------------

# 846_Hand_of_Straights
# 846. Hand of Straights

Alice has a hand of cards, given as an array of integers.

    Now she wants to rearrange the cards into groups so that each group is size W,
        and consists of W consecutive cards.

    Return true if and only if she can.

     

    
    

    Example 1:

    Input: hand = [1,2,3,6,2,3,4,7,8], W = 3
Output: true
Explanation: Alice's hand can be rearranged as [1,2,3],[2,3,4],[6,7,8].

    Example 2:

    Input: hand = [1,2,3,4,5], W = 4
Output: false
Explanation: Alice's hand can't be rearranged into groups of 4.

     

    Note:

    
        1 <= hand.length <= 10000
        0 <= hand[i] <= 10^9
        1 <= W <= hand.length
-----------------

# 1257_Smallest_Common_Region
# 1257. Smallest Common Region


-----------------

# 560_Subarray_Sum_Equals_K
# 560. Subarray Sum Equals K

Given an array of integers and an integer k, you need to find the total number of
        continuous subarrays whose sum equals to k.

    Example 1:
    Input:nums = [1,1,1], k = 2
Output: 2

    

    Note:
    
        The length of the array is in range [1, 20,000].
        The range of numbers in the array is [-1000, 1000] and the range of the integer k
            is [-1e7, 1e7].
-----------------

# 825_Friends_Of_Appropriate_Ages
# 825. Friends Of Appropriate Ages

Some people will make friend requests. The list of their ages is given and ages[i] is
        the age of the ith person. 

    Person A will NOT friend request person B (B != A) if any of the following conditions are
        true:

    
        age[B] <= 0.5 * age[A] + 7
        age[B] > age[A]
        age[B] > 100 && age[A] < 100
    

    Otherwise, A will friend request B.

    Note that if A requests B, B does not necessarily request A.  Also, people will not
        friend request themselves.

    How many total friend requests are made?

    Example 1:

    Input: [16,16]
Output: 2
Explanation: 2 people friend request each other.

    Example 2:

    Input: [16,17,18]
Output: 2
Explanation: Friend requests are made 17 -> 16, 18 -> 17.

    Example 3:

    Input: [20,30,100,110,120]
Output: 
Explanation: Friend requests are made 110 -> 100, 120 -> 110, 120 -> 100.

     

    Notes:

    
        1 <= ages.length <= 20000.
        1 <= ages[i] <= 120.
-----------------

# 869_Reordered_Power_of_2
# 869. Reordered Power of 2

Starting with a positive integer N, we reorder the digits in any order
        (including the original order) such that the leading digit is not zero.

    Return true if and only if we can do this in a way such that the resulting
        number is a power of 2.
-----------------

# 105_Construct_Binary_Tree_from_Preorder_and_Inorder_Traversal
# 105. Construct Binary Tree from Preorder and Inorder Traversal

Given preorder and inorder traversal of a tree, construct the binary tree.

    Note:
        You may assume that duplicates do not exist in the tree.

    For example, given

    preorder = [3,9,20,15,7]
inorder = [9,3,15,20,7]

    Return the following binary tree:

        3
   / \
  9  20
    /  \
   15   7
-----------------

# 1514_Path_with_Maximum_Probability
# 1514. Path with Maximum Probability


-----------------

# 590_N-ary_Tree_Postorder_Traversal
# 590. N-ary Tree Postorder Traversal

Given an n-ary tree, return the postorder traversal of its nodes' values.

    For example, given a 3-ary tree:

     

    
        

     

    Return its postorder traversal as: [5,6,3,2,4,1].
     

    Note:

    Recursive solution is trivial, could you do it iteratively?
-----------------

# 1698_Number_of_Distinct_Substrings_in_a_String
# 1698. Number of Distinct Substrings in a String

Hints:

    Hint 1
    Calculate the prefix hashing array for s.
    Hint 2
    Use the prefix hashing array to calculate the hashing value of each substring.
    Hint 3
    Compare the hashing values to determine the unique substrings.
    Hint 4
    There could be collisions if you use hashing, what about double hashing.
-----------------

# 1_Two_Sum
# 1. Two Sum

Given an array of integers, return indices of the two numbers such that they
        add up to a specific target.

    You may assume that each input would have exactly one solution, and
        you may not use the same element twice.

    Example:

    Given nums = [2, 7, 11, 15], target = 9,

Because nums[0] + nums[1] = 2 + 7 = 9,
return [0, 1].
-----------------

# 1291_Sequential_Digits
# 1291. Sequential Digits


-----------------

# 452_Minimum_Number_of_Arrows_to_Burst_Balloons
# 452. Minimum Number of Arrows to Burst Balloons

There are a number of spherical balloons spread in two-dimensional space. For each balloon,
        provided input is the start and end coordinates of the horizontal diameter. Since it's
        horizontal, y-coordinates don't matter and hence the x-coordinates of start and end of
        the diameter suffice. Start is always smaller than end. There will be at most 104
        balloons.

    An arrow can be shot up exactly vertically from different points along the x-axis. A balloon
        with xstart and xend bursts by an arrow shot at x if xstart
        ≤ x ≤ xend. There is no limit to the number of arrows that can be shot. An
        arrow once shot keeps travelling up infinitely. The problem is to find the minimum number of
        arrows that must be shot to burst all balloons.

    Example:

    Input:
[[10,16], [2,8], [1,6], [7,12]]

Output:
2

Explanation:
One way is to shoot one arrow for example at x = 6 (bursting the balloons [2,8] and [1,6]) and another arrow at x = 11 (bursting the other two balloons).
-----------------

# 379_Design_Phone_Directory
# 379. Design Phone Directory

Design a Phone Directory which supports the following operations:

    
    
        get: Provide a number which is not assigned to anyone.
        check: Check if a number is available or not.
        release: Recycle or release a number.
    
    

    Example:
    // Init a phone directory containing a total of 3 numbers: 0, 1, and 2.
PhoneDirectory directory = new PhoneDirectory(3);

// It can return any available phone number. Here we assume it returns 0.
directory.get();

// Assume it returns 1.
directory.get();

// The number 2 is available, so return true.
directory.check(2);

// It returns 2, the only number that is left.
directory.get();

// The number 2 is no longer available, so return false.
directory.check(2);

// Release number 2 back to the pool.
directory.release(2);

// Number 2 is available again, return true.
directory.check(2);
-----------------

# 464_Can_I_Win
# 464. Can I Win

In the "100 game," two players take turns adding, to a running total, any integer from 1..10.
        The player who first causes the running total to reach or exceed 100 wins. 

    What if we change the game so that players cannot re-use integers? 

    For example, two players might take turns drawing from a common pool of numbers of 1..15
        without replacement until they reach a total >= 100.

    Given an integer maxChoosableInteger and another integer
        desiredTotal, determine if the first player to move can force a win, assuming
        both players play optimally. 

    You can always assume that maxChoosableInteger will not be larger than 20 and
        desiredTotal will not be larger than 300.
    

    Example
    Input:
maxChoosableInteger = 10
desiredTotal = 11

Output:
false

Explanation:
No matter which integer the first player choose, the first player will lose.
The first player can choose an integer from 1 up to 10.
If the first player choose 1, the second player can only choose integers from 2 up to 10.
The second player will win by choosing 10 and get a total = 11, which is >= desiredTotal.
Same with other integers chosen by the first player, the second player will always win.
-----------------

# 1395_Count_Number_of_Teams
# 1395. Count Number of Teams


-----------------

# 1448_Count_Good_Nodes_in_Binary_Tree
# 1448. Count Good Nodes in Binary Tree


-----------------

# 260_Single_Number_III
# 260. Single Number III

Given an array of numbers nums, in which exactly two elements appear only once
        and all the other elements appear exactly twice. Find the two elements that appear only
        once.

    Example:

    Input:  [1,2,1,3,2,5]
Output: [3,5]

    Note:

    
        The order of the result is not important. So in the above example, [5, 3]
            is also correct.
        
        Your algorithm should run in linear runtime complexity. Could you implement it using
            only constant space complexity?
-----------------

# 613_Shortest_Distance_in_a_Line
# 613. Shortest Distance in a Line

Table point holds the x coordinate of some points on x-axis in a plane, which are
    all integers.
     
    Write a query to find the shortest distance between two points in these points.

     

    | x   |
|-----|
| -1  |
| 0   |
| 2   |

     
    The shortest distance is '1' obviously, which is from point '-1' to '0'.
    So the output is as below:

     

    | shortest|
|---------|
| 1       |

     
    Note: Every point is unique, which means there is no duplicates in table
    point.

     
    Follow-up: What if all these points have an id and are arranged from the left most to the
    right most of x axis?
-----------------

# 1288_Remove_Covered_Intervals
# 1288. Remove Covered Intervals


-----------------

# 790_Domino_and_Tromino_Tiling
# 790. Domino and Tromino Tiling

We have two types of tiles: a 2x1 domino shape, and an "L" tromino shape. These
        shapes may be rotated.

    XX  <- domino

XX  <- "L" tromino
X

    Given N, how many ways are there to tile a 2 x N board? Return your answer modulo
        10^9 + 7.

    (In a tiling, every square must be covered by a tile. Two tilings are different if and only
        if there are two 4-directionally adjacent cells on the board such that exactly one of the
        tilings has both squares occupied by a tile.)

    Example:
Input: 3
Output: 5
Explanation:
The five different ways are listed below, different letters indicates different tiles:
XYZ XXZ XYY XXY XYY
XYZ YYZ XZZ XYY XXY

    Note:

    
        N  will be in range [1, 1000].
-----------------

# 919_Complete_Binary_Tree_Inserter
# 919. Complete Binary Tree Inserter

A complete binary tree is a binary tree in which every level, except possibly the
        last, is completely filled, and all nodes are as far left as possible.

    Write a data structure CBTInserter that is initialized with a complete
        binary tree and supports the following operations:

    
        CBTInserter(TreeNode root) initializes the data structure on a given tree with
            head node root;
        
        CBTInserter.insert(int v) will insert a TreeNode into the
            tree with value node.val = v so that the tree remains complete,
            and returns the value of the parent of the inserted
                TreeNode;
        
        CBTInserter.get_root() will return the head node of the tree.
-----------------

# 31_Next_Permutation
# 31. Next Permutation

Implement next permutation, which rearranges numbers into the
        lexicographically next greater permutation of numbers.

    If such arrangement is not possible, it must rearrange it as the lowest possible order (ie,
        sorted in ascending order).

    The replacement must be in-place and use only
        constant extra memory.

    Here are some examples. Inputs are in the left-hand column and its corresponding outputs are
        in the right-hand column.

    1,2,3 → 1,3,2
        3,2,1 → 1,2,3
        1,1,5 → 1,5,1
-----------------

# 54_Spiral_Matrix
# 54. Spiral Matrix

Given a matrix of m x n elements (m rows, n columns),
        return all elements of the matrix in spiral order.

    Example 1:

    Input:
[
 [ 1, 2, 3 ],
 [ 4, 5, 6 ],
 [ 7, 8, 9 ]
]
Output: [1,2,3,6,9,8,7,4,5]

    Example 2:
    Input:
[
  [1, 2, 3, 4],
  [5, 6, 7, 8],
  [9,10,11,12]
]
Output: [1,2,3,4,8,12,11,10,9,5,6,7]
-----------------

# 1735_Count_Ways_to_Make_Array_With_Product
# 1735. Count Ways to Make Array With Product


-----------------

# 1728_Cat_and_Mouse_II
# 1728. Cat and Mouse II


-----------------

# 1521_Find_a_Value_of_a_Mysterious_Function_Closest_to_Target
# 1521. Find a Value of a Mysterious Function Closest to Target


-----------------

# 4_Median_of_Two_Sorted_Arrays
# 4. Median of Two Sorted Arrays

There are two sorted arrays nums1 and nums2 of size m and n respectively.

    Find the median of the two sorted arrays. The overall run time complexity should be O(log
        (m+n)).

    You may assume nums1 and nums2 cannot be both empty.
    

    Example 1:

    nums1 = [1, 3]
nums2 = [2]

The median is 2.0

    Example 2:

    nums1 = [1, 2]
nums2 = [3, 4]

The median is (2 + 3)/2 = 2.5
-----------------

# 908_Smallest_Range_I
# 908. Smallest Range I

Given an array A of integers, for each integer A[i] we may choose
        any x with -K <= x <= K, and add x to A[i].
    

    After this process, we have some array B.

    Return the smallest possible difference between the maximum value of B and
        the minimum value of B.
-----------------

# 142_Linked_List_Cycle_II
# 142. Linked List Cycle II

Given a linked list, return the node where the cycle begins. If there is no cycle, return
        null.

    To represent a cycle in the given linked list, we use an integer pos which
        represents the position (0-indexed) in the linked list where tail connects to. If
        pos is -1, then there is no cycle in the linked list.

    Note: Do not modify the linked list.

     

    Example 1:

    Input: head = [3,2,0,-4], pos = 1
Output: tail connects to node index 1
Explanation: There is a cycle in the linked list, where tail connects to the second node.

    

    Example 2:

    Input: head = [1,2], pos = 0
Output: tail connects to node index 0
Explanation: There is a cycle in the linked list, where tail connects to the first node.

    

    Example 3:

    Input: head = [1], pos = -1
Output: no cycle
Explanation: There is no cycle in the linked list.

    

     

    Follow-up:
        Can you solve it without using extra space?
-----------------

# 17_Letter_Combinations_of_a_Phone_Number
# 17. Letter Combinations of a Phone Number

Given a string containing digits from 2-9 inclusive, return all possible letter
        combinations that the number could represent.

    A mapping of digit to letters (just like on the telephone buttons) is given below. Note that
        1 does not map to any letters.

    
        
    

    Example:

    Input: "23"
Output: ["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"].

    Note:

    Although the above answer is in lexicographical order, your answer could be in any order you
        want.
-----------------

# 1727_Largest_Submatrix_With_Rearrangements
# 1727. Largest Submatrix With Rearrangements


-----------------

# 1340_Jump_Game_V
# 1340. Jump Game V


-----------------

# 1167_Minimum_Cost_to_Connect_Sticks
# 1167. Minimum Cost to Connect Sticks

You have some sticks with positive integer lengths.

    You can connect any two sticks of lengths X and Y into one stick by
        paying a cost of X + Y.  You perform this action until there is one stick
        remaining.

    Return the minimum cost of connecting all the given sticks into one stick
        in this way.

     
    Example 1:
    Input: sticks = [2,4,3]
Output: 14

    Example 2:
    Input: sticks = [1,8,3,5]
Output: 30

     
    Constraints:

    
        1 <= sticks.length <= 10^4
        1 <= sticks[i] <= 10^4
-----------------

# 757_Set_Intersection_Size_At_Least_Two
# 757. Set Intersection Size At Least Two

An integer interval [a, b] (for integers a < b) is a set of all
        consecutive integers from a to b, including a and
        b.
    
    
        Find the minimum size of a set S such that for every integer interval A in
        intervals, the intersection of S with A has size at least 2.
    

    Example 1:
    Input: intervals = [[1, 3], [1, 4], [2, 5], [3, 5]]
Output: 3
Explanation:
Consider the set S = {2, 3, 4}.  For each interval, there are at least 2 elements from S in the interval.
Also, there isn't a smaller size set that fulfills the above condition.
Thus, we output the size of this set, which is 3.

    

    Example 2:
    Input: intervals = [[1, 2], [2, 3], [2, 4], [4, 5]]
Output: 5
Explanation:
An example of a minimum sized set is {1, 2, 3, 4, 5}.

    

    Note:
    
        intervals will have length in range [1, 3000].
        intervals[i] will have length 2, representing some integer
            interval.
        
        intervals[i][j] will be an integer in [0, 10^8].
-----------------

# 1168_Optimize_Water_Distribution_in_a_Village
# 1168. Optimize Water Distribution in a Village

There are n houses in a village. We want to
        supply water for all the houses by building wells and laying pipes.

    For each house i, we can either build a well inside it directly with cost wells[i],
        or pipe in water from another well to it. The costs to lay pipes between houses are given by
        the array pipes, where each pipes[i] = [house1, house2, cost] represents
        the cost to connect house1 and house2 together
        using a pipe. Connections are bidirectional.

    Find the minimum total cost to supply water to all houses.

     
    Example 1:

    

    Input: n = 3, wells = [1,2,2], pipes = [[1,2,1],[2,3,1]]
Output: 3
Explanation: 
The image shows the costs of connecting houses using pipes.
The best strategy is to build a well in the first house with cost 1 and connect the other houses to it with cost 2 so the total cost is 3.

     
    Constraints:

    
        1 <= n <= 10000
        wells.length == n
        0 <= wells[i] <= 10^5
        1 <= pipes.length <= 10000
        1 <= pipes[i][0], pipes[i][1] <= n
        0 <= pipes[i][2] <= 10^5
        pipes[i][0] != pipes[i][1]
-----------------

# 1553_Minimum_Number_of_Days_to_Eat_N_Oranges
# 1553. Minimum Number of Days to Eat N Oranges


-----------------

# 248_Strobogrammatic_Number_III
# 248. Strobogrammatic Number III

A strobogrammatic number is a number that looks the same when rotated 180 degrees (looked at
        upside down).

    Write a function to count the total strobogrammatic numbers that exist in the range of low
        <= num <= high.

    Example:

    Input: low = "50", high = "100"
Output: 3
Explanation: 69, 88, and 96 are three strobogrammatic numbers.

    Note:
        Because the range might be a large number, the low and high numbers are
        represented as string.
-----------------

# 1037_Valid_Boomerang
# 1037. Valid Boomerang

A boomerang is a set of 3 points that are all distinct and not in a
        straight line.

    Given a list of three points in the plane, return whether these points are a
        boomerang.

     

    Example 1:

    Input: [[1,1],[2,3],[3,2]]
Output: true
-----------------

# 1187_Make_Array_Strictly_Increasing
# 1187. Make Array Strictly Increasing

Given two integer arrays arr1 and arr2, return the minimum
        number of operations (possibly zero) needed to make arr1 strictly
        increasing.

    In one operation, you can choose two indices 0 <= i <
        arr1.length and 0 <= j < arr2.length and do the
        assignment arr1[i] = arr2[j].

    If there is no way to make arr1 strictly increasing, return -1.
    

     
    Example 1:

    Input: arr1 = [1,5,3,6,7], arr2 = [1,3,2,4]
Output: 1
Explanation: Replace 5 with 2, then arr1 = [1, 2, 3, 6, 7].

    Example 2:

    Input: arr1 = [1,5,3,6,7], arr2 = [4,3,1]
Output: 2
Explanation: Replace 5 with 3 and then replace 3 with 4. arr1 = [1, 3, 4, 6, 7].

    Example 3:

    Input: arr1 = [1,5,3,6,7], arr2 = [1,6,3,3]
Output: -1
Explanation: You can't make arr1 strictly increasing.

     
    Constraints:

    
        1 <= arr1.length, arr2.length <= 2000
        0 <= arr1[i], arr2[i] <= 10^9
-----------------

# 1077_Project_Employees_III
# 1077. Project Employees III

Table: Project

    +-------------+---------+
| Column Name | Type    |
+-------------+---------+
| project_id  | int     |
| employee_id | int     |
+-------------+---------+
(project_id, employee_id) is the primary key of this table.
employee_id is a foreign key to Employee table.

    Table: Employee

    +------------------+---------+
| Column Name      | Type    |
+------------------+---------+
| employee_id      | int     |
| name             | varchar |
| experience_years | int     |
+------------------+---------+
employee_id is the primary key of this table.

     

    Write an SQL query that reports the most experienced employees in each
        project. In case of a tie, report all employees with the maximum number of experience years.
    

    The query result format is in the following example:

    Project table:
+-------------+-------------+
| project_id  | employee_id |
+-------------+-------------+
| 1           | 1           |
| 1           | 2           |
| 1           | 3           |
| 2           | 1           |
| 2           | 4           |
+-------------+-------------+

Employee table:
+-------------+--------+------------------+
| employee_id | name   | experience_years |
+-------------+--------+------------------+
| 1           | Khaled | 3                |
| 2           | Ali    | 2                |
| 3           | John   | 3                |
| 4           | Doe    | 2                |
+-------------+--------+------------------+

Result table:
+-------------+---------------+
| project_id  | employee_id   |
+-------------+---------------+
| 1           | 1             |
| 1           | 3             |
| 2           | 1             |
+-------------+---------------+
Both employees with id 1 and 3 have the most experience among the employees of the first project. For the second project, the employee with id 1 has the most experience.
-----------------

# 1787_Make_the_XOR_of_All_Segments_Equal_to_Zero
# 1787. Make the XOR of All Segments Equal to Zero


-----------------

# 1083_Sales_Analysis_II
# 1083. Sales Analysis II

Table: Product

    +--------------+---------+
| Column Name  | Type    |
+--------------+---------+
| product_id   | int     |
| product_name | varchar |
| unit_price   | int     |
+--------------+---------+
product_id is the primary key of this table.

    Table: Sales

    +-------------+---------+
| Column Name | Type    |
+-------------+---------+
| seller_id   | int     |
| product_id  | int     |
| buyer_id    | int     |
| sale_date   | date    |
| quantity    | int     |
| price       | int     |
+------ ------+---------+
This table has no primary key, it can have repeated rows.
product_id is a foreign key to Product table.

     

    Write an SQL query that reports the buyers who have bought S8 but
        not iPhone. Note that S8 and iPhone are products present in the
        Product table.

    The query result format is in the following example:

    Product table:
+------------+--------------+------------+
| product_id | product_name | unit_price |
+------------+--------------+------------+
| 1          | S8           | 1000       |
| 2          | G4           | 800        |
| 3          | iPhone       | 1400       |
+------------+--------------+------------+

Sales table:
+-----------+------------+----------+------------+----------+-------+
| seller_id | product_id | buyer_id | sale_date  | quantity | price |
+-----------+------------+----------+------------+----------+-------+
| 1         | 1          | 1        | 2019-01-21 | 2        | 2000  |
| 1         | 2          | 2        | 2019-02-17 | 1        | 800   |
| 2         | 1          | 3        | 2019-06-02 | 1        | 800   |
| 3         | 3          | 3        | 2019-05-13 | 2        | 2800  |
+-----------+------------+----------+------------+----------+-------+

Result table:
+-------------+
| buyer_id    |
+-------------+
| 1           |
+-------------+
The buyer with id 1 bought an S8 but didn't buy an iPhone. The buyer with id 3 bought both.
-----------------

# 656_Coin_Path
# 656. Coin Path

Given an array A (index starts at 1) consisting of N integers:
        A1, A2, ..., AN and an integer B. The
        integer B denotes that from any place (suppose the index is i) in
        the array A, you can jump to any one of the place in the array A
        indexed i+1, i+2, …, i+B if this place can be
        jumped to. Also, if you step on the index i, you have to pay Ai coins.
        If Ai is -1, it means you can’t jump to the place indexed
        i in the array.

    Now, you start from the place indexed 1 in the array A, and your
        aim is to reach the place indexed N using the minimum coins. You need to return
        the path of indexes (starting from 1 to N) in the array you should take to get to the place
        indexed N using minimum coins.

    If there are multiple paths with the same cost, return the lexicographically smallest such
        path.

    If it's not possible to reach the place indexed N then you need to return an empty
        array.

    Example 1:

    Input: [1,2,4,-1,2], 2
Output: [1,3,5]

     

    Example 2:

    Input: [1,2,4,-1,2], 1
Output: []

     

    Note:

    
        Path Pa1, Pa2, ..., Pan is lexicographically
            smaller than Pb1, Pb2, ..., Pbm, if and only if at the
            first i where Pai and Pbi differ,
            Pai < Pbi; when no such i exists,
            then n < m.
        
        A1 >= 0. A2, ..., AN (if exist) will in the range of
            [-1, 100].
        
        Length of A is in the range of [1, 1000].
        B is in the range of [1, 100].
-----------------

# 474_Ones_and_Zeroes
# 474. Ones and Zeroes

In the computer world, use restricted resource you have to generate maximum benefit is what
        we always want to pursue.

    For now, suppose you are a dominator of m 0s and n 1s
        respectively. On the other hand, there is an array with strings consisting of only
        0s and 1s.

    Now your task is to find the maximum number of strings that you can form with given m
        0s and n 1s. Each 0 and 1 can be
        used at most once.

    Note:

    
        The given numbers of 0s and 1s will both not exceed
            100
        The size of given string array won't exceed 600.
    

     

    Example 1:

    Input: Array = {"10", "0001", "111001", "1", "0"}, m = 5, n = 3
Output: 4

Explanation: This are totally 4 strings can be formed by the using of 5 0s and 3 1s, which are “10,”0001”,”1”,”0”

     

    Example 2:

    Input: Array = {"10", "0", "1"}, m = 1, n = 1
Output: 2

Explanation: You could form "10", but then you'd have nothing left. Better form "0" and "1".
-----------------

# 111_Minimum_Depth_of_Binary_Tree
# 111. Minimum Depth of Binary Tree

Given a binary tree, find its minimum depth.

    The minimum depth is the number of nodes along the shortest path from the root node down to
        the nearest leaf node.

    Note: A leaf is a node with no children.

    Example:

    Given binary tree [3,9,20,null,null,15,7],

        3
   / \
  9  20
    /  \
   15   7

    return its minimum depth = 2.
-----------------

# 540_Single_Element_in_a_Sorted_Array
# 540. Single Element in a Sorted Array

You are given a sorted array consisting of only integers where every element appears exactly
        twice, except for one element which appears exactly once. Find this single element that
        appears only once.

     

    Example 1:

    Input: [1,1,2,3,3,4,4,8,8]
Output: 2

    Example 2:

    Input: [3,3,7,7,10,11,11]
Output: 10

     

    Note: Your solution should run in O(log n) time and O(1) space.
-----------------

# 1421_NPV_Queries
# 1421. NPV Queries


-----------------

# 347_Top_K_Frequent_Elements
# 347. Top K Frequent Elements

Given a non-empty array of integers, return the k most frequent elements.

    Example 1:

    Input: nums = [1,1,1,2,2,3], k = 2
Output: [1,2]
-----------------

# 157_Read_N_Characters_Given_Read4
# 157. Read N Characters Given Read4

Given a file and assume that you can only read the file using a given
        method read4, implement a method to read n characters.

     

    Method read4: 

    The API read4 reads 4 consecutive characters from the file, then writes
        those characters into the buffer array buf.

    The return value is the number of actual characters read.

    Note that read4() has its own file pointer, much like FILE *fp
        in C.

    Definition of read4:

        Parameter:  char[] buf
    Returns:    int

Note: buf[] is destination not source, the results from read4 will be copied to buf[]

    Below is a high level example of how read4 works:

    File file("abcdefghijk"); // File is "abcdefghijk", initially file pointer (fp) points to 'a'
char[] buf = new char[4]; // Create buffer with enough space to store characters
read4(buf); // read4 returns 4. Now buf = "abcd", fp points to 'e'
read4(buf); // read4 returns 4. Now buf = "efgh", fp points to 'i'
read4(buf); // read4 returns 3. Now buf = "ijk", fp points to end of file

     

    Method read:

    By using the read4 method, implement the method read that
        reads n characters from the file and store it in the buffer
        array buf. Consider that you cannot manipulate the file
        directly.

    The return value is the number of actual characters read.

    Definition of read: 

        Parameters:	char[] buf, int n
    Returns:	int

Note: buf[] is destination not source, you will need to write the results to buf[]

     

    Example 1:

    Input: file = "abc", n = 4
Output: 3
Explanation: After calling your read method, buf should contain "abc". We read a total of 3 characters from the file, so return 3. Note that "abc" is the file's content, not buf. buf is the destination buffer that you will have to write the results to.

    Example 2:

    Input: file = "abcde", n = 5
Output: 5
Explanation: After calling your read method, buf should contain "abcde". We read a total of 5 characters from the file, so return 5.

    Example 3:

    Input: file = "abcdABCD1234", n = 12
Output: 12
Explanation: After calling your read method, buf should contain "abcdABCD1234". We read a total of 12 characters from the file, so return 12.

    Example 4:

    Input: file = "leetcode", n = 5
Output: 5
Explanation: After calling your read method, buf should contain "leetc". We read a total of 5 characters from the file, so return 5.

     

    Note:

    
        Consider that you cannot manipulate the file directly, the file is only
            accesible for read4 but not for read.
        
        The read function will only be called once for each test case.
        You may assume the destination buffer array, buf, is guaranteed
            to have enough space for storing n characters.
-----------------

# 994_Rotting_Oranges
# 994. Rotting Oranges

In a given grid, each cell can have one of three values:

    
        the value 0 representing an empty cell;
        the value 1 representing a fresh orange;
        the value 2 representing a rotten orange.
    

    Every minute, any fresh orange that is adjacent (4-directionally) to a rotten orange becomes
        rotten.

    Return the minimum number of minutes that must elapse until no cell has a fresh orange. 
        If this is impossible, return -1 instead.
-----------------

# 132_Palindrome_Partitioning_II
# 132. Palindrome Partitioning II

Given a string s, partition s such that every substring of the partition is
        a palindrome.

    Return the minimum cuts needed for a palindrome partitioning of s.

    Example:

    Input: "aab"
Output: 1
Explanation: The palindrome partitioning ["aa","b"] could be produced using 1 cut.
-----------------

# 56_Merge_Intervals
# 56. Merge Intervals

Given a collection of intervals, merge all overlapping intervals.

    Example 1:

    Input: [[1,3],[2,6],[8,10],[15,18]]
Output: [[1,6],[8,10],[15,18]]
Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6].

    Example 2:

    Input: [[1,4],[4,5]]
Output: [[1,5]]
Explanation: Intervals [1,4] and [4,5] are considered overlapping.

    NOTE: input types have been changed on April 15, 2019. Please reset to
        default code definition to get new method signature.
-----------------

# 1793_Maximum_Score_of_a_Good_Subarray
# 1793. Maximum Score of a Good Subarray


-----------------

# 369_Plus_One_Linked_List
# 369. Plus One Linked List

Given a non-negative integer represented as non-empty a singly linked list of digits,
        plus one to the integer.

    You may assume the integer do not contain any leading zero, except the number 0 itself.

    The digits are stored such that the most significant digit is at the head of the list.
-----------------

# 1704_Determine_if_String_Halves_Are_Alike
# 1704. Determine if String Halves Are Alike


-----------------

# 500_Keyboard_Row
# 500. Keyboard Row

Given a List of words, return the words that can be typed using letters of alphabet on
        only one row's of American keyboard like the image below.

     

    
     

    Example:

    Input: ["Hello", "Alaska", "Dad", "Peace"]
Output: ["Alaska", "Dad"]

     

    Note:

    
        You may use one character in the keyboard more than once.
        You may assume the input string will only contain letters of alphabet.
-----------------

# 1202_Smallest_String_With_Swaps
# 1202. Smallest String With Swaps

You are given a string s, and an array of pairs of indices in the
        string pairs where pairs[i] = [a, b] indicates
        2 indices(0-indexed) of the string.

    You can swap the characters at any pair of indices in the given pairs any
        number of times.

    Return the lexicographically smallest string that s can be changed to
        after using the swaps.

     
    Example 1:

    Input: s = "dcab", pairs = [[0,3],[1,2]]
Output: "bacd"
Explaination:
Swap s[0] and s[3], s = "bcad"
Swap s[1] and s[2], s = "bacd"

    Example 2:

    Input: s = "dcab", pairs = [[0,3],[1,2],[0,2]]
Output: "abcd"
Explaination: 
Swap s[0] and s[3], s = "bcad"
Swap s[0] and s[2], s = "acbd"
Swap s[1] and s[2], s = "abcd"

    Example 3:

    Input: s = "cba", pairs = [[0,1],[1,2]]
Output: "abc"
Explaination: 
Swap s[0] and s[1], s = "bca"
Swap s[1] and s[2], s = "bac"
Swap s[0] and s[1], s = "abc"

     
    Constraints:

    
        1 <= s.length <= 10^5
        0 <= pairs.length <= 10^5
        0 <= pairs[i][0], pairs[i][1] < s.length
        s only contains lower case English letters.
-----------------

# 1635_Hopper_Company_Queries_I
# 1635. Hopper Company Queries I


-----------------

# 512_Game_Play_Analysis_II
# 512. Game Play Analysis II

Table: Activity

    +--------------+---------+
| Column Name  | Type    |
+--------------+---------+
| player_id    | int     |
| device_id    | int     |
| event_date   | date    |
| games_played | int     |
+--------------+---------+
(player_id, event_date) is the primary key of this table.
This table shows the activity of players of some game.
Each row is a record of a player who logged in and played a number of games (possibly 0) before logging out on some day using some device.

     

    Write a SQL query that reports the device that is first
        logged in for each player.

    The query result format is in the following example:

    Activity table:
+-----------+-----------+------------+--------------+
| player_id | device_id | event_date | games_played |
+-----------+-----------+------------+--------------+
| 1         | 2         | 2016-03-01 | 5            |
| 1         | 2         | 2016-05-02 | 6            |
| 2         | 3         | 2017-06-25 | 1            |
| 3         | 1         | 2016-03-02 | 0            |
| 3         | 4         | 2018-07-03 | 5            |
+-----------+-----------+------------+--------------+

Result table:
+-----------+-----------+
| player_id | device_id |
+-----------+-----------+
| 1         | 2         |
| 2         | 3         |
| 3         | 1         |
+-----------+-----------+
-----------------

# 454_4Sum_II
# 454. 4Sum II

Given four lists A, B, C, D of integer values, compute how many tuples (i, j, k,
        l) there are such that A[i] + B[j] + C[k] + D[l] is zero.

    To make problem a bit easier, all A, B, C, D have same length of N where 0 ≤ N ≤ 500.
        All integers are in the range of -228 to 228 - 1 and the result is
        guaranteed to be at most 231 - 1.

    Example:

    Input:
A = [ 1, 2]
B = [-2,-1]
C = [-1, 2]
D = [ 0, 2]

Output:
2

Explanation:
The two tuples are:
1. (0, 0, 0, 1) -> A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 0
2. (1, 1, 0, 0) -> A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0
-----------------

# 256_Paint_House
# 256. Paint House

There are a row of n houses, each house can be painted with one of the three colors:
        red, blue or green. The cost of painting each house with a certain color is different. You
        have to paint all the houses such that no two adjacent houses have the same color.

    The cost of painting each house with a certain color is represented by a n x 3
        cost matrix. For example, costs[0][0] is the cost of painting house 0 with
        color red; costs[1][2] is the cost of painting house 1 with color green, and so
        on... Find the minimum cost to paint all houses.

    Note:
        All costs are positive integers.

    Example:

    Input: [[17,2,17],[16,16,5],[14,3,19]]
Output: 10
Explanation: Paint house 0 into blue, paint house 1 into green, paint house 2 into blue.
             Minimum cost: 2 + 5 + 3 = 10.
-----------------

# 469_Convex_Polygon
# 469. Convex Polygon

Given a list of points that form a polygon when joined sequentially, find if this polygon is
        convex (Convex
            polygon definition).

     

    Note:

    
        There are at least 3 and at most 10,000 points.
        Coordinates are in the range -10,000 to 10,000.
        You may assume the polygon formed by given points is always a simple polygon (Simple polygon
            definition). In other words, we ensure that exactly two edges intersect at each
            vertex, and that edges otherwise don't intersect each other.
        
    

     

    Example 1:

    [[0,0],[0,1],[1,1],[1,0]]

Answer: True

Explanation:

    Example 2:

    [[0,0],[0,10],[10,10],[10,0],[5,5]]

Answer: False

Explanation:
-----------------

# 548_Split_Array_with_Equal_Sum
# 548. Split Array with Equal Sum

Given an array with n integers, you need to find if there are triplets (i, j, k) which
        satisfies following conditions:
    
         0 < i, i + 1 < j, j + 1 < k < n - 1
         Sum of subarrays (0, i - 1), (i + 1, j - 1), (j + 1, k - 1) and (k + 1, n - 1) should
            be equal.
        
    
    where we define that subarray (L, R) represents a slice of the original array starting from the
    element indexed L to the element indexed R.
    

    Example:
    Input: [1,2,1,2,1,2,1]
Output: True
Explanation:
i = 1, j = 3, k = 5.
sum(0, i - 1) = sum(0, 0) = 1
sum(i + 1, j - 1) = sum(2, 2) = 1
sum(j + 1, k - 1) = sum(4, 4) = 1
sum(k + 1, n - 1) = sum(6, 6) = 1

    

    Note:
    
         1 <= n <= 2000.
         Elements in the given array will be in range [-1,000,000, 1,000,000].
-----------------

# 681_Next_Closest_Time
# 681. Next Closest Time

Given a time represented in the format "HH:MM", form the next closest time by reusing the
        current digits. There is no limit on how many times a digit can be reused.

    You may assume the given input string is always valid. For example, "01:34", "12:09" are all
        valid. "1:34", "12:9" are all invalid.

    Example 1:
    Input: "19:34"
Output: "19:39"
Explanation: The next closest time choosing from digits 1, 9, 3, 4, is 19:39, which occurs 5 minutes later.  It is not 19:33, because this occurs 23 hours and 59 minutes later.

    

    Example 2:
    Input: "23:59"
Output: "22:22"
Explanation: The next closest time choosing from digits 2, 3, 5, 9, is 22:22. It may be assumed that the returned time is next day's time since it is smaller than the input time numerically.
-----------------

# 19_Remove_Nth_Node_From_End_of_List
# 19. Remove Nth Node From End of List

Given a linked list, remove the n-th node from the end of list and return its head.
    

    Example:

    Given linked list: 1->2->3->4->5, and n = 2.

After removing the second node from the end, the linked list becomes 1->2->3->5.

    Note:

    Given n will always be valid.

    Follow up:

    Could you do this in one pass?
-----------------

# 1244_Design_A_Leaderboard
# 1244. Design A Leaderboard

Design a Leaderboard class, which has 3 functions:

    
        addScore(playerId, score): Update the leaderboard by adding
            score to the given player's score. If there is no player with such id
            in the leaderboard, add him to the leaderboard with the given score.
        
        top(K): Return the score sum of the top K players.
        reset(playerId): Reset the score of the player with the given id to 0.
            It is guaranteed that the player was added to the leaderboard before calling this
            function.
        
    

    Initially, the leaderboard is empty.

     
    Example 1:

    Input: 
["Leaderboard","addScore","addScore","addScore","addScore","addScore","top","reset","reset","addScore","top"]
[[],[1,73],[2,56],[3,39],[4,51],[5,4],[1],[1],[2],[2,51],[3]]
Output: 
[null,null,null,null,null,null,73,null,null,null,141]

Explanation: 
Leaderboard leaderboard = new Leaderboard ();
leaderboard.addScore(1,73);   // leaderboard = [[1,73]];
leaderboard.addScore(2,56);   // leaderboard = [[1,73],[2,56]];
leaderboard.addScore(3,39);   // leaderboard = [[1,73],[2,56],[3,39]];
leaderboard.addScore(4,51);   // leaderboard = [[1,73],[2,56],[3,39],[4,51]];
leaderboard.addScore(5,4);    // leaderboard = [[1,73],[2,56],[3,39],[4,51],[5,4]];
leaderboard.top(1);           // returns 73;
leaderboard.reset(1);         // leaderboard = [[2,56],[3,39],[4,51],[5,4]];
leaderboard.reset(2);         // leaderboard = [[3,39],[4,51],[5,4]];
leaderboard.addScore(2,51);   // leaderboard = [[2,51],[3,39],[4,51],[5,4]];
leaderboard.top(3);           // returns 141 = 51 + 51 + 39;

     
    Constraints:

    
        1 <= playerId, K <= 10000
        It's guaranteed that K is less than or equal to the current number of
            players.
        
        1 <= score <= 100
        There will be at most 1000 function calls.
-----------------

# 1443_Minimum_Time_to_Collect_All_Apples_in_a_Tree
# 1443. Minimum Time to Collect All Apples in a Tree


-----------------

# 1549_The_Most_Recent_Orders_for_Each_Product
# 1549. The Most Recent Orders for Each Product


-----------------

# 259_3Sum_Smaller
# 259. 3Sum Smaller

Given an array of n integers nums and a target, find the number of index
        triplets i, j, k with 0 <= i < j < k < n that satisfy
        the condition nums[i] + nums[j] + nums[k] < target.

    Example:

    Input: nums = [-2,0,1,3], and target = 2
Output: 2
Explanation: Because there are two triplets which sums are less than 2:
             [-2,0,1]
             [-2,0,3]

    Follow up:
        Could you solve it in O(n2) runtime?
-----------------

# 680_Valid_Palindrome_II
# 680. Valid Palindrome II

Given a non-empty string s, you may delete at most one character. Judge
        whether you can make it a palindrome.
    

    Example 1:
    Input: "aba"
Output: True

    

    Example 2:
    Input: "abca"
Output: True
Explanation: You could delete the character 'c'.

    

    Note:
    
        The string will only contain lowercase characters a-z.
            The maximum length of the string is 50000.
-----------------

# 1136_Parallel_Courses
# 1136. Parallel Courses

There are N courses, labelled from 1 to N.

    We are given relations[i] = [X, Y], representing a prerequisite
        relationship between course X and course Y: course
        X has to be studied before course Y.

    In one semester you can study any number of courses as long as you have studied all the
        prerequisites for the course you are studying.

    Return the minimum number of semesters needed to study all courses.  If there is no way
        to study all the courses, return -1.

     

    Example 1:

    

    Input: N = 3, relations = [[1,3],[2,3]]
Output: 2
Explanation: 
In the first semester, courses 1 and 2 are studied. In the second semester, course 3 is studied.

    Example 2:

    

    Input: N = 3, relations = [[1,2],[2,3],[3,1]]
Output: -1
Explanation: 
No course can be studied because they depend on each other.

     

    Note:

    
        1 <= N <= 5000
        1 <= relations.length <= 5000
        relations[i][0] != relations[i][1]
        There are no repeated relations in the input.
-----------------

# 183_Customers_Who_Never_Order
# 183. Customers Who Never Order

Suppose that a website contains two tables, the Customers table and the Orders
        table. Write a SQL query to find all customers who never order anything.

    Table: Customers.

    +----+-------+
| Id | Name  |
+----+-------+
| 1  | Joe   |
| 2  | Henry |
| 3  | Sam   |
| 4  | Max   |
+----+-------+

    Table: Orders.

    +----+------------+
| Id | CustomerId |
+----+------------+
| 1  | 3          |
| 2  | 1          |
+----+------------+

    Using the above tables as example, return the following:

    +-----------+
| Customers |
+-----------+
| Henry     |
| Max       |
+-----------+
-----------------

# 1391_Check_if_There_is_a_Valid_Path_in_a_Grid
# 1391. Check if There is a Valid Path in a Grid


-----------------

# 294_Flip_Game_II
# 294. Flip Game II

You are playing the following Flip Game with your friend: Given a string that contains only
        these two characters: + and -, you and your friend take turns to
        flip two consecutive "++" into "--".
        The game ends when a person can no longer make a move and therefore the other person will be
        the winner.

    Write a function to determine if the starting player can guarantee a win.

    Example:

    Input: s = "++++"
Output: true
Explanation: The starting player can guarantee a win by flipping the middle "++" to become "+--+".

    Follow up:
        Derive your algorithm's runtime complexity.
-----------------

# 724_Find_Pivot_Index
# 724. Find Pivot Index

Given an array of integers nums, write a method that returns the "pivot"
        index of this array.

    We define the pivot index as the index where the sum of the numbers to the left of the index
        is equal to the sum of the numbers to the right of the index.

    If no such index exists, we should return -1. If there are multiple pivot indexes, you should
        return the left-most pivot index.

    Example 1:

    Input:
nums = [1, 7, 3, 6, 5, 6]
Output: 3
Explanation:
The sum of the numbers to the left of index 3 (nums[3] = 6) is equal to the sum of numbers to the right of index 3.
Also, 3 is the first index where this occurs.

     

    Example 2:

    Input:
nums = [1, 2, 3]
Output: -1
Explanation:
There is no index that satisfies the conditions in the problem statement.

     

    Note:

    
        The length of nums will be in the range [0, 10000].
        Each element nums[i] will be an integer in the range [-1000,
            1000].
-----------------

# 1717_Maximum_Score_From_Removing_Substrings
# 1717. Maximum Score From Removing Substrings


-----------------

# 675_Cut_Off_Trees_for_Golf_Event
# 675. Cut Off Trees for Golf Event

You are asked to cut off trees in a forest for a golf event. The forest is represented as a
        non-negative 2D map, in this map:

    
        0 represents the obstacle can't be reached.
        1 represents the ground can be walked through.
        The place with number bigger than 1 represents a tree can be
            walked through, and this positive number represents the tree's height.
        
    

     

    You are asked to cut off all the trees in this forest in the order of tree's
        height - always cut off the tree with lowest height first. And after cutting, the original
        place has the tree will become a grass (value 1).

    You will start from the point (0, 0) and you should output the minimum steps you need to
        walk to cut off all the trees. If you can't cut off all the trees, output -1 in that
        situation.

    You are guaranteed that no two trees have the same height and there is at least
        one tree needs to be cut off.

    Example 1:

    Input:
[
 [1,2,3],
 [0,0,4],
 [7,6,5]
]
Output: 6

     

    Example 2:

    Input:
[
 [1,2,3],
 [0,0,0],
 [7,6,5]
]
Output: -1

     

    Example 3:

    Input:
[
 [2,3,4],
 [0,0,5],
 [8,7,6]
]
Output: 6
Explanation: You started from the point (0,0) and you can cut off the tree in (0,0) directly without walking.

     

    Hint: size of the given matrix will not exceed 50x50.
-----------------

# 424_Longest_Repeating_Character_Replacement
# 424. Longest Repeating Character Replacement

Given a string s that consists of only uppercase English letters, you can
        perform at most k operations on that string.

    In one operation, you can choose any character of the string and change it
        to any other uppercase English character.

    Find the length of the longest sub-string containing all repeating letters you can get after
        performing the above operations.

    Note:
        Both the string's length and k will not exceed 104.

    Example 1:

    Input:
s = "ABAB", k = 2

Output:
4

Explanation:
Replace the two 'A's with two 'B's or vice versa.

     

    Example 2:

    Input:
s = "AABABBA", k = 1

Output:
4

Explanation:
Replace the one 'A' in the middle with 'B' and form "AABBBBA".
The substring "BBBB" has the longest repeating letters, which is 4.
-----------------

# 421_Maximum_XOR_of_Two_Numbers_in_an_Array
# 421. Maximum XOR of Two Numbers in an Array

Given a non-empty array of numbers, a0, a1, a2,
        … , an-1, where 0 ≤ ai < 231.

    Find the maximum result of ai XOR aj, where 0 ≤ i, j
        < n.

    Could you do this in O(n) runtime?

    Example:

    Input: [3, 10, 5, 25, 2, 8]

Output: 28

Explanation: The maximum result is 5 ^ 25 = 28.
-----------------

# 1638_Count_Substrings_That_Differ_by_One_Character
# 1638. Count Substrings That Differ by One Character


-----------------

# 665_Non-decreasing_Array
# 665. Non-decreasing Array

Given an array with n integers, your task is to check if it could become
        non-decreasing by modifying at most 1 element.
    

    
        We define an array is non-decreasing if array[i] <= array[i + 1] holds for
        every i (1 <= i < n).
    

    Example 1:
    Input: [4,2,3]
Output: True
Explanation: You could modify the first 4 to 1 to get a non-decreasing array.

    

    Example 2:
    Input: [4,2,1]
Output: False
Explanation: You can't get a non-decreasing array by modify at most one element.

    

    Note:
        The n belongs to [1, 10,000].
-----------------

# 783_Minimum_Distance_Between_BST_Nodes
# 783. Minimum Distance Between BST Nodes

Given a Binary Search Tree (BST) with the root node root, return the
        minimum difference between the values of any two different nodes in the tree.

    Example :

    Input: root = [4,2,6,1,3,null,null]
Output: 1
Explanation:
Note that root is a TreeNode object, not an array.

The given tree [4,2,6,1,3,null,null] is represented by the following diagram:

          4
        /   \
      2      6
     / \
    1   3

while the minimum difference in this tree is 1, it occurs between node 1 and node 2, also between node 3 and node 2.

    Note:

    
        The size of the BST will be between 2 and 100.
        The BST is always valid, each node's value is an integer, and each node's value
            is different.
-----------------

# 32_Longest_Valid_Parentheses
# 32. Longest Valid Parentheses

Given a string containing just the characters '(' and
        ')', find the length of the longest valid (well-formed) parentheses
        substring.

    Example 1:

    Input: "(()"
Output: 2
Explanation: The longest valid parentheses substring is "()"

    Example 2:

    Input: ")()())"
Output: 4
Explanation: The longest valid parentheses substring is "()()"
-----------------

# 1721_Swapping_Nodes_in_a_Linked_List
# 1721. Swapping Nodes in a Linked List


-----------------

# 1781_Sum_of_Beauty_of_All_Substrings
# 1781. Sum of Beauty of All Substrings


-----------------

# 33_Search_in_Rotated_Sorted_Array
# 33. Search in Rotated Sorted Array

Suppose an array sorted in ascending order is rotated at some pivot unknown to you
        beforehand.

    (i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]).

    You are given a target value to search. If found in the array return its index, otherwise
        return -1.

    You may assume no duplicate exists in the array.

    Your algorithm's runtime complexity must be in the order of O(log n).
    

    Example 1:

    Input: nums = [4,5,6,7,0,1,2], target = 0
Output: 4

    Example 2:

    Input: nums = [4,5,6,7,0,1,2], target = 3
Output: -1
-----------------

# 462_Minimum_Moves_to_Equal_Array_Elements_II
# 462. Minimum Moves to Equal Array Elements II

Given a non-empty integer array, find the minimum number of moves required to make all
        array elements equal, where a move is incrementing a selected element by 1 or decrementing a
        selected element by 1.

    You may assume the array's length is at most 10,000.

    Example:
    Input:
[1,2,3]

Output:
2

Explanation:
Only two moves are needed (remember each move increments or decrements one element):

[1,2,3]  =>  [2,2,3]  =>  [2,2,2]
-----------------

# 1444_Number_of_Ways_of_Cutting_a_Pizza
# 1444. Number of Ways of Cutting a Pizza


-----------------

# 660_Remove_9
# 660. Remove 9

Start from integer 1, remove any integer that contains 9 such as 9, 19, 29... 

    So now, you will have a new integer sequence: 1, 2, 3, 4, 5, 6, 7, 8, 10, 11, ...

    Given a positive integer n, you need to return the n-th integer after removing.
        Note that 1 will be the first integer.

    Example 1:
    Input: 9
Output: 10

    

    
         Hint: n will not exceed 9 x 10^8.
-----------------

# 901_Online_Stock_Span
# 901. Online Stock Span

Write a class StockSpanner which collects daily price quotes for some stock, and
        returns the span of that stock's price for the current day.

    The span of the stock's price today is defined as the maximum number of consecutive
        days (starting from today and going backwards) for which the price of the stock was
        less than or equal to today's price.

    For example, if the price of a stock over the next 7 days were [100, 80, 60, 70, 60,
        75, 85], then the stock spans would be [1, 1, 1, 2, 1, 4, 6].
-----------------

# 351_Android_Unlock_Patterns
# 351. Android Unlock Patterns

Given an Android 3x3 key lock screen and two integers m and n, where 1
        ≤ m ≤ n ≤ 9, count the total number of unlock patterns of the Android lock screen,
        which consist of minimum of m keys and maximum n keys.

     

    Rules for a valid pattern:

    
        Each pattern must connect at least m keys and at most n keys.
        All the keys must be distinct.
        If the line connecting two consecutive keys in the pattern passes through any other
            keys, the other keys must have previously selected in the pattern. No jumps through non
            selected key is allowed.
        
        The order of keys used matters.
    

     

    

     

    Explanation:

    | 1 | 2 | 3 |
| 4 | 5 | 6 |
| 7 | 8 | 9 |

    Invalid move: 4 - 1 - 3 - 6 
        Line 1 - 3 passes through key 2 which had not been selected in the pattern.

    Invalid move: 4 - 1 - 9 - 2
        Line 1 - 9 passes through key 5 which had not been selected in the pattern.

    Valid move: 2 - 4 - 1 - 3 - 6
        Line 1 - 3 is valid because it passes through key 2, which had been selected in the pattern
    

    Valid move: 6 - 5 - 4 - 1 - 9 - 2
        Line 1 - 9 is valid because it passes through key 5, which had been selected in the pattern.
    

     

    Example:
-----------------

# 1096_Brace_Expansion_II
# 1096. Brace Expansion II

Under a grammar given below, strings can represent a set of lowercase words.  Let's use
        R(expr) to denote the set of words the expression
        represents.

    Grammar can best be understood through simple examples:

    
        Single letters represent a singleton set containing that word.
            
                R("a") = {"a"}
                R("w") = {"w"}
            
        
        When we take a comma delimited list of 2 or more expressions, we take the union of
            possibilities.
            
                R("{a,b,c}") =
                    {"a","b","c"}
                R("{{a,b},{b,c}}") =
                    {"a","b","c"} (notice the final set
                    only contains each word at most once)
                
            
        
        When we concatenate two expressions, we take the set of possible concatenations between
            two words where the first word comes from the first expression and the second word comes
            from the second expression.
            
                R("{a,b}{c,d}") = {"ac","ad","bc","bd"}
                
                R("a{b,c}{d,e}f{g,h}") = {"abdfg", "abdfh",
                    "abefg", "abefh", "acdfg", "acdfh",
                    "acefg", "acefh"}
            
        
    

    Formally, the 3 rules for our grammar:

    
        For every lowercase letter x, we have R(x) = {x}
        For expressions e_1, e_2, ... , e_k with k >= 2, we
            have R({e_1,e_2,...}) = R(e_1) ∪ R(e_2) ∪ ...
        For expressions e_1 and e_2, we have R(e_1 + e_2) =
            {a + b for (a, b) in R(e_1) × R(e_2)}, where + denotes
            concatenation, and × denotes the cartesian product.
        
    

    Given an expression representing a set of words under the given grammar, return
        the sorted list of words that the expression represents.
-----------------

# 1189_Maximum_Number_of_Balloons
# 1189. Maximum Number of Balloons

Given a string text, you want to use the characters
        of text to form as many instances of the word "balloon"
        as possible.

    You can use each character in text at most once. Return the
        maximum number of instances that can be formed.

     
    Example 1:

    

    Input: text = "nlaebolko"
Output: 1

    Example 2:

    

    Input: text = "loonbalxballpoon"
Output: 2

    Example 3:

    Input: text = "leetcode"
Output: 0

     
    Constraints:

    
        1 <= text.length <= 10^4
        text consists of lower case English letters only.
-----------------

# 948_Bag_of_Tokens
# 948. Bag of Tokens

You have an initial power P, an initial score of 0 points, and a
        bag of tokens.

    Each token can be used at most once, has a value token[i], and has potentially
        two ways to use it.

    
        If we have at least token[i] power, we may play the token face up, losing
            token[i] power, and gaining 1 point.
        
        If we have at least 1 point, we may play the token face down, gaining
            token[i] power, and losing 1 point.
        
    

    Return the largest number of points we can have after playing any number of tokens.
-----------------

# 1359_Count_All_Valid_Pickup_and_Delivery_Options
# 1359. Count All Valid Pickup and Delivery Options


-----------------

# 1354_Construct_Target_Array_With_Multiple_Sums
# 1354. Construct Target Array With Multiple Sums


-----------------

# 25_Reverse_Nodes_in_k-Group
# 25. Reverse Nodes in k-Group

Given a linked list, reverse the nodes of a linked list k at a time and return its
        modified list.

    k is a positive integer and is less than or equal to the length of the linked list.
        If the number of nodes is not a multiple of k then left-out nodes in the end should
        remain as it is.

    
    

    Example:

    Given this linked list: 1->2->3->4->5

    For k = 2, you should return: 2->1->4->3->5

    For k = 3, you should return: 3->2->1->4->5

    Note:

    
        Only constant extra memory is allowed.
        You may not alter the values in the list's nodes, only nodes itself may be
            changed.
-----------------

# 360_Sort_Transformed_Array
# 360. Sort Transformed Array

Given a sorted array of integers nums and integer values a, b and
        c. Apply a quadratic function of the form f(x) = ax2 +
        bx + c to each element x in the array.

    The returned array must be in sorted order.

    Expected time complexity: O(n)
-----------------

# 1028_Recover_a_Tree_From_Preorder_Traversal
# 1028. Recover a Tree From Preorder Traversal

We run a preorder depth first search on the root of a binary tree.

    At each node in this traversal, we output D dashes (where D is the
        depth of this node), then we output the value of this node.  (If the
            depth of a node is D, the depth of its immediate child is D+1. 
            The depth of the root node is 0.)

    If a node has only one child, that child is guaranteed to be the left child.

    Given the output S of this traversal, recover the tree and return its
        root.

     

    Example 1:

    

    Input: "1-2--3--4-5--6--7"
Output: [1,2,5,3,4,6,7]
-----------------

# 135_Candy
# 135. Candy

There are N children standing in a line. Each child is assigned a rating value.

    You are giving candies to these children subjected to the following requirements:

    
        Each child must have at least one candy.
        Children with a higher rating get more candies than their neighbors.
    

    What is the minimum candies you must give?

    Example 1:

    Input: [1,0,2]
Output: 5
Explanation: You can allocate to the first, second and third child with 2, 1, 2 candies respectively.

    Example 2:

    Input: [1,2,2]
Output: 4
Explanation: You can allocate to the first, second and third child with 1, 2, 1 candies respectively.
             The third child gets 1 candy because it satisfies the above two conditions.
-----------------

# 244_Shortest_Word_Distance_II
# 244. Shortest Word Distance II

Design a class which receives a list of words in the constructor, and implements a method
        that takes two words word1 and word2 and return the shortest distance
        between these two words in the list. Your method will be called repeatedly many
        times with different parameters. 

    Example:
        Assume that words = ["practice", "makes", "perfect",
            "coding", "makes"].

    Input: word1 = “coding”, word2 = “practice”
Output: 3

    Input: word1 = "makes", word2 = "coding"
Output: 1

    Note:
        You may assume that word1 does not equal to word2, and
        word1 and word2 are both in the list.
-----------------

# 506_Relative_Ranks
# 506. Relative Ranks

Given scores of N athletes, find their relative ranks and the people with the top
        three highest scores, who will be awarded medals: "Gold Medal", "Silver Medal" and "Bronze
        Medal".

    Example 1:
    Input: [5, 4, 3, 2, 1]
Output: ["Gold Medal", "Silver Medal", "Bronze Medal", "4", "5"]
Explanation: The first three athletes got the top three highest scores, so they got "Gold Medal", "Silver Medal" and "Bronze Medal". For the left two athletes, you just need to output their relative ranks according to their scores.

    

    Note:
    
        N is a positive integer and won't exceed 10,000.
        All the scores of athletes are guaranteed to be unique.
-----------------

# 1119_Remove_Vowels_from_a_String
# 1119. Remove Vowels from a String

Given a string S, remove the vowels 'a',
        'e', 'i', 'o', and 'u'
        from it, and return the new string.

     

    Example 1:

    Input: "leetcodeisacommunityforcoders"
Output: "ltcdscmmntyfrcdrs"

    Example 2:

    Input: "aeiou"
Output: ""

     

    Note:

    
        S consists of lowercase English letters only.
        1 <= S.length <= 1000
-----------------

# 290_Word_Pattern
# 290. Word Pattern

Given a pattern and a string str, find if str follows
        the same pattern.

    Here follow means a full match, such that there is a bijection between a letter in
        pattern and a non-empty word in str.

    Example 1:

    Input: pattern = "abba", str = "dog cat cat dog"
Output: true

    Example 2:

    Input:pattern = "abba", str = "dog cat cat fish"
Output: false

    Example 3:

    Input: pattern = "aaaa", str = "dog cat cat dog"
Output: false

    Example 4:

    Input: pattern = "abba", str = "dog dog dog dog"
Output: false

    Notes:
        You may assume pattern contains only lowercase letters, and str
        contains lowercase letters that may be separated by a single space.
-----------------

# 66_Plus_One
# 66. Plus One

Given a non-empty array of digits representing a non-negative integer,
        plus one to the integer.

    The digits are stored such that the most significant digit is at the head of the list, and
        each element in the array contain a single digit.

    You may assume the integer does not contain any leading zero, except the number 0 itself.

    Example 1:

    Input: [1,2,3]
Output: [1,2,4]
Explanation: The array represents the integer 123.

    Example 2:

    Input: [4,3,2,1]
Output: [4,3,2,2]
Explanation: The array represents the integer 4321.
-----------------

# 289_Game_of_Life
# 289. Game of Life

According to the Wikipedia's article: "The Game of
        Life, also known simply as Life, is a cellular automaton devised by the British
        mathematician John Horton Conway in 1970."

    Given a board with m by n cells, each cell has an initial state
        live (1) or dead (0). Each cell interacts with its eight
            neighbors (horizontal, vertical, diagonal) using the following four rules (taken
        from the above Wikipedia article):

    
        Any live cell with fewer than two live neighbors dies, as if caused by
            under-population.
        
        Any live cell with two or three live neighbors lives on to the next generation.
        Any live cell with more than three live neighbors dies, as if by over-population..
        Any dead cell with exactly three live neighbors becomes a live cell, as if by
            reproduction.
        
    

    Write a function to compute the next state (after one update) of the board given its current
        state. The next state is created by applying the above rules simultaneously to every cell in the current state, where births and deaths occur simultaneously.
    

    Example:

    Input:
[
  [0,1,0],
  [0,0,1],
  [1,1,1],
  [0,0,0]
]
Output:
[
  [0,0,0],
  [1,0,1],
  [0,1,1],
  [0,1,0]
]

    Follow up:

    
        Could you solve it in-place? Remember that the board needs to be updated at the same
            time: You cannot update some cells first and then use their updated values to update
            other cells.
        
        In this question, we represent the board using a 2D array. In principle, the board is
            infinite, which would cause problems when the active area encroaches the border of the
            array. How would you address these problems?
-----------------

# 1357_Apply_Discount_Every_n_Orders
# 1357. Apply Discount Every n Orders


-----------------

# 471_Encode_String_with_Shortest_Length
# 471. Encode String with Shortest Length

Given a non-empty string, encode the string such that its encoded length is the
        shortest.

    The encoding rule is: k[encoded_string], where the encoded_string inside
        the square brackets is being repeated exactly k times.

    Note:

    
        k will be a positive integer and encoded string will not be empty or have extra
            space.
        
        You may assume that the input string contains only lowercase English letters. The string's
            length is at most 160.
        
        If an encoding process does not make the string shorter, then do not encode it. If there
            are several solutions, return any of them is fine.
        
    

     

    Example 1:

    Input: "aaa"
Output: "aaa"
Explanation: There is no way to encode it such that it is shorter than the input string, so we do not encode it.

     

    Example 2:

    Input: "aaaaa"
Output: "5[a]"
Explanation: "5[a]" is shorter than "aaaaa" by 1 character.

     

    Example 3:

    Input: "aaaaaaaaaa"
Output: "10[a]"
Explanation: "a9[a]" or "9[a]a" are also valid solutions, both of them have the same length = 5, which is the same as "10[a]".

     

    Example 4:

    Input: "aabcaabcd"
Output: "2[aabc]d"
Explanation: "aabc" occurs twice, so one answer can be "2[aabc]d".

     

    Example 5:

    Input: "abbbabbbcabbbabbbc"
Output: "2[2[abbb]c]"
Explanation: "abbbabbbc" occurs twice, but "abbbabbbc" can also be encoded to "2[abbb]c", so one answer can be "2[2[abbb]c]".
-----------------

# 1706_Where_Will_the_Ball_Fall
# 1706. Where Will the Ball Fall


-----------------

# 1616_Split_Two_Strings_to_Make_Palindrome
# 1616. Split Two Strings to Make Palindrome


-----------------

# 178_Rank_Scores
# 178. Rank Scores

Write a SQL query to rank scores. If there is a tie between two scores, both should have the
        same ranking. Note that after a tie, the next ranking number should be the next consecutive
        integer value. In other words, there should be no "holes" between ranks.

    +----+-------+
| Id | Score |
+----+-------+
| 1  | 3.50  |
| 2  | 3.65  |
| 3  | 4.00  |
| 4  | 3.85  |
| 5  | 4.00  |
| 6  | 3.65  |
+----+-------+

    For example, given the above Scores table, your query should generate the
        following report (order by highest score):

    +-------+------+
| Score | Rank |
+-------+------+
| 4.00  | 1    |
| 4.00  | 1    |
| 3.85  | 2    |
| 3.65  | 3    |
| 3.65  | 3    |
| 3.50  | 4    |
+-------+------+
-----------------

# 1316_Distinct_Echo_Substrings
# 1316. Distinct Echo Substrings


-----------------

# 1126_Active_Businesses
# 1126. Active Businesses

Table: Events

    +---------------+---------+
| Column Name   | Type    |
+---------------+---------+
| business_id   | int     |
| event_type    | varchar |
| occurences    | int     |
+---------------+---------+
(business_id, event_type) is the primary key of this table.
Each row in the table logs the info that an event of some type occured at some business for a number of times.

     

    Write an SQL query to find all active businesses.

    An active business is a business that has more than one event type with occurences
        greater than the average occurences of that event type among all businesses.

    The query result format is in the following example:

    Events table:
+-------------+------------+------------+
| business_id | event_type | occurences |
+-------------+------------+------------+
| 1           | reviews    | 7          |
| 3           | reviews    | 3          |
| 1           | ads        | 11         |
| 2           | ads        | 7          |
| 3           | ads        | 6          |
| 1           | page views | 3          |
| 2           | page views | 12         |
+-------------+------------+------------+

Result table:
+-------------+
| business_id |
+-------------+
| 1           |
+-------------+
Average for 'reviews', 'ads' and 'page views' are (7+3)/2=5, (11+7+6)/3=8, (3+12)/2=7.5 respectively.
Business with id 1 has 7 'reviews' events (more than 5) and 11 'ads' events (more than 8) so it is an active business.
-----------------

# 867_Transpose_Matrix
# 867. Transpose Matrix

Given a matrix A, return the transpose of A.

    The transpose of a matrix is the matrix flipped over it's main diagonal, switching the
        row and column indices of the matrix.
-----------------

# 1543_Fix_Product_Name_Format
# 1543. Fix Product Name Format


-----------------

# 1707_Maximum_XOR_With_an_Element_From_Array
# 1707. Maximum XOR With an Element From Array


-----------------

# 1623_All_Valid_Triplets_That_Can_Represent_a_Country
# 1623. All Valid Triplets That Can Represent a Country


-----------------

# 763_Partition_Labels
# 763. Partition Labels

A string S of lowercase letters is given. We want to partition this string into
        as many parts as possible so that each letter appears in at most one part, and return a list
        of integers representing the size of these parts.
    
    

    Example 1:
    Input: S = "ababcbacadefegdehijhklij"
Output: [9,7,8]
Explanation:
The partition is "ababcbaca", "defegde", "hijhklij".
This is a partition so that each letter appears in at most one part.
A partition like "ababcbacadefegde", "hijhklij" is incorrect, because it splits S into less parts.

    

    Note:
    
        S will have length in range [1, 500].
        S will consist of lowercase letters ('a' to 'z')
            only.
-----------------

# 147_Insertion_Sort_List
# 147. Insertion Sort List

Sort a linked list using insertion sort.

    
    

    
        A graphical example of insertion sort. The partial sorted list (black) initially
            contains only the first element in the list.
            With each iteration one element (red) is removed from the input data and inserted
            in-place into the sorted list
        
        
         
    

    
    

    Algorithm of Insertion Sort:

    
        Insertion sort iterates, consuming one input element each repetition, and growing a
            sorted output list.
        
        At each iteration, insertion sort removes one element from the input data, finds the
            location it belongs within the sorted list, and inserts it there.
        
        It repeats until no input elements remain.
    

    
        Example 1:

    Input: 4->2->1->3
Output: 1->2->3->4

    Example 2:

    Input: -1->5->3->4->0
Output: -1->0->3->4->5
-----------------

# 104_Maximum_Depth_of_Binary_Tree
# 104. Maximum Depth of Binary Tree

Given a binary tree, find its maximum depth.

    The maximum depth is the number of nodes along the longest path from the root node down to
        the farthest leaf node.

    Note: A leaf is a node with no children.

    Example:

    Given binary tree [3,9,20,null,null,15,7],

        3
   / \
  9  20
    /  \
   15   7

    return its depth = 3.
-----------------

# 114_Flatten_Binary_Tree_to_Linked_List
# 114. Flatten Binary Tree to Linked List

Given a binary tree, flatten it to a linked list in-place.

    For example, given the following tree:

        1
   / \
  2   5
 / \   \
3   4   6

    The flattened tree should look like:

    1
 \
  2
   \
    3
     \
      4
       \
        5
         \
          6
-----------------

# 499_The_Maze_III
# 499. The Maze III

There is a ball in a maze with empty spaces and walls. The ball can go through empty
        spaces by rolling up (u), down (d), left (l) or right (r), but
        it won't stop rolling until hitting a wall. When the ball stops, it could choose the
        next direction. There is also a hole in this maze. The ball will drop into the hole
        if it rolls on to the hole.

    Given the ball position, the hole position and the maze, find out how
        the ball could drop into the hole by moving the shortest distance. The distance is
        defined by the number of empty spaces traveled by the ball from the start position
        (excluded) to the hole (included). Output the moving directions by using 'u',
        'd', 'l' and 'r'. Since there could be several different shortest
        ways, you should output the lexicographically smallest way. If the ball cannot reach
        the hole, output "impossible".

    The maze is represented by a binary 2D array. 1 means the wall and 0 means the empty space.
        You may assume that the borders of the maze are all walls. The ball and the hole coordinates
        are represented by row and column indexes.

     

    Example 1:

    Input 1: a maze represented by a 2D array

0 0 0 0 0
1 1 0 0 1
0 0 0 0 0
0 1 0 0 1
0 1 0 0 0

Input 2: ball coordinate (rowBall, colBall) = (4, 3)
Input 3: hole coordinate (rowHole, colHole) = (0, 1)

Output: "lul"

Explanation: There are two shortest ways for the ball to drop into the hole.
The first way is left -> up -> left, represented by "lul".
The second way is up -> left, represented by 'ul'.
Both ways have shortest distance 6, but the first way is lexicographically smaller because 'l' < 'u'. So the output is "lul".

    Example 2:

    Input 1: a maze represented by a 2D array

0 0 0 0 0
1 1 0 0 1
0 0 0 0 0
0 1 0 0 1
0 1 0 0 0

Input 2: ball coordinate (rowBall, colBall) = (4, 3)
Input 3: hole coordinate (rowHole, colHole) = (3, 0)

Output: "impossible"

Explanation: The ball cannot reach the hole.

     

    Note:

    
        There is only one ball and one hole in the maze.
        Both the ball and hole exist on an empty space, and they will not be at the same
            position initially.
        
        The given maze does not contain border (like the red rectangle in the example pictures),
            but you could assume the border of the maze are all walls.
        
        The maze contains at least 2 empty spaces, and the width and the height of the maze won't
            exceed 30.
-----------------

# 537_Complex_Number_Multiplication
# 537. Complex Number Multiplication

Given two strings representing two complex
        numbers.

    
        You need to return a string representing their multiplication. Note i2 = -1
        according to the definition.
    

    Example 1:
    Input: "1+1i", "1+1i"
Output: "0+2i"
Explanation: (1 + i) * (1 + i) = 1 + i2 + 2 * i = 2i, and you need convert it to the form of 0+2i.

    

    Example 2:
    Input: "1+-1i", "1+-1i"
Output: "0+-2i"
Explanation: (1 - i) * (1 - i) = 1 + i2 - 2 * i = -2i, and you need convert it to the form of 0+-2i.

    

    Note:
    
        The input strings will not have extra blank.
        The input strings will be given in the form of a+bi, where the integer a
            and b will both belong to the range of [-100, 100]. And the output should be
                also in this form.
-----------------

# 1825_Finding_MK_Average
# 1825. Finding MK Average


-----------------

# 252_Meeting_Rooms
# 252. Meeting Rooms

Given an array of meeting time intervals consisting of start and end times [[s1,e1],[s2,e2],...]
        (si < ei), determine if a person could attend all meetings.

    Example 1:

    Input: [[0,30],[5,10],[15,20]]
Output: false

    Example 2:

    Input: [[7,10],[2,4]]
Output: true

    NOTE: input types have been changed on April 15, 2019. Please reset to
        default code definition to get new method signature.
-----------------

# 1259_Handshakes_That_Don't_Cross
# 1259. Handshakes That Don't Cross


-----------------

# 1310_XOR_Queries_of_a_Subarray
# 1310. XOR Queries of a Subarray


-----------------

# 1154_Day_of_the_Year
# 1154. Day of the Year

Given a string date representing a Gregorian calendar
        date formatted as YYYY-MM-DD, return the day number of the year.

     
    Example 1:

    Input: date = "2019-01-09"
Output: 9
Explanation: Given date is the 9th day of the year in 2019.

    Example 2:

    Input: date = "2019-02-10"
Output: 41

    Example 3:

    Input: date = "2003-03-01"
Output: 60

    Example 4:

    Input: date = "2004-03-01"
Output: 61

     
    Constraints:

    
        date.length == 10
        date[4] == date[7] == '-', and all other date[i]'s
            are digits
        
        date represents a calendar date between Jan 1st, 1900 and Dec 31, 2019.
-----------------

# 693_Binary_Number_with_Alternating_Bits
# 693. Binary Number with Alternating Bits

Given a positive integer, check whether it has alternating bits: namely, if two adjacent bits
        will always have different values.

    Example 1:
    Input: 5
Output: True
Explanation:
The binary representation of 5 is: 101

    

    Example 2:
    Input: 7
Output: False
Explanation:
The binary representation of 7 is: 111.

    

    Example 3:
    Input: 11
Output: False
Explanation:
The binary representation of 11 is: 1011.

    

    Example 4:
    Input: 10
Output: True
Explanation:
The binary representation of 10 is: 1010.
-----------------

# 1488_Avoid_Flood_in_The_City
# 1488. Avoid Flood in The City


-----------------

# 1086_High_Five
# 1086. High Five

Given a list of scores of different students, return the average score of each student's
        top five scores in the order of each student's id.

    Each entry items[i] has items[i][0] the student's id, and
        items[i][1] the student's score.  The average score is calculated
        using integer division.

     

    Example 1:

    Input: [[1,91],[1,92],[2,93],[2,97],[1,60],[2,77],[1,65],[1,87],[1,100],[2,100],[2,76]]
Output: [[1,87],[2,88]]
Explanation: 
The average of the student with id = 1 is 87.
The average of the student with id = 2 is 88.6. But with integer division their average converts to 88.

     

    Note:

    
        1 <= items.length <= 1000
        items[i].length == 2
        The IDs of the students is between 1 to 1000
        The score of the students is between 1 to 100
        For each student, there are at least 5 scores
-----------------

# 1690_Stone_Game_VII
# 1690. Stone Game VII


-----------------

# 422_Valid_Word_Square
# 422. Valid Word Square

Given a sequence of words, check whether it forms a valid word square.

    A sequence of words forms a valid word square if the kth row and column
        read the exact same string, where 0 ≤ k < max(numRows, numColumns).

    Note:
    
        The number of words given is at least 1 and does not exceed 500.
        Word length will be at least 1 and does not exceed 500.
        Each word contains only lowercase English alphabet a-z.
    
    

    Example 1:
    Input:
[
  "abcd",
  "bnrt",
  "crmy",
  "dtye"
]

Output:
true

Explanation:
The first row and first column both read "abcd".
The second row and second column both read "bnrt".
The third row and third column both read "crmy".
The fourth row and fourth column both read "dtye".

Therefore, it is a valid word square.

    

    Example 2:
    Input:
[
  "abcd",
  "bnrt",
  "crm",
  "dt"
]

Output:
true

Explanation:
The first row and first column both read "abcd".
The second row and second column both read "bnrt".
The third row and third column both read "crm".
The fourth row and fourth column both read "dt".

Therefore, it is a valid word square.

    

    Example 3:
    Input:
[
  "ball",
  "area",
  "read",
  "lady"
]

Output:
false

Explanation:
The third row reads "read" while the third column reads "lead".

Therefore, it is NOT a valid word square.
-----------------

# 1598_Crawler_Log_Folder
# 1598. Crawler Log Folder


-----------------

# 409_Longest_Palindrome
# 409. Longest Palindrome

Given a string which consists of lowercase or uppercase letters, find the length of the
        longest palindromes that can be built with those letters.

    This is case sensitive, for example "Aa" is not considered a palindrome here.
    

    Note:
        Assume the length of given string will not exceed 1,010.
    

    Example: 
    Input:
"abccccdd"

Output:
7

Explanation:
One longest palindrome that can be built is "dccaccd", whose length is 7.
-----------------

# 1746_Maximum_Subarray_Sum_After_One_Operation
# 1746. Maximum Subarray Sum After One Operation


-----------------

# 868_Binary_Gap
# 868. Binary Gap

Given a positive integer N, find and return the longest distance between
        two consecutive 1's in the binary representation of N.

    If there aren't two consecutive 1's, return 0.
-----------------

# 306_Additive_Number
# 306. Additive Number

Additive number is a string whose digits can form additive sequence.

    A valid additive sequence should contain at least three numbers. Except for the first
        two numbers, each subsequent number in the sequence must be the sum of the preceding two.
    

    Given a string containing only digits '0'-'9', write a function
        to determine if it's an additive number.

    Note: Numbers in the additive sequence cannot have leading zeros, so sequence
        1, 2, 03 or 1, 02, 3 is invalid.

     
    Example 1:

    Input: "112358"
Output: true
Explanation: The digits can form an additive sequence: 1, 1, 2, 3, 5, 8.
             1 + 1 = 2, 1 + 2 = 3, 2 + 3 = 5, 3 + 5 = 8

    Example 2:

    Input: "199100199"
Output: true
Explanation: The additive sequence is: 1, 99, 100, 199. 
             1 + 99 = 100, 99 + 100 = 199

     
    Constraints:

    
        num consists only of digits '0'-'9'.
        
        1 <= num.length <= 35
    

    Follow up:
        How would you handle overflow for very large input integers?
-----------------

# 164_Maximum_Gap
# 164. Maximum Gap

Given an unsorted array, find the maximum difference between the successive elements in its
        sorted form.

    Return 0 if the array contains less than 2 elements.

    Example 1:

    Input: [3,6,9,1]
Output: 3
Explanation: The sorted form of the array is [1,3,6,9], either
             (3,6) or (6,9) has the maximum difference 3.

    Example 2:

    Input: [10]
Output: 0
Explanation: The array contains less than 2 elements, therefore return 0.

    Note:

    
        You may assume all elements in the array are non-negative integers and fit in the 32-bit
            signed integer range.
        
        Try to solve it in linear time/space.
-----------------

# 1045_Customers_Who_Bought_All_Products
# 1045. Customers Who Bought All Products

Table: Customer

    +-------------+---------+
| Column Name | Type    |
+-------------+---------+
| customer_id | int     |
| product_key | int     |
+-------------+---------+
product_key is a foreign key to Product table.

    Table: Product

    +-------------+---------+
| Column Name | Type    |
+-------------+---------+
| product_key | int     |
+-------------+---------+
product_key is the primary key column for this table.

     

    Write an SQL query for a report that provides the customer ids from
        the Customer table that bought all the products in the Product table.
    

    For example:

    Customer table:
+-------------+-------------+
| customer_id | product_key |
+-------------+-------------+
| 1           | 5           |
| 2           | 6           |
| 3           | 5           |
| 3           | 6           |
| 1           | 6           |
+-------------+-------------+

Product table:
+-------------+
| product_key |
+-------------+
| 5           |
| 6           |
+-------------+

Result table:
+-------------+
| customer_id |
+-------------+
| 1           |
| 3           |
+-------------+
The customers who bought all the products (5 and 6) are customers with id 1 and 3.
-----------------

# 917_Reverse_Only_Letters
# 917. Reverse Only Letters

Given a string S, return the "reversed" string where all characters
        that are not a letter stay in the same place, and all letters reverse their positions.
-----------------

# 364_Nested_List_Weight_Sum_II
# 364. Nested List Weight Sum II

Given a nested list of integers, return the sum of all integers in the list weighted by their
        depth.

    Each element is either an integer, or a list -- whose elements may also be integers or other
        lists.

    Different from the previous
        question where weight is increasing from root to leaf, now the weight is defined from
        bottom up. i.e., the leaf level integers have weight 1, and the root level integers have the
        largest weight.

    Example 1:
-----------------

# 508_Most_Frequent_Subtree_Sum
# 508. Most Frequent Subtree Sum

Given the root of a tree, you are asked to find the most frequent subtree sum. The subtree
        sum of a node is defined as the sum of all the node values formed by the subtree rooted at
        that node (including the node itself). So what is the most frequent subtree sum value? If
        there is a tie, return all the values with the highest frequency in any order.
    

    Examples 1
        Input:
      5
 /  \
2   -3

    return [2, -3, 4], since all the values happen only once, return all of them in any order.
    

    Examples 2
        Input:
      5
 /  \
2   -5

    return [2], since 2 happens twice, however -5 only occur once.
    

    Note:
        You may assume the sum of values in any subtree is in the range of 32-bit signed integer.
-----------------

# 1007_Minimum_Domino_Rotations_For_Equal_Row
# 1007. Minimum Domino Rotations For Equal Row

In a row of dominoes, A[i] and B[i] represent the top and bottom
        halves of the i-th domino.  (A domino is a tile with two numbers from 1 to
        6 - one on each half of the tile.)

    We may rotate the i-th domino, so that A[i] and B[i]
        swap values.

    Return the minimum number of rotations so that all the values in A are the same,
        or all the values in B are the same.

    If it cannot be done, return -1.

     

    Example 1:

    

    Input: A = [2,1,2,4,2,2], B = [5,2,6,2,3,2]
Output: 2
Explanation: 
The first figure represents the dominoes as given by A and B: before we do any rotations.
If we rotate the second and fourth dominoes, we can make every value in the top row equal to 2, as indicated by the second figure.

    Example 2:

    Input: A = [3,5,1,2,3], B = [3,6,3,3,4]
Output: -1
Explanation: 
In this case, it is not possible to rotate the dominoes to make one row of values equal.

     

    Note:

    
        1 <= A[i], B[i] <= 6
        2 <= A.length == B.length <= 20000
-----------------

# 1748_Sum_of_Unique_Elements
# 1748. Sum of Unique Elements


-----------------

# 1367_Linked_List_in_Binary_Tree
# 1367. Linked List in Binary Tree


-----------------

# 603_Consecutive_Available_Seats
# 603. Consecutive Available Seats

Several friends at a cinema ticket office would like to reserve consecutive available
    seats.
    Can you help to query all the consecutive available seats order by the seat_id using the
    following cinema table?
    | seat_id | free |
|---------|------|
| 1       | 1    |
| 2       | 0    |
| 3       | 1    |
| 4       | 1    |
| 5       | 1    |

     
    Your query should return the following result for the sample case above.

     

    | seat_id |
|---------|
| 3       |
| 4       |
| 5       |

    Note:

    
        The seat_id is an auto increment int, and free is bool ('1' means free, and
            '0' means occupied.).
        
        Consecutive available seats are more than 2(inclusive) seats consecutively available.
-----------------

# 1162_As_Far_from_Land_as_Possible
# 1162. As Far from Land as Possible

Given an N x N grid containing only values 0 and
        1, where 0 represents water and 1
        represents land, find a water cell such that its distance to the nearest land cell is
        maximized and return the distance.

    The distance used in this problem is the Manhattan distance: the distance
        between two cells (x0, y0) and (x1, y1) is |x0 - x1| + |y0 -
            y1|.

    If no land or water exists in the grid, return -1.

     

    Example 1:

    

    Input: [[1,0,1],[0,0,0],[1,0,1]]
Output: 2
Explanation: 
The cell (1, 1) is as far as possible from all the land with distance 2.

    Example 2:

    

    Input: [[1,0,0],[0,0,0],[0,0,0]]
Output: 4
Explanation: 
The cell (2, 2) is as far as possible from all the land with distance 4.

     

    Note:

    
        1 <= grid.length == grid[0].length <= 100
        grid[i][j] is 0 or 1
-----------------

# 172_Factorial_Trailing_Zeroes
# 172. Factorial Trailing Zeroes

Given an integer n, return the number of trailing zeroes in n!.

    Example 1:

    Input: 3
Output: 0
Explanation: 3! = 6, no trailing zero.

    Example 2:

    Input: 5
Output: 1
Explanation: 5! = 120, one trailing zero.

    Note: Your solution should be in logarithmic time complexity.
-----------------

# 678_Valid_Parenthesis_String
# 678. Valid Parenthesis String

Given a string containing only three types of characters: '(', ')' and '*', write a function
        to check whether this string is valid. We define the validity of a string by these rules:
    
        Any left parenthesis '(' must have a corresponding right parenthesis ')'.
        
        Any right parenthesis ')' must have a corresponding left parenthesis '('.
        
        Left parenthesis '(' must go before the corresponding right parenthesis
            ')'.
        
        '*' could be treated as a single right parenthesis ')' or a
            single left parenthesis '(' or an empty string.
        
        An empty string is also valid.
    
    

    Example 1:
    Input: "()"
Output: True

    

    Example 2:
    Input: "(*)"
Output: True

    

    Example 3:
    Input: "(*))"
Output: True

    

    Note:
    
        The string size will be in the range [1, 100].
-----------------

# 1080_Insufficient_Nodes_in_Root_to_Leaf_Paths
# 1080. Insufficient Nodes in Root to Leaf Paths

Given the root of a binary tree, consider all root to leaf paths:
        paths from the root to any leaf.  (A leaf is a node with no children.)

    A node is insufficient if every such root to leaf
        path intersecting this node has sum strictly less than limit.
    

    Delete all insufficient nodes simultaneously, and return the root of the resulting binary
        tree.

     

    Example 1:

    
Input: root = [1,2,3,4,-99,-99,7,8,9,-99,-99,12,13,-99,14], limit = 1

Output: [1,2,3,4,null,null,7,8,9,null,14]
-----------------

# 770_Basic_Calculator_IV
# 770. Basic Calculator IV

Given an expression such as expression = "e + 8 - a +
        5" and an evaluation map such as {"e": 1} (given in terms
        of evalvars = ["e"] and evalints = [1]), return a list
        of tokens representing the simplified expression, such as ["-1*a","14"]
    

    
        An expression alternates chunks and symbols, with a space separating each chunk and
            symbol.
        
        A chunk is either an expression in parentheses, a variable, or a non-negative integer.
        
        A variable is a string of lowercase letters (not including digits.) Note that variables
            can be multiple letters, and note that variables never have a leading coefficient or
            unary operator like "2x" or "-x".
        
    

    Expressions are evaluated in the usual order: brackets first, then multiplication, then
        addition and subtraction. For example, expression = "1 + 2 * 3" has
        an answer of ["7"].

    The format of the output is as follows:

    
        For each term of free variables with non-zero coefficient, we write the free variables
            within a term in sorted order lexicographically. For example, we would never write a
            term like "b*a*c", only "a*b*c".
        
        Terms have degree equal to the number of free variables being multiplied, counting
            multiplicity. (For example, "a*a*b*c" has degree 4.) We write the
            largest degree terms of our answer first, breaking ties by lexicographic order ignoring
            the leading coefficient of the term.
        
        The leading coefficient of the term is placed directly to the left with an asterisk
            separating it from the variables (if they exist.)  A leading coefficient of 1 is
            still printed.
        
        An example of a well formatted answer is ["-2*a*a*a", "3*a*a*b",
            "3*b*b", "4*a", "5*c", "-6"] 
        
        Terms (including constant terms) with coefficient 0 are not included.  For example,
            an expression of "0" has an output of [].
        
    

    Examples:

    Input: expression = "e + 8 - a + 5", evalvars = ["e"], evalints = [1]
Output: ["-1*a","14"]

Input: expression = "e - 8 + temperature - pressure",
evalvars = ["e", "temperature"], evalints = [1, 12]
Output: ["-1*pressure","5"]

Input: expression = "(e + 8) * (e - 8)", evalvars = [], evalints = []
Output: ["1*e*e","-64"]

Input: expression = "7 - 7", evalvars = [], evalints = []
Output: []

Input: expression = "a * b * c + b * a * c * 4", evalvars = [], evalints = []
Output: ["5*a*b*c"]

Input: expression = "((a - b) * (b - c) + (c - a)) * ((a - b) + (b - c) * (c - a))",
evalvars = [], evalints = []
Output: ["-1*a*a*b*b","2*a*a*b*c","-1*a*a*c*c","1*a*b*b*b","-1*a*b*b*c","-1*a*b*c*c","1*a*c*c*c","-1*b*b*b*c","2*b*b*c*c","-1*b*c*c*c","2*a*a*b","-2*a*a*c","-2*a*b*b","2*a*c*c","1*b*b*b","-1*b*b*c","1*b*c*c","-1*c*c*c","-1*a*a","1*a*b","1*a*c","-1*b*c"]

    Note:

    
        expression will have length in range [1, 250].
        evalvars, evalints will have equal lengths in range [0, 100].
-----------------

# 331_Verify_Preorder_Serialization_of_a_Binary_Tree
# 331. Verify Preorder Serialization of a Binary Tree

One way to serialize a binary tree is to use pre-order traversal. When we encounter a
        non-null node, we record the node's value. If it is a null node, we record using a
        sentinel value such as #.

         _9_
    /   \
   3     2
  / \   / \
 4   1  #  6
/ \ / \   / \
# # # #   # #

    For example, the above binary tree can be serialized to the string "9,3,4,#,#,1,#,#,2,#,6,#,#",
        where # represents a null node.

    Given a string of comma separated values, verify whether it is a correct preorder traversal
        serialization of a binary tree. Find an algorithm without reconstructing the tree.

    Each comma separated value in the string must be either an integer or a character '#'
        representing null pointer.

    You may assume that the input format is always valid, for example it could never contain two
        consecutive commas such as "1,,3".

    Example 1:

    Input: "9,3,4,#,#,1,#,#,2,#,6,#,#"
Output: true

    Example 2:

    Input: "1,#"
Output: false

    Example 3:

    Input: "9,#,#,1"
Output: false
-----------------

# 1324_1324._Print_Words_Vertically
# 1324. 1324. Print Words Vertically


-----------------

# 318_Maximum_Product_of_Word_Lengths
# 318. Maximum Product of Word Lengths

Given a string array words, find the maximum value of length(word[i]) *
        length(word[j]) where the two words do not share common letters. You may assume that
        each word will contain only lower case letters. If no such two words exist, return 0.

    Example 1:

    Input: ["abcw","baz","foo","bar","xtfn","abcdef"]
Output: 16
Explanation: The two words can be "abcw", "xtfn".

    Example 2:

    Input: ["a","ab","abc","d","cd","bcd","abcd"]
Output: 4
Explanation: The two words can be "ab", "cd".

    Example 3:

    Input: ["a","aa","aaa","aaaa"]
Output: 0
Explanation: No such pair of words.
-----------------

# 1342_Number_of_Steps_to_Reduce_a_Number_to_Zero
# 1342. Number of Steps to Reduce a Number to Zero


-----------------

# 1337_The_K_Weakest_Rows_in_a_Matrix
# 1337. The K Weakest Rows in a Matrix


-----------------

# 746_Min_Cost_Climbing_Stairs
# 746. Min Cost Climbing Stairs

On a staircase, the i-th step has some non-negative cost cost[i]
        assigned (0 indexed).
    
    
        Once you pay the cost, you can either climb one or two steps. You need to find minimum cost
        to reach the top of the floor, and you can either start from the step with index 0, or the
        step with index 1.
    

    Example 1:
    Input: cost = [10, 15, 20]
Output: 15
Explanation: Cheapest is start on cost[1], pay that cost and go to the top.

    

    Example 2:
    Input: cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]
Output: 6
Explanation: Cheapest is start on cost[0], and only step on 1s, skipping cost[3].

    

    Note:
    
        cost will have a length in the range [2, 1000].
        Every cost[i] will be an integer in the range [0, 999].
-----------------

# 1772_Sort_Features_by_Popularity
# 1772. Sort Features by Popularity


-----------------

# 594_Longest_Harmonious_Subsequence
# 594. Longest Harmonious Subsequence

We define a harmounious array as an array where the difference between its maximum value and
        its minimum value is exactly 1.

    Now, given an integer array, you need to find the length of its longest harmonious
        subsequence among all its possible subsequences.
    

    Example 1:

    Input: [1,3,2,2,5,2,3,7]
Output: 5
Explanation: The longest harmonious subsequence is [3,2,2,2,3].

     

    Note: The length of the input array will not exceed 20,000.
-----------------

# 1682_Longest_Palindromic_Subsequence_II
# 1682. Longest Palindromic Subsequence II


-----------------

# 1317_Convert_Integer_to_the_Sum_of_Two_No-Zero_Integers
# 1317. Convert Integer to the Sum of Two No-Zero Integers


-----------------

# 1581_Customer_Who_Visited_but_Did_Not_Make_Any_Transactions
# 1581. Customer Who Visited but Did Not Make Any Transactions


-----------------

# 1742_Maximum_Number_of_Balls_in_a_Box
# 1742. Maximum Number of Balls in a Box


-----------------

# 63_Unique_Paths_II
# 63. Unique Paths II

A robot is located at the top-left corner of a m x n grid (marked 'Start'
        in the diagram below).

    The robot can only move either down or right at any point in time. The robot is trying to
        reach the bottom-right corner of the grid (marked 'Finish' in the diagram
        below).

    Now consider if some obstacles are added to the grids. How many unique paths would there
        be?

    
        

    An obstacle and empty space is marked as 1 and 0 respectively in
        the grid.

    Note: m and n will be at most 100.

    Example 1:

    Input:
[
  [0,0,0],
  [0,1,0],
  [0,0,0]
]
Output: 2
Explanation:
There is one obstacle in the middle of the 3x3 grid above.
There are two ways to reach the bottom-right corner:
1. Right -> Right -> Down -> Down
2. Down -> Down -> Right -> Right
-----------------

# 862_Shortest_Subarray_with_Sum_at_Least_K
# 862. Shortest Subarray with Sum at Least K

Return the length of the shortest, non-empty, contiguous subarray of
        A with sum at least K.

    If there is no non-empty subarray with sum at least K, return -1.
-----------------

# 1174_Immediate_Food_Delivery_II
# 1174. Immediate Food Delivery II

Table: Delivery

    +-----------------------------+---------+
| Column Name                 | Type    |
+-----------------------------+---------+
| delivery_id                 | int     |
| customer_id                 | int     |
| order_date                  | date    |
| customer_pref_delivery_date | date    |
+-----------------------------+---------+
delivery_id is the primary key of this table.
The table holds information about food delivery to customers that make orders at some date and specify a preferred delivery date (on the same order date or after it).

     

    If the preferred delivery date of the customer is the same as the order date then
        the order is called immediate otherwise it's called scheduled.
    

    The first order of a customer is the order with the earliest order date
        that customer made. It is guaranteed that a customer has exactly one first order.

    Write an SQL query to find the percentage of immediate orders in the first orders of all
        customers, rounded to 2 decimal places.

    The query result format is in the following example:

    Delivery table:
+-------------+-------------+------------+-----------------------------+
| delivery_id | customer_id | order_date | customer_pref_delivery_date |
+-------------+-------------+------------+-----------------------------+
| 1           | 1           | 2019-08-01 | 2019-08-02                  |
| 2           | 2           | 2019-08-02 | 2019-08-02                  |
| 3           | 1           | 2019-08-11 | 2019-08-12                  |
| 4           | 3           | 2019-08-24 | 2019-08-24                  |
| 5           | 3           | 2019-08-21 | 2019-08-22                  |
| 6           | 2           | 2019-08-11 | 2019-08-13                  |
| 7           | 4           | 2019-08-09 | 2019-08-09                  |
+-------------+-------------+------------+-----------------------------+

Result table:
+----------------------+
| immediate_percentage |
+----------------------+
| 50.00                |
+----------------------+
The customer id 1 has a first order with delivery id 1 and it is scheduled.
The customer id 2 has a first order with delivery id 2 and it is immediate.
The customer id 3 has a first order with delivery id 5 and it is scheduled.
The customer id 4 has a first order with delivery id 7 and it is immediate.
Hence, half the customers have immediate first orders.
-----------------

# 1002_Find_Common_Characters
# 1002. Find Common Characters

Given an array A of strings made only from lowercase letters, return a list
        of all characters that show up in all strings within the list (including
            duplicates).  For example, if a character occurs 3 times in all
        strings but not 4 times, you need to include that character three times in the final
        answer.

    You may return the answer in any order.
-----------------

# 685_Redundant_Connection_II
# 685. Redundant Connection II

In this problem, a rooted tree is a directed graph such that, there is exactly one
        node (the root) for which all other nodes are descendants of this node, plus every node has
        exactly one parent, except for the root node which has no parents.
    
    
        The given input is a directed graph that started as a rooted tree with N nodes (with
        distinct values 1, 2, ..., N), with one additional directed edge added. The added edge has
        two different vertices chosen from 1 to N, and was not an edge that already existed.
    
    
        The resulting graph is given as a 2D-array of edges. Each element of edges
        is a pair [u, v] that represents a directed edge connecting nodes u
        and v, where u is a parent of child v.
    
    
        Return an edge that can be removed so that the resulting graph is a rooted tree of N nodes.
        If there are multiple answers, return the answer that occurs last in the given 2D-array.
    
    Example 1:
    Input: [[1,2], [1,3], [2,3]]
Output: [2,3]
Explanation: The given directed graph will be like this:
  1
 / \
v   v
2-->3

    
    Example 2:
    Input: [[1,2], [2,3], [3,4], [4,1], [1,5]]
Output: [4,1]
Explanation: The given directed graph will be like this:
5 <- 1 -> 2
     ^    |
     |    v
     4 <- 3

    
    Note:
    The size of the input 2D-array will be between 3 and 1000.
    Every integer represented in the 2D-array will be between 1 and N, where N is the size of
        the input array.
-----------------

# 1326_1326._Minimum_Number_of_Taps_to_Open_to_Water_a_Garden
# 1326. 1326. Minimum Number of Taps to Open to Water a Garden


-----------------

# 307_Range_Sum_Query_-_Mutable
# 307. Range Sum Query - Mutable

Given an integer array nums, find the sum of the elements between indices i and
        j (i ≤ j), inclusive.

    The update(i, val) function modifies nums by updating the element at index
        i to val.

    Example:

    Given nums = [1, 3, 5]

sumRange(0, 2) -> 9
update(1, 2)
sumRange(0, 2) -> 8

    Note:

    
        The array is only modifiable by the update function.
        You may assume the number of calls to update and sumRange function is
            distributed evenly.
-----------------

# 389_Find_the_Difference
# 389. Find the Difference

Given two strings s and t which consist of only lowercase
        letters.

    String t is generated by random shuffling string s and then add
        one more letter at a random position.

    Find the letter that was added in t.

    Example:
    Input:
s = "abcd"
t = "abcde"

Output:
e

Explanation:
'e' is the letter that was added.
-----------------

# 305_Number_of_Islands_II
# 305. Number of Islands II

A 2d grid map of m rows and n columns is initially filled with
        water. We may perform an addLand operation which turns the water at position (row,
        col) into a land. Given a list of positions to operate, count the number of islands after
            each addLand operation. An island is surrounded by water and is formed by
        connecting adjacent lands horizontally or vertically. You may assume all four edges of the
        grid are all surrounded by water.

    Example:

    Input: m = 3, n = 3, positions = [[0,0], [0,1], [1,2], [2,1]]
Output: [1,1,2,3]

    Explanation:

    Initially, the 2d grid grid is filled with water. (Assume 0 represents water and
        1 represents land).

    0 0 0
0 0 0
0 0 0

    Operation #1: addLand(0, 0) turns the water at grid[0][0] into a land.

    1 0 0
0 0 0   Number of islands = 1
0 0 0

    Operation #2: addLand(0, 1) turns the water at grid[0][1] into a land.

    1 1 0
0 0 0   Number of islands = 1
0 0 0

    Operation #3: addLand(1, 2) turns the water at grid[1][2] into a land.

    1 1 0
0 0 1   Number of islands = 2
0 0 0

    Operation #4: addLand(2, 1) turns the water at grid[2][1] into a land.

    1 1 0
0 0 1   Number of islands = 3
0 1 0

    Follow up:

    Can you do it in time complexity O(k log mn), where k is the length of the
        positions?
-----------------

# 1137_N-th_Tribonacci_Number
# 1137. N-th Tribonacci Number

The Tribonacci sequence Tn is defined as follows: 

    T0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn
        + Tn+1 + Tn+2 for n >= 0.

    Given n, return the value of Tn.

     
    Example 1:

    Input: n = 4
Output: 4
Explanation:
T_3 = 0 + 1 + 1 = 2
T_4 = 1 + 1 + 2 = 4

    Example 2:

    Input: n = 25
Output: 1389537

     
    Constraints:

    
        0 <= n <= 37
        The answer is guaranteed to fit within a 32-bit integer, ie. answer <= 2^31 -
            1.
-----------------

# 1645_Hopper_Company_Queries_II
# 1645. Hopper Company Queries II


-----------------

# 1764_Form_Array_by_Concatenating_Subarrays_of_Another_Array
# 1764. Form Array by Concatenating Subarrays of Another Array


-----------------

# 663_Equal_Tree_Partition
# 663. Equal Tree Partition

Given a binary tree with n nodes, your task is to check if it's possible to
        partition the tree to two trees which have the equal sum of values after removing
        exactly one edge on the original tree.
    

    Example 1:
    Input:
    5
   / \
  10 10
    /  \
   2   3

Output: True
Explanation:
    5
   /
  10

Sum: 15

   10
  /  \
 2    3

Sum: 15

    

    Example 2:
    Input:
    1
   / \
  2  10
    /  \
   2   20

Output: False
Explanation: You can't split the tree into two trees with equal sum after removing exactly one edge on the tree.

    

    Note:
    
        The range of tree node value is in the range of [-100000, 100000].
        1 <= n <= 10000
-----------------

# 201_Bitwise_AND_of_Numbers_Range
# 201. Bitwise AND of Numbers Range

Given a range [m, n] where 0 <= m <= n <= 2147483647, return the bitwise AND of all
        numbers in this range, inclusive.

    Example 1:

    Input: [5,7]
Output: 4

    Example 2:

    Input: [0,1]
Output: 0
-----------------

# 361_Bomb_Enemy
# 361. Bomb Enemy

Given a 2D grid, each cell is either a wall 'W', an enemy 'E'
        or empty '0' (the number zero), return the maximum enemies you can kill
        using one bomb.
        The bomb kills all the enemies in the same row and column from the planted point until it
        hits the wall since the wall is too strong to be destroyed.
        Note: You can only put the bomb at an empty cell.

    Example:
-----------------

# 1744_Can_You_Eat_Your_Favorite_Candy_on_Your_Favorite_Day
# 1744. Can You Eat Your Favorite Candy on Your Favorite Day?


-----------------

# 1161_Maximum_Level_Sum_of_a_Binary_Tree
# 1161. Maximum Level Sum of a Binary Tree

Given the root of a binary tree, the level of its root is 1, the
        level of its children is 2, and so on.

    Return the smallest level X such that the sum of all the values
        of nodes at level X is maximal.

     

    Example 1:

    

    Input: [1,7,0,7,-8,null,null]
Output: 2
Explanation: 
Level 1 sum = 1.
Level 2 sum = 7 + 0 = 7.
Level 3 sum = 7 + -8 = -1.
So we return the level with the maximum sum which is level 2.

     

    Note:

    
        The number of nodes in the given tree is between 1 and 10^4.
        
        -10^5 <= node.val <= 10^5
-----------------

# 1121_Divide_Array_Into_Increasing_Sequences
# 1121. Divide Array Into Increasing Sequences

Given a non-decreasing array of positive integers nums and
        an integer K, find out if this array can be divided into one or more disjoint
            increasing subsequences of length at least K.

     

    Example 1:

    Input: nums = [1,2,2,3,3,4,4], K = 3
Output: true
Explanation: 
The array can be divided into the two subsequences [1,2,3,4] and [2,3,4] with lengths at least 3 each.

    Example 2:

    Input: nums = [5,6,6,7,8], K = 3
Output: false
Explanation: 
There is no way to divide the array using the conditions required.

     

    Note:

    
        1 <= nums.length <= 10^5
        1 <= K <= nums.length
        1 <= nums[i] <= 10^5
-----------------

# 1051_Height_Checker
# 1051. Height Checker

Students are asked to stand in non-decreasing order of heights for an annual photo.

    Return the minimum number of students not standing in the right positions.  (This is the
        number of students that must move in order for all students to be standing in non-decreasing
        order of height.)

     

    Example 1:

    Input: [1,1,4,2,1,3]
Output: 3
Explanation: 
Students with heights 4, 3 and the last 1 are not standing in the right positions.

     

    Note:

    
        1 <= heights.length <= 100
        1 <= heights[i] <= 100
-----------------

# 276_Paint_Fence
# 276. Paint Fence

There is a fence with n posts, each post can be painted with one of the k colors.

    You have to paint all the posts such that no more than two adjacent fence posts have the same
        color.

    Return the total number of ways you can paint the fence.

    Note:
        n and k are non-negative integers.

    Example:

    Input: n = 3, k = 2
Output: 6
Explanation: Take c1 as color 1, c2 as color 2. All possible ways are:

            post1  post2  post3
 -----      -----  -----  -----
   1         c1     c1     c2
   2         c1     c2     c1
   3         c1     c2     c2
   4         c2     c1     c1 
   5         c2     c1     c2
   6         c2     c2     c1
-----------------

# 145_Binary_Tree_Postorder_Traversal
# 145. Binary Tree Postorder Traversal

Given a binary tree, return the postorder traversal of its nodes' values.

    Example:

    Input: [1,null,2,3]
   1
    \
     2
    /
   3

Output: [3,2,1]

    Follow up: Recursive solution is trivial, could you do it iteratively?
-----------------

# 1068_Product_Sales_Analysis_I
# 1068. Product Sales Analysis I

Table: Sales

    +-------------+-------+
| Column Name | Type  |
+-------------+-------+
| sale_id     | int   |
| product_id  | int   |
| year        | int   |
| quantity    | int   |
| price       | int   |
+-------------+-------+
(sale_id, year) is the primary key of this table.
product_id is a foreign key to Product table.
Note that the price is per unit.

    Table: Product

    +--------------+---------+
| Column Name  | Type    |
+--------------+---------+
| product_id   | int     |
| product_name | varchar |
+--------------+---------+
product_id is the primary key of this table.

     

    Write an SQL query that reports all product names of the products in the
        Sales table along with their selling year and price.
    

    For example:

    Sales table:
+---------+------------+------+----------+-------+
| sale_id | product_id | year | quantity | price |
+---------+------------+------+----------+-------+
| 1       | 100        | 2008 | 10       | 5000  |
| 2       | 100        | 2009 | 12       | 5000  |
| 7       | 200        | 2011 | 15       | 9000  |
+---------+------------+------+----------+-------+

Product table:
+------------+--------------+
| product_id | product_name |
+------------+--------------+
| 100        | Nokia        |
| 200        | Apple        |
| 300        | Samsung      |
+------------+--------------+

Result table:
+--------------+-------+-------+
| product_name | year  | price |
+--------------+-------+-------+
| Nokia        | 2008  | 5000  |
| Nokia        | 2009  | 5000  |
| Apple        | 2011  | 9000  |
+--------------+-------+-------+
-----------------

# 36_Valid_Sudoku
# 36. Valid Sudoku

Determine if a 9x9 Sudoku board is valid. Only the filled cells need to be
        validated according to the following rules:

    
        Each row must contain the digits 1-9 without repetition.
        
        Each column must contain the digits 1-9 without repetition.
        Each of the 9 3x3 sub-boxes of the grid must contain the digits 1-9 without
            repetition.
        
    

    
        
        A partially filled sudoku which is valid.
    

    The Sudoku board could be partially filled, where empty cells are filled with the character
        '.'.

    Example 1:

    Input:
[
  ["5","3",".",".","7",".",".",".","."],
  ["6",".",".","1","9","5",".",".","."],
  [".","9","8",".",".",".",".","6","."],
  ["8",".",".",".","6",".",".",".","3"],
  ["4",".",".","8",".","3",".",".","1"],
  ["7",".",".",".","2",".",".",".","6"],
  [".","6",".",".",".",".","2","8","."],
  [".",".",".","4","1","9",".",".","5"],
  [".",".",".",".","8",".",".","7","9"]
]
Output: true

    Example 2:

    Input:
[
  ["8","3",".",".","7",".",".",".","."],
  ["6",".",".","1","9","5",".",".","."],
  [".","9","8",".",".",".",".","6","."],
  ["8",".",".",".","6",".",".",".","3"],
  ["4",".",".","8",".","3",".",".","1"],
  ["7",".",".",".","2",".",".",".","6"],
  [".","6",".",".",".",".","2","8","."],
  [".",".",".","4","1","9",".",".","5"],
  [".",".",".",".","8",".",".","7","9"]
]
Output: false
Explanation: Same as Example 1, except with the 5 in the top left corner being
    modified to 8. Since there are two 8's in the top left 3x3 sub-box, it is invalid.

    Note:

    
        A Sudoku board (partially filled) could be valid but is not necessarily solvable.
        Only the filled cells need to be validated according to the mentioned rules.
        The given board contain only digits 1-9 and the character '.'.
        
        The given board size is always 9x9.
-----------------

# 1046_Last_Stone_Weight
# 1046. Last Stone Weight

We have a collection of rocks, each rock has a positive integer weight.

    Each turn, we choose the two heaviest rocks and smash them
        together.  Suppose the stones have weights x and y with
        x <= y.  The result of this smash is:

    
        If x == y, both stones are totally destroyed;
        If x != y, the stone of weight x is totally destroyed, and the
            stone of weight y has new weight y-x.
        
    

    At the end, there is at most 1 stone left.  Return the weight of this stone (or 0 if
        there are no stones left.)

     

    Example 1:

    Input: [2,7,4,1,8,1]
Output: 1
Explanation: 
We combine 7 and 8 to get 1 so the array converts to [2,4,1,1,1] then,
we combine 2 and 4 to get 2 so the array converts to [2,1,1,1] then,
we combine 2 and 1 to get 1 so the array converts to [1,1,1] then,
we combine 1 and 1 to get 0 so the array converts to [1] then that's the value of last stone.

     

    Note:

    
        1 <= stones.length <= 30
        1 <= stones[i] <= 1000
-----------------

# 928_Minimize_Malware_Spread_II
# 928. Minimize Malware Spread II

(This problem is the same as Minimize Malware Spread, with the differences bolded.)
    

    In a network of nodes, each node i is directly connected to another node
        j if and only if graph[i][j] = 1.

    Some nodes initial are initially infected by malware.  Whenever two nodes
        are directly connected and at least one of those two nodes is infected by malware, both
        nodes will be infected by malware.  This spread of malware will continue until no more
        nodes can be infected in this manner.

    Suppose M(initial) is the final number of nodes infected with malware in
        the entire network, after the spread of malware stops.

    We will remove one node from the initial list, completely removing it and any
        connections from this node to any other node.  Return the node that if
        removed, would minimize M(initial).  If multiple nodes could be
        removed to minimize M(initial), return such a node with the smallest index.
-----------------

# 208_Implement_Trie_(Prefix_Tree)
# 208. Implement Trie (Prefix Tree)

Implement a trie with insert, search, and startsWith
        methods.

    Example:

    Trie trie = new Trie();

trie.insert("apple");
trie.search("apple");   // returns true
trie.search("app");     // returns false
trie.startsWith("app"); // returns true
trie.insert("app");
trie.search("app");     // returns true

    Note:

    
        You may assume that all inputs are consist of lowercase letters a-z.
        All inputs are guaranteed to be non-empty strings.
-----------------

# 761_Special_Binary_String
# 761. Special Binary String

Special binary strings are binary strings with the following two properties:
    
    
    The number of 0's is equal to the number of 1's.
    Every prefix of the binary string has at least as many 1's as 0's.
    
    Given a special string S, a move consists of choosing two consecutive,
    non-empty, special substrings of S, and swapping them. (Two strings are
    consecutive if the last character of the first string is exactly one index before the first
    character of the second string.)

    
        At the end of any number of moves, what is the lexicographically largest resulting string
        possible?
    

    Example 1:
    Input: S = "11011000"
Output: "11100100"
Explanation:
The strings "10" [occuring at S[1]] and "1100" [at S[3]] are swapped.
This is the lexicographically largest string possible after some number of swaps.

    

    Note:
    
        S has length at most 50.
        S is guaranteed to be a special binary string as defined above.
-----------------

# 589_N-ary_Tree_Preorder_Traversal
# 589. N-ary Tree Preorder Traversal

Given an n-ary tree, return the preorder traversal of its nodes' values.

    For example, given a 3-ary tree:

     

    
        

     

    Return its preorder traversal as: [1,3,5,6,2,4].

     

    Note:

    Recursive solution is trivial, could you do it iteratively?
-----------------

# 570_Managers_with_at_Least_5_Direct_Reports
# 570. Managers with at Least 5 Direct Reports

The Employee table holds all employees including their managers. Every employee
        has an Id, and there is also a column for the manager Id.

    +------+----------+-----------+----------+
|Id    |Name 	  |Department |ManagerId |
+------+----------+-----------+----------+
|101   |John 	  |A 	      |null      |
|102   |Dan 	  |A 	      |101       |
|103   |James 	  |A 	      |101       |
|104   |Amy 	  |A 	      |101       |
|105   |Anne 	  |A 	      |101       |
|106   |Ron 	  |B 	      |101       |
+------+----------+-----------+----------+

    Given the Employee table, write a SQL query that finds out managers with at
        least 5 direct report. For the above table, your SQL query should return:

    +-------+
| Name  |
+-------+
| John  |
+-------+

    Note:
        No one would report to himself.
-----------------

# 189_Rotate_Array
# 189. Rotate Array

Given an array, rotate the array to the right by k steps, where k is
        non-negative.

    Example 1:

    Input: [1,2,3,4,5,6,7] and k = 3
Output: [5,6,7,1,2,3,4]
Explanation:
rotate 1 steps to the right: [7,1,2,3,4,5,6]
rotate 2 steps to the right: [6,7,1,2,3,4,5]
rotate 3 steps to the right: [5,6,7,1,2,3,4]

    Example 2:

    Input: [-1,-100,3,99] and k = 2
Output: [3,99,-1,-100]
Explanation:
rotate 1 steps to the right: [99,-1,-100,3]
rotate 2 steps to the right: [3,99,-1,-100]

    Note:

    
        Try to come up as many solutions as you can, there are at least 3 different ways to
            solve this problem.
        
        Could you do it in-place with O(1) extra space?
-----------------

# 633_Sum_of_Square_Numbers
# 633. Sum of Square Numbers

Given a non-negative integer c, your task is to decide whether there're two
        integers a and b such that a2 + b2 = c.

    Example 1:

    Input: 5
Output: True
Explanation: 1 * 1 + 2 * 2 = 5

     

    Example 2:

    Input: 3
Output: False
-----------------

# 37_Sudoku_Solver
# 37. Sudoku Solver

Write a program to solve a Sudoku puzzle by filling the empty cells.

    A sudoku solution must satisfy all of the following rules:

    
        Each of the digits 1-9 must occur exactly once in each row.
        Each of the digits 1-9 must occur exactly once in each
            column.
        
        Each of the the digits 1-9 must occur exactly once in each of the 9
            3x3 sub-boxes of the grid.
        
    

    Empty cells are indicated by the character '.'.

    
        
        A sudoku puzzle...
    

    
        
        ...and its solution numbers marked in red.
    

    Note:

    
        The given board contain only digits 1-9 and the character '.'.
        
        You may assume that the given Sudoku puzzle will have a single unique solution.
        The given board size is always 9x9.
-----------------

# 1120_Maximum_Average_Subtree
# 1120. Maximum Average Subtree

Given the root of a binary tree, find the maximum average value of any subtree
        of that tree.

    (A subtree of a tree is any node of that tree plus all its descendants. The average value of
        a tree is the sum of its values, divided by the number of nodes.)

     

    Example 1:

    

    Input: [5,6,1]
Output: 6.00000
Explanation: 
For the node with value = 5 we have an average of (5 + 6 + 1) / 3 = 4.
For the node with value = 6 we have an average of 6 / 1 = 6.
For the node with value = 1 we have an average of 1 / 1 = 1.
So the answer is 6 which is the maximum.

     

    Note:

    
        The number of nodes in the tree is between 1 and 5000.
        Each node will have a value between 0 and 100000.
        Answers will be accepted as correct if they are within 10^-5 of the correct
            answer.
-----------------

# 775_Global_and_Local_Inversions
# 775. Global and Local Inversions

We have some permutation A of [0, 1, ..., N - 1], where
        N is the length of A.

    The number of (global) inversions is the number of i < j with 0 <= i
        < j < N and A[i] > A[j].

    The number of local inversions is the number of i with 0 <= i <
        N and A[i] > A[i+1].

    Return true if and only if the number of global inversions is equal to the
        number of local inversions.

    Example 1:

    Input: A = [1,0,2]
Output: true
Explanation: There is 1 global inversion, and 1 local inversion.

    Example 2:

    Input: A = [1,2,0]
Output: false
Explanation: There are 2 global inversions, and 1 local inversion.

    Note:

    
        A will be a permutation of [0, 1, ..., A.length - 1].
        A will have length in range [1, 5000].
        The time limit for this problem has been reduced.
-----------------

# 1247_Minimum_Swaps_to_Make_Strings_Equal
# 1247. Minimum Swaps to Make Strings Equal

You are given two strings s1 and s2 of equal
        length consisting of letters "x" and "y"
        only. Your task is to make these two strings equal to each other. You
        can swap any two characters that belong to different strings, which
        means: swap s1[i] and s2[j].

    Return the minimum number of swaps required to make s1 and
        s2 equal, or return -1 if it is impossible to do
        so.

     
    Example 1:

    Input: s1 = "xx", s2 = "yy"
Output: 1
Explanation:
Swap s1[0] and s2[1], s1 = "yx", s2 = "yx".

    Example 2: 

    Input: s1 = "xy", s2 = "yx"
Output: 2
Explanation:
Swap s1[0] and s2[0], s1 = "yy", s2 = "xx".
Swap s1[0] and s2[1], s1 = "xy", s2 = "xy".
Note that you can't swap s1[0] and s1[1] to make s1 equal to "yx", cause we can only swap chars in different strings.

    Example 3:

    Input: s1 = "xx", s2 = "xy"
Output: -1

    Example 4:

    Input: s1 = "xxyyxyxyxx", s2 = "xyyxyxxxyx"
Output: 4

     
    Constraints:

    
        1 <= s1.length, s2.length <= 1000
        s1, s2 only contain 'x' or
            'y'.
-----------------

# 408_Valid_Word_Abbreviation
# 408. Valid Word Abbreviation

Given a non-empty string s and an abbreviation abbr, return
        whether the string matches with the given abbreviation.
    

    A string such as "word" contains only the following valid abbreviations:

    ["word", "1ord", "w1rd", "wo1d", "wor1", "2rd", "w2d", "wo2", "1o1d", "1or1", "w1r1", "1o2", "2r1", "3d", "w3", "4"]

    Notice that only the above abbreviations are valid abbreviations of the string
        "word". Any other string is not a valid abbreviation of "word".
    

    Note:
        Assume s contains only lowercase letters and abbr contains only
        lowercase letters and digits.
    

    Example 1:
    Given s = "internationalization", abbr = "i12iz4n":

Return true.

    

    Example 2:
    Given s = "apple", abbr = "a2e":

Return false.
-----------------

# 1084_Sales_Analysis_III
# 1084. Sales Analysis III

Table: Product

    +--------------+---------+
| Column Name  | Type    |
+--------------+---------+
| product_id   | int     |
| product_name | varchar |
| unit_price   | int     |
+--------------+---------+
product_id is the primary key of this table.

    Table: Sales

    +-------------+---------+
| Column Name | Type    |
+-------------+---------+
| seller_id   | int     |
| product_id  | int     |
| buyer_id    | int     |
| sale_date   | date    |
| quantity    | int     |
| price       | int     |
+------ ------+---------+
This table has no primary key, it can have repeated rows.
product_id is a foreign key to Product table.

     

    Write an SQL query that reports the products that were
        only sold in spring 2019. That is,
        between 2019-01-01 and 2019-03-31 inclusive.

    The query result format is in the following example:

    Product table:
+------------+--------------+------------+
| product_id | product_name | unit_price |
+------------+--------------+------------+
| 1          | S8           | 1000       |
| 2          | G4           | 800        |
| 3          | iPhone       | 1400       |
+------------+--------------+------------+

Sales table:
+-----------+------------+----------+------------+----------+-------+
| seller_id | product_id | buyer_id | sale_date  | quantity | price |
+-----------+------------+----------+------------+----------+-------+
| 1         | 1          | 1        | 2019-01-21 | 2        | 2000  |
| 1         | 2          | 2        | 2019-02-17 | 1        | 800   |
| 2         | 2          | 3        | 2019-06-02 | 1        | 800   |
| 3         | 3          | 4        | 2019-05-13 | 2        | 2800  |
+-----------+------------+----------+------------+----------+-------+

Result table:
+-------------+--------------+
| product_id  | product_name |
+-------------+--------------+
| 1           | S8           |
+-------------+--------------+
The product with id 1 was only sold in spring 2019 while the other two were sold after.
-----------------

# 842_Split_Array_into_Fibonacci_Sequence
# 842. Split Array into Fibonacci Sequence

Given a string S of digits, such as S = "123456579",
        we can split it into a Fibonacci-like sequence [123, 456, 579].
    

    Formally, a Fibonacci-like sequence is a list F of non-negative integers
        such that:

    
        0 <= F[i] <= 2^31 - 1, (that is, each integer fits a 32-bit
            signed integer type);
        
        F.length >= 3;
        and F[i] + F[i+1] = F[i+2] for all 0 <= i < F.length - 2.
        
    

    Also, note that when splitting the string into pieces, each piece must not have extra leading
        zeroes, except if the piece is the number 0 itself.

    Return any Fibonacci-like sequence split from S, or return [] if it
        cannot be done.

    Example 1:

    Input: "123456579"
Output: [123,456,579]

    Example 2:

    Input: "11235813"
Output: [1,1,2,3,5,8,13]

    Example 3:

    Input: "112358130"
Output: []
Explanation: The task is impossible.

    Example 4:

    Input: "0123"
Output: []
Explanation: Leading zeroes are not allowed, so "01", "2", "3" is not valid.

    Example 5:

    Input: "1101111"
Output: [110, 1, 111]
Explanation: The output [11, 0, 11, 11] would also be accepted.

    Note: 

    
        1 <= S.length <= 200
        S contains only digits.
-----------------

# 262_Trips_and_Users
# 262. Trips and Users

The Trips table holds all taxi trips. Each trip has a unique Id, while Client_Id
        and Driver_Id are both foreign keys to the Users_Id at the Users table. Status
        is an ENUM type of (‘completed’, ‘cancelled_by_driver’, ‘cancelled_by_client’).
    

    +----+-----------+-----------+---------+--------------------+----------+
| Id | Client_Id | Driver_Id | City_Id |        Status      |Request_at|
+----+-----------+-----------+---------+--------------------+----------+
| 1  |     1     |    10     |    1    |     completed      |2013-10-01|
| 2  |     2     |    11     |    1    | cancelled_by_driver|2013-10-01|
| 3  |     3     |    12     |    6    |     completed      |2013-10-01|
| 4  |     4     |    13     |    6    | cancelled_by_client|2013-10-01|
| 5  |     1     |    10     |    1    |     completed      |2013-10-02|
| 6  |     2     |    11     |    6    |     completed      |2013-10-02|
| 7  |     3     |    12     |    6    |     completed      |2013-10-02|
| 8  |     2     |    12     |    12   |     completed      |2013-10-03|
| 9  |     3     |    10     |    12   |     completed      |2013-10-03|
| 10 |     4     |    13     |    12   | cancelled_by_driver|2013-10-03|
+----+-----------+-----------+---------+--------------------+----------+

    The Users table holds all users. Each user has an unique Users_Id, and Role is
        an ENUM type of (‘client’, ‘driver’, ‘partner’).

    +----------+--------+--------+
| Users_Id | Banned |  Role  |
+----------+--------+--------+
|    1     |   No   | client |
|    2     |   Yes  | client |
|    3     |   No   | client |
|    4     |   No   | client |
|    10    |   No   | driver |
|    11    |   No   | driver |
|    12    |   No   | driver |
|    13    |   No   | driver |
+----------+--------+--------+

    Write a SQL query to find the cancellation rate of requests made by unbanned users (both
        client and driver must be unbanned) between Oct 1, 2013 and Oct
            3, 2013. The cancellation rate is computed by dividing the number of canceled
        (by client or driver) requests made by unbanned users by the total number of requests made
        by unbanned users.

    For the above tables, your SQL query should return the following rows with the cancellation
        rate being rounded to two decimal places.

    +------------+-------------------+
|     Day    | Cancellation Rate |
+------------+-------------------+
| 2013-10-01 |       0.33        |
| 2013-10-02 |       0.00        |
| 2013-10-03 |       0.50        |
+------------+-------------------+

    Credits:
        Special thanks to @cak1erlizhou
        for contributing this question, writing the problem description and adding part of the test
        cases.
-----------------

# 302_Smallest_Rectangle_Enclosing_Black_Pixels
# 302. Smallest Rectangle Enclosing Black Pixels

An image is represented by a binary matrix with 0 as a white pixel and
        1 as a black pixel. The black pixels are connected, i.e., there is only one
        black region. Pixels are connected horizontally and vertically. Given the location (x,
            y) of one of the black pixels, return the area of the smallest (axis-aligned)
        rectangle that encloses all black pixels.

    Example:

    Input:
[
  "0010",
  "0110",
  "0100"
]
and x = 0, y = 2

Output: 6
-----------------

# 181_Employees_Earning_More_Than_Their_Managers
# 181. Employees Earning More Than Their Managers

The Employee table holds all employees including their managers. Every employee
        has an Id, and there is also a column for the manager Id.

    +----+-------+--------+-----------+
| Id | Name  | Salary | ManagerId |
+----+-------+--------+-----------+
| 1  | Joe   | 70000  | 3         |
| 2  | Henry | 80000  | 4         |
| 3  | Sam   | 60000  | NULL      |
| 4  | Max   | 90000  | NULL      |
+----+-------+--------+-----------+

    Given the Employee table, write a SQL query that finds out employees who earn
        more than their managers. For the above table, Joe is the only employee who earns more than
        his manager.

    +----------+
| Employee |
+----------+
| Joe      |
+----------+
-----------------

# 48_Rotate_Image
# 48. Rotate Image

You are given an n x n 2D matrix representing an image.

    Rotate the image by 90 degrees (clockwise).

    Note:

    You have to rotate the image in-place, which means
        you have to modify the input 2D matrix directly. DO NOT allocate another 2D
        matrix and do the rotation.

    Example 1:

    Given input matrix =
[
  [1,2,3],
  [4,5,6],
  [7,8,9]
],

rotate the input matrix in-place such that it becomes:
[
  [7,4,1],
  [8,5,2],
  [9,6,3]
]

    Example 2:

    Given input matrix =
[
  [ 5, 1, 9,11],
  [ 2, 4, 8,10],
  [13, 3, 6, 7],
  [15,14,12,16]
],

rotate the input matrix in-place such that it becomes:
[
  [15,13, 2, 5],
  [14, 3, 4, 1],
  [12, 6, 8, 9],
  [16, 7,10,11]
]
-----------------

# 1414_Find_the_Minimum_Number_of_Fibonacci_Numbers_Whose_Sum_Is_K
# 1414. Find the Minimum Number of Fibonacci Numbers Whose Sum Is K


-----------------

# 1656_Design_an_Ordered_Stream
# 1656. Design an Ordered Stream


-----------------

# 10_Regular_Expression_Matching
# 10. Regular Expression Matching

Given an input string (s) and a pattern (p), implement regular
        expression matching with support for '.' and '*'.
    

    '.' Matches any single character.
'*' Matches zero or more of the preceding element.

    The matching should cover the entire input string (not partial).

    Note:

    
        s could be empty and contains only lowercase letters a-z.
        
        p could be empty and contains only lowercase letters a-z, and
            characters like . or *.
        
    

    Example 1:

    Input:
s = "aa"
p = "a"
Output: false
Explanation: "a" does not match the entire string "aa".

    Example 2:

    Input:
s = "aa"
p = "a*"
Output: true
Explanation: '*' means zero or more of the preceding element, 'a'. Therefore, by repeating 'a' once, it becomes "aa".

    Example 3:

    Input:
s = "ab"
p = ".*"
Output: true
Explanation: ".*" means "zero or more (*) of any character (.)".

    Example 4:

    Input:
s = "aab"
p = "c*a*b"
Output: true
Explanation: c can be repeated 0 times, a can be repeated 1 time. Therefore, it matches "aab".

    Example 5:

    Input:
s = "mississippi"
p = "mis*is*p*."
Output: false
-----------------

# 1838_Frequency_of_the_Most_Frequent_Element
# 1838. Frequency of the Most Frequent Element


-----------------

# 1123_Lowest_Common_Ancestor_of_Deepest_Leaves
# 1123. Lowest Common Ancestor of Deepest Leaves

Given a rooted binary tree, return the lowest common ancestor of its deepest leaves.

    Recall that:

    
        The node of a binary tree is a leaf if and only if it has no children
        The depth of the root of the tree is 0, and if the depth of a node is
            d, the depth of each of its children is d+1.
        
        The lowest common ancestor of a set S of nodes is the node
            A with the largest depth such that every node in S is in the subtree with
            root A.
        
    

     
    Example 1:

    Input: root = [1,2,3]
Output: [1,2,3]
Explanation:
The deepest leaves are the nodes with values 2 and 3.
The lowest common ancestor of these leaves is the node with value 1.
The answer returned is a TreeNode object (not an array) with serialization "[1,2,3]".

    Example 2:

    Input: root = [1,2,3,4]
Output: [4]

    Example 3:

    Input: root = [1,2,3,4,5]
Output: [2,4,5]

     
    Constraints:

    
        The given tree will have between 1 and 1000 nodes.
        Each node of the tree will have a distinct value between 1 and 1000.
-----------------

# 1636_Sort_Array_by_Increasing_Frequency
# 1636. Sort Array by Increasing Frequency


-----------------

# 411_Minimum_Unique_Word_Abbreviation
# 411. Minimum Unique Word Abbreviation

A string such as "word" contains the following abbreviations:

    ["word", "1ord", "w1rd", "wo1d", "wor1", "2rd", "w2d", "wo2", "1o1d", "1or1", "w1r1", "1o2", "2r1", "3d", "w3", "4"]

    Given a target string and a set of strings in a dictionary, find an abbreviation of this
        target string with the smallest possible length such that it does not conflict
        with abbreviations of the strings in the dictionary. 

    Each number or letter in the abbreviation is considered length = 1. For example, the
        abbreviation "a32bc" has length = 4.

    Note:
    
        In the case of multiple answers as shown in the second example below, you may return any
            one of them.
        
        Assume length of target string = m, and dictionary size = n. You may
            assume that m ≤ 21, n ≤ 1000, and log2(n) + m
                ≤ 20.
        
    
    

    Examples:
    "apple", ["blade"] -> "a4" (because "5" or "4e" conflicts with "blade")

"apple", ["plain", "amber", "blade"] -> "1p3" (other valid answers include "ap3", "a3e", "2p2", "3le", "3l1").
-----------------

# 1821_Find_Customers_With_Positive_Revenue_this_Year
# 1821. Find Customers With Positive Revenue this Year


-----------------

# 15_3Sum
# 15. 3Sum

Given an array nums of n integers, are there elements a,
        b, c in nums such that a + b + c =
        0? Find all unique triplets in the array which gives the sum of zero.

    Note:

    The solution set must not contain duplicate triplets.

    Example:

    Given array nums = [-1, 0, 1, 2, -1, -4],

A solution set is:
[
  [-1, 0, 1],
  [-1, -1, 2]
]
-----------------

# 1122_Relative_Sort_Array
# 1122. Relative Sort Array

Given two arrays arr1 and arr2, the elements of arr2
        are distinct, and all elements in arr2 are also in arr1.

    Sort the elements of arr1 such that the relative ordering of items in
        arr1 are the same as in arr2.  Elements that don't appear
        in arr2 should be placed at the end of arr1 in
        ascending order.

     
    Example 1:
    Input: arr1 = [2,3,1,3,2,4,6,7,9,2,19], arr2 = [2,1,4,3,9,6]
Output: [2,2,2,1,4,3,3,9,6,7,19]

     
    Constraints:

    
        arr1.length, arr2.length <= 1000
        0 <= arr1[i], arr2[i] <= 1000
        Each arr2[i] is distinct.
        Each arr2[i] is in arr1.
-----------------

# 799_Champagne_Tower
# 799. Champagne Tower

We stack glasses in a pyramid, where the first row has 1 glass, the second row has 2 glasses,
        and so on until the 100th row.  Each glass holds one cup (250ml) of champagne.

    Then, some champagne is poured in the first glass at the top.  When the top most glass
        is full, any excess liquid poured will fall equally to the glass immediately to the left and
        right of it.  When those glasses become full, any excess champagne will fall equally to
        the left and right of those glasses, and so on.  (A glass at the bottom row has it's
        excess champagne fall on the floor.)

    For example, after one cup of champagne is poured, the top most glass is full.  After
        two cups of champagne are poured, the two glasses on the second row are half full. 
        After three cups of champagne are poured, those two cups become full - there are 3 full
        glasses total now.  After four cups of champagne are poured, the third row has the
        middle glass half full, and the two outside glasses are a quarter full, as pictured
        below.

    

    Now after pouring some non-negative integer cups of champagne, return how full the j-th glass
        in the i-th row is (both i and j are 0 indexed.)

     

    Example 1:
Input: poured = 1, query_glass = 1, query_row = 1
Output: 0.0
Explanation: We poured 1 cup of champange to the top glass of the tower (which is indexed as (0, 0)). There will be no excess liquid so all the glasses under the top glass will remain empty.

Example 2:
Input: poured = 2, query_glass = 1, query_row = 1
Output: 0.5
Explanation: We poured 2 cups of champange to the top glass of the tower (which is indexed as (0, 0)). There is one cup of excess liquid. The glass indexed as (1, 0) and the glass indexed as (1, 1) will share the excess liquid equally, and each will get half cup of champange.

     

    Note:

    
        poured will be in the range of [0, 10 ^ 9].
        
        query_glass and query_row will be in the range of [0,
            99].
-----------------

# 1225_Report_Contiguous_Dates
# 1225. Report Contiguous Dates

Table: Failed

    +--------------+---------+
| Column Name  | Type    |
+--------------+---------+
| fail_date    | date    |
+--------------+---------+
Primary key for this table is fail_date.
Failed table contains the days of failed tasks.

    Table: Succeeded

    +--------------+---------+
| Column Name  | Type    |
+--------------+---------+
| success_date | date    |
+--------------+---------+
Primary key for this table is success_date.
Succeeded table contains the days of succeeded tasks.

     

    A system is running one task every day. Every task is independent of the
        previous tasks. The tasks can fail or succeed.

    Write an SQL query to generate a report of period_state for each continuous
        interval of days in the period from 2019-01-01 to
        2019-12-31.

    period_state is 'failed' if tasks in this interval failed
        or 'succeeded' if tasks in this interval succeeded. Interval of days
        are retrieved as start_date and end_date.

    Order result by start_date.

    The query result format is in the following example:

    Failed table:
+-------------------+
| fail_date         |
+-------------------+
| 2018-12-28        |
| 2018-12-29        |
| 2019-01-04        |
| 2019-01-05        |
+-------------------+

Succeeded table:
+-------------------+
| success_date      |
+-------------------+
| 2018-12-30        |
| 2018-12-31        |
| 2019-01-01        |
| 2019-01-02        |
| 2019-01-03        |
| 2019-01-06        |
+-------------------+

Result table:
+--------------+--------------+--------------+
| period_state | start_date   | end_date     |
+--------------+--------------+--------------+
| succeeded    | 2019-01-01   | 2019-01-03   |
| failed       | 2019-01-04   | 2019-01-05   |
| succeeded    | 2019-01-06   | 2019-01-06   |
+--------------+--------------+--------------+

The report ignored the system state in 2018 as we care about the system in the period 2019-01-01 to 2019-12-31.
From 2019-01-01 to 2019-01-03 all tasks succeeded and the system state was "succeeded".
From 2019-01-04 to 2019-01-05 all tasks failed and system state was "failed".
From 2019-01-06 to 2019-01-06 all tasks succeeded and system state was "succeeded".
-----------------

# 526_Beautiful_Arrangement
# 526. Beautiful Arrangement

Suppose you have N integers from 1 to N. We define a beautiful arrangement as an array
        that is constructed by these N numbers successfully if one of the following is true
        for the ith position (1 <= i <= N) in this array:

    
        The number at the ith position is divisible by i.
        i is divisible by the number at the ith position.
    

     

    Now given N, how many beautiful arrangements can you construct?

    Example 1:

    Input: 2
Output: 2
Explanation:

The first beautiful arrangement is [1, 2]:

Number at the 1st position (i=1) is 1, and 1 is divisible by i (i=1).

Number at the 2nd position (i=2) is 2, and 2 is divisible by i (i=2).

The second beautiful arrangement is [2, 1]:

Number at the 1st position (i=1) is 2, and 2 is divisible by i (i=1).

Number at the 2nd position (i=2) is 1, and i (i=2) is divisible by 1.

     

    Note:

    
        N is a positive integer and will not exceed 15.
-----------------

# 985_Sum_of_Even_Numbers_After_Queries
# 985. Sum of Even Numbers After Queries

We have an array A of integers, and an array queries of
        queries.

    For the i-th query val = queries[i][0], index =
        queries[i][1], we add val to A[index]. 
        Then, the answer to the i-th query is the sum of the even values of
        A.

    (Here, the given index = queries[i][1] is a 0-based index, and each query
        permanently modifies the array A.)

    Return the answer to all queries.  Your answer array should
        have answer[i] as the answer to the i-th query.

     

    Example 1:

    Input: A = [1,2,3,4], queries = [[1,0],[-3,1],[-4,0],[2,3]]
Output: [8,6,2,4]
Explanation: 
At the beginning, the array is [1,2,3,4].
After adding 1 to A[0], the array is [2,2,3,4], and the sum of even values is 2 + 2 + 4 = 8.
After adding -3 to A[1], the array is [2,-1,3,4], and the sum of even values is 2 + 4 = 6.
After adding -4 to A[0], the array is [-2,-1,3,4], and the sum of even values is -2 + 4 = 2.
After adding 2 to A[3], the array is [-2,-1,3,6], and the sum of even values is -2 + 6 = 4.

     

    Note:

    
        1 <= A.length <= 10000
        -10000 <= A[i] <= 10000
        1 <= queries.length <= 10000
        -10000 <= queries[i][0] <= 10000
        0 <= queries[i][1] < A.length
-----------------

# 1608_Special_Array_With_X_Elements_Greater_Than_or_Equal_X
# 1608. Special Array With X Elements Greater Than or Equal X


-----------------

# 1108_Defanging_an_IP_Address
# 1108. Defanging an IP Address

Given a valid (IPv4) IP address, return a defanged version of that IP address.
    

    A defanged IP address replaces every period "."
        with "[.]".

     
    Example 1:
    Input: address = "1.1.1.1"
Output: "1[.]1[.]1[.]1"

    Example 2:
    Input: address = "255.100.50.0"
Output: "255[.]100[.]50[.]0"

     
    Constraints:

    
        The given address is a valid IPv4 address.
-----------------

# 610_Triangle_Judgement
# 610. Triangle Judgement

A pupil Tim gets homework to identify whether three line segments could possibly form a
    triangle.
     
    However, this assignment is very heavy because there are hundreds of records to calculate.

     
    Could you help Tim by writing a query to judge whether these three sides can form a triangle,
    assuming table triangle holds the length of the three sides x, y and z.

     

    | x  | y  | z  |
|----|----|----|
| 13 | 15 | 30 |
| 10 | 20 | 15 |

    For the sample data above, your query should return the follow result:

    | x  | y  | z  | triangle |
|----|----|----|----------|
| 13 | 15 | 30 | No       |
| 10 | 20 | 15 | Yes      |
-----------------

# 1716_Calculate_Money_in_Leetcode_Bank
# 1716. Calculate Money in Leetcode Bank


-----------------

# 152_Maximum_Product_Subarray
# 152. Maximum Product Subarray

Given an integer array nums, find the contiguous subarray within an array
        (containing at least one number) which has the largest product.

    Example 1:

    Input: [2,3,-2,4]
Output: 6
Explanation: [2,3] has the largest product 6.

    Example 2:

    Input: [-2,0,-1]
Output: 0
Explanation: The result cannot be 2, because [-2,-1] is not a subarray.
-----------------

# 662_Maximum_Width_of_Binary_Tree
# 662. Maximum Width of Binary Tree

Given a binary tree, write a function to get the maximum width of the given tree. The width
        of a tree is the maximum width among all levels. The binary tree has the same structure as a
        full binary tree, but some nodes are null.

    The width of one level is defined as the length between the end-nodes (the leftmost and right
        most non-null nodes in the level, where the null nodes between the end-nodes
        are also counted into the length calculation.

    Example 1:

    Input:

           1
         /   \
        3     2
       / \     \
      5   3     9

Output: 4
Explanation: The maximum width existing in the third level with the length 4 (5,3,null,9).

    Example 2:

    Input:

          1
         /
        3
       / \
      5   3

Output: 2
Explanation: The maximum width existing in the third level with the length 2 (5,3).

    Example 3:

    Input:

          1
         / \
        3   2
       /
      5

Output: 2
Explanation: The maximum width existing in the second level with the length 2 (3,2).

    Example 4:

    Input:

          1
         / \
        3   2
       /     \
      5       9
     /         \
    6           7
Output: 8
Explanation:The maximum width existing in the fourth level with the length 8 (6,null,null,null,null,null,null,7).

    Note: Answer will in the range of 32-bit signed integer.
-----------------

# 79_Word_Search
# 79. Word Search

Given a 2D board and a word, find if the word exists in the grid.

    The word can be constructed from letters of sequentially adjacent cell, where "adjacent"
        cells are those horizontally or vertically neighboring. The same letter cell may not be used
        more than once.

    Example:

    board =
[
  ['A','B','C','E'],
  ['S','F','C','S'],
  ['A','D','E','E']
]

Given word = "ABCCED", return true.
Given word = "SEE", return true.
Given word = "ABCB", return false.
-----------------

# 1347_Minimum_Number_of_Steps_to_Make_Two_Strings_Anagram
# 1347. Minimum Number of Steps to Make Two Strings Anagram


-----------------

# 910_Smallest_Range_II
# 910. Smallest Range II

Given an array A of integers, for each integer A[i] we need to
        choose either x = -K or x = K, and add
        x to A[i] (only once).

    After this process, we have some array B.

    Return the smallest possible difference between the maximum value of B and
        the minimum value of B.
-----------------

# 1351_Count_Negative_Numbers_in_a_Sorted_Matrix
# 1351. Count Negative Numbers in a Sorted Matrix


-----------------

# 671_Second_Minimum_Node_In_a_Binary_Tree
# 671. Second Minimum Node In a Binary Tree

Given a non-empty special binary tree consisting of nodes with the non-negative value, where
        each node in this tree has exactly two or zero sub-node. If the
        node has two sub-nodes, then this node's value is the smaller value among its two
        sub-nodes. More formally, the property root.val = min(root.left.val,
            root.right.val) always holds.

    Given such a binary tree, you need to output the second minimum value in the set made
        of all the nodes' value in the whole tree.

    If no such second minimum value exists, output -1 instead.

    Example 1:

    Input:
    2
   / \
  2   5
     / \
    5   7

Output: 5
Explanation: The smallest value is 2, the second smallest value is 5.

     

    Example 2:

    Input:
    2
   / \
  2   2

Output: -1
Explanation: The smallest value is 2, but there isn't any second smallest value.
-----------------

# 1213_Intersection_of_Three_Sorted_Arrays
# 1213. Intersection of Three Sorted Arrays

Given three integer arrays arr1, arr2 and
        arr3 sorted in strictly increasing
        order, return a sorted array of only the integers that appeared
        in all three arrays.

     
    Example 1:

    Input: arr1 = [1,2,3,4,5], arr2 = [1,2,5,7,9], arr3 = [1,3,4,5,8]
Output: [1,5]
Explanation: Only 1 and 5 appeared in the three arrays.

     
    Constraints:

    
        1 <= arr1.length, arr2.length, arr3.length <= 1000
        1 <= arr1[i], arr2[i], arr3[i] <= 2000
-----------------

# 765_Couples_Holding_Hands
# 765. Couples Holding Hands

N couples sit in 2N seats arranged in a row and want to hold hands. We want to know the
        minimum number of swaps so that every couple is sitting side by side. A swap consists
        of choosing any two people, then they stand up and switch seats.
    
    
        The people and seats are represented by an integer from 0 to 2N-1,
        the couples are numbered in order, the first couple being (0, 1), the second
        couple being (2, 3), and so on with the last couple being (2N-2,
        2N-1).
    
    
        The couples' initial seating is given by row[i] being the value of the person
        who is initially sitting in the i-th seat.

    Example 1:
    Input: row = [0, 2, 1, 3]
Output: 1
Explanation: We only need to swap the second (row[1]) and third (row[2]) person.

    

    Example 2:
    Input: row = [3, 2, 0, 1]
Output: 0
Explanation: All couples are already seated side by side.

    

    
        Note:
    
        len(row) is even and in the range of [4, 60].
        row is guaranteed to be a permutation of 0...len(row)-1.
-----------------

# 187_Repeated_DNA_Sequences
# 187. Repeated DNA Sequences

All DNA is composed of a series of nucleotides abbreviated as A, C, G, and T, for example:
        "ACGAATTCCG". When studying DNA, it is sometimes useful to identify repeated
        sequences within the DNA.

    Write a function to find all the 10-letter-long sequences (substrings) that occur more than
        once in a DNA molecule.

    Example:

    Input: s = "AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT"

Output: ["AAAAACCCCC", "CCCCCAAAAA"]
-----------------

# 456_132_Pattern
# 456. 132 Pattern

Given a sequence of n integers a1, a2, ..., an, a 132
        pattern is a subsequence ai, aj, ak
        such
        that i < j < k and ai < ak < aj.
        Design an algorithm that takes a list of n numbers as input and checks whether there is a
        132 pattern in the list.

    Note: n will be less than 15,000.

    Example 1:
    Input: [1, 2, 3, 4]

Output: False

Explanation: There is no 132 pattern in the sequence.

    

    Example 2:
    Input: [3, 1, 4, 2]

Output: True

Explanation: There is a 132 pattern in the sequence: [1, 4, 2].

    

    Example 3:
    Input: [-1, 3, 2, 0]

Output: True

Explanation: There are three 132 patterns in the sequence: [-1, 3, 2], [-1, 3, 0] and [-1, 2, 0].
-----------------

# 1159_Market_Analysis_II
# 1159. Market Analysis II

Table: Users

    +----------------+---------+
| Column Name    | Type    |
+----------------+---------+
| user_id        | int     |
| join_date      | date    |
| favorite_brand | varchar |
+----------------+---------+
user_id is the primary key of this table.
This table has the info of the users of an online shopping website where users can sell and buy items.

    Table: Orders

    +---------------+---------+
| Column Name   | Type    |
+---------------+---------+
| order_id      | int     |
| order_date    | date    |
| item_id       | int     |
| buyer_id      | int     |
| seller_id     | int     |
+---------------+---------+
order_id is the primary key of this table.
item_id is a foreign key to the Items table.
buyer_id and seller_id are foreign keys to the Users table.

    Table: Items

    +---------------+---------+
| Column Name   | Type    |
+---------------+---------+
| item_id       | int     |
| item_brand    | varchar |
+---------------+---------+
item_id is the primary key of this table.

     

    Write an SQL query to find for each user, whether the brand of the second item (by date) they
        sold is their favorite brand. If a user sold less than two items, report the
        answer for that user as no.

    It is guaranteed that no seller sold more than one item on a day.

    The query result format is in the following example:

    Users table:
+---------+------------+----------------+
| user_id | join_date  | favorite_brand |
+---------+------------+----------------+
| 1       | 2019-01-01 | Lenovo         |
| 2       | 2019-02-09 | Samsung        |
| 3       | 2019-01-19 | LG             |
| 4       | 2019-05-21 | HP             |
+---------+------------+----------------+

Orders table:
+----------+------------+---------+----------+-----------+
| order_id | order_date | item_id | buyer_id | seller_id |
+----------+------------+---------+----------+-----------+
| 1        | 2019-08-01 | 4       | 1        | 2         |
| 2        | 2019-08-02 | 2       | 1        | 3         |
| 3        | 2019-08-03 | 3       | 2        | 3         |
| 4        | 2019-08-04 | 1       | 4        | 2         |
| 5        | 2019-08-04 | 1       | 3        | 4         |
| 6        | 2019-08-05 | 2       | 2        | 4         |
+----------+------------+---------+----------+-----------+

Items table:
+---------+------------+
| item_id | item_brand |
+---------+------------+
| 1       | Samsung    |
| 2       | Lenovo     |
| 3       | LG         |
| 4       | HP         |
+---------+------------+

Result table:
+-----------+--------------------+
| seller_id | 2nd_item_fav_brand |
+-----------+--------------------+
| 1         | no                 |
| 2         | yes                |
| 3         | yes                |
| 4         | no                 |
+-----------+--------------------+

The answer for the user with id 1 is no because they sold nothing.
The answer for the users with id 2 and 3 is yes because the brands of their second sold items are their favorite brands.
The answer for the user with id 4 is no because the brand of their second sold item is not their favorite brand.
-----------------

# 861_Score_After_Flipping_Matrix
# 861. Score After Flipping Matrix

We have a two dimensional matrix A where each value is 0 or
        1.

    A move consists of choosing any row or column, and toggling each value in that row or column:
        changing all 0s to 1s, and all 1s to 0s.
    

    After making any number of moves, every row of this matrix is interpreted as a binary number,
        and the score of the matrix is the sum of these numbers.

    Return the highest possible score.
-----------------

# 343_Integer_Break
# 343. Integer Break

Given a positive integer n, break it into the sum of at least two positive
        integers and maximize the product of those integers. Return the maximum product you can get.
    

    Example 1:
-----------------

# 1436_Destination_City
# 1436. Destination City


-----------------

# 390_Elimination_Game
# 390. Elimination Game

There is a list of sorted integers from 1 to n. Starting from left to right, remove
        the first number and every other number afterward until you reach the end of the list.

    Repeat the previous step again, but this time from right to left, remove the right most
        number and every other number from the remaining numbers.

    We keep repeating the steps again, alternating left to right and right to left, until a
        single number remains.

    Find the last number that remains starting with a list of length n.

    Example:
    Input:
n = 9,
1 2 3 4 5 6 7 8 9
2 4 6 8
2 6
6

Output:
6
-----------------

# 815_Bus_Routes
# 815. Bus Routes

We have a list of bus routes. Each routes[i] is a bus route that the i-th bus repeats
        forever. For example if routes[0] = [1, 5, 7], this means that the first bus
        (0-th indexed) travels in the sequence 1->5->7->1->5->7->1->...
        forever.

    We start at bus stop S (initially not on a bus), and we want to go to bus stop
        T. Travelling by buses only, what is the least number of buses we must take to
        reach our destination? Return -1 if it is not possible.

    Example:
Input:
routes = [[1, 2, 7], [3, 6, 7]]
S = 1
T = 6
Output: 2
Explanation:
The best strategy is take the first bus to the bus stop 7, then take the second bus to the bus stop 6.

    Note: 

    
        1 <= routes.length <= 500.
        1 <= routes[i].length <= 500.
        0 <= routes[i][j] < 10 ^ 6.
-----------------

# 605_Can_Place_Flowers
# 605. Can Place Flowers

Suppose you have a long flowerbed in which some of the plots are planted and some are not.
        However, flowers cannot be planted in adjacent plots - they would compete for water and both
        would die.

    Given a flowerbed (represented as an array containing 0 and 1, where 0 means empty and 1
        means not empty), and a number n, return if n new flowers can be planted in it
        without violating the no-adjacent-flowers rule.

    Example 1:
    Input: flowerbed = [1,0,0,0,1], n = 1
Output: True

    

    Example 2:
    Input: flowerbed = [1,0,0,0,1], n = 2
Output: False

    

    Note:
    
        The input array won't violate no-adjacent-flowers rule.
        The input array size is in the range of [1, 20000].
        n is a non-negative integer which won't exceed the input array size.
-----------------

# 407_Trapping_Rain_Water_II
# 407. Trapping Rain Water II

Given an m x n matrix of positive integers representing the height of each unit
        cell in a 2D elevation map, compute the volume of water it is able to trap after raining.
    

     

    Note:

    Both m and n are less than 110. The height of each unit cell is greater than 0
        and is less than 20,000.

     

    Example:

    Given the following 3x6 height map:
[
  [1,4,3,1,3,2],
  [3,2,1,3,2,4],
  [2,3,3,2,3,1]
]

Return 4.

    
        

    The above image represents the elevation map [[1,4,3,1,3,2],[3,2,1,3,2,4],[2,3,3,2,3,1]]
        before the rain.

     

    
        

    After the rain, water is trapped between the blocks. The total volume of water trapped is
        4.
-----------------

# 1476_Subrectangle_Queries
# 1476. Subrectangle Queries


-----------------

# 1215_Stepping_Numbers
# 1215. Stepping Numbers

A Stepping Number is an integer such that all of its adjacent digits
        have an absolute difference of exactly 1. For example, 321 is a
        Stepping Number while 421 is not.

    Given two integers low and high, find and return a
        sorted list of all the Stepping Numbers in the range [low,
            high] inclusive.

     
    Example 1:
    Input: low = 0, high = 21
Output: [0,1,2,3,4,5,6,7,8,9,10,12,21]

     
    Constraints:

    
        0 <= low <= high <= 2 * 10^9
-----------------

# 619_Biggest_Single_Number
# 619. Biggest Single Number

Table my_numbers contains many numbers in column num including duplicated
        ones.
        Can you write a SQL query to find the biggest number, which only appears once.

    +---+
|num|
+---+
| 8 |
| 8 |
| 3 |
| 3 |
| 1 |
| 4 |
| 5 |
| 6 |

    For the sample data above, your query should return the following result:

    +---+
|num|
+---+
| 6 |

    Note:
    If there is no such number, just output null.
-----------------

# 1846_Maximum_Element_After_Decreasing_and_Rearranging
# 1846. Maximum Element After Decreasing and Rearranging


-----------------

# 1500_Design_a_File_Sharing_System
# 1500. Design a File Sharing System


-----------------

# 277_Find_the_Celebrity
# 277. Find the Celebrity

Suppose you are at a party with n people (labeled from 0 to n
        - 1) and among them, there may exist one celebrity. The definition of a celebrity is
        that all the other n - 1 people know him/her but he/she does not know any of
        them.

    Now you want to find out who the celebrity is or verify that there is not one. The only thing
        you are allowed to do is to ask questions like: "Hi, A. Do you know B?" to get
        information of whether A knows B. You need to find out the celebrity (or verify there is not
        one) by asking as few questions as possible (in the asymptotic sense).

    You are given a helper function bool knows(a, b) which tells you whether A knows
        B. Implement a function int findCelebrity(n). There will be exactly one
        celebrity if he/she is in the party. Return the celebrity's label if there is a
        celebrity in the party. If there is no celebrity, return -1.

     

    Example 1:
    
    Input: graph = [
  [1,1,0],
  [0,1,0],
  [1,1,1]
]
Output: 1
Explanation: There are three persons labeled with 0, 1 and 2. graph[i][j] = 1 means person i knows person j, otherwise graph[i][j] = 0 means person i does not know person j. The celebrity is the person labeled as 1 because both 0 and 2 know him but 1 does not know anybody.

    Example 2:
    
    Input: graph = [
  [1,0,1],
  [1,1,0],
  [0,1,1]
]
Output: -1
Explanation: There is no celebrity.

     

    Note:

    
        The directed graph is represented as an adjacency matrix, which is an n x
            n matrix where a[i][j] = 1 means person i knows
            person j while a[i][j] = 0 means the contrary.
        
        Remember that you won't have direct access to the adjacency matrix.
-----------------

# 904_Fruit_Into_Baskets
# 904. Fruit Into Baskets

In a row of trees, the i-th tree produces fruit with type tree[i].
    

    You start at any tree of your choice, then repeatedly perform the
        following steps:

    
        Add one piece of fruit from this tree to your baskets.  If you cannot, stop.
        Move to the next tree to the right of the current tree.  If there is no tree to the
            right, stop.
        
    

    Note that you do not have any choice after the initial choice of starting tree: you must
        perform step 1, then step 2, then back to step 1, then step 2, and so on until you stop.

    You have two baskets, and each basket can carry any quantity of fruit, but you want each
        basket to only carry one type of fruit each.

    What is the total amount of fruit you can collect with this procedure?

     

    Example 1:

    Input: [1,2,1]
Output: 3
Explanation: We can collect [1,2,1].
-----------------

# 190_Reverse_Bits
# 190. Reverse Bits

Reverse bits of a given 32 bits unsigned integer.

     

    Example 1:

    Input: 00000010100101000001111010011100
Output: 00111001011110000010100101000000
Explanation: The input binary string 00000010100101000001111010011100 represents the unsigned integer 43261596, so return 964176192 which its binary representation is 00111001011110000010100101000000.

    Example 2:

    Input: 11111111111111111111111111111101
Output: 10111111111111111111111111111111
Explanation: The input binary string 11111111111111111111111111111101 represents the unsigned integer 4294967293, so return 3221225471 which its binary representation is 10101111110010110010011101101001.

     

    Note:

    
        Note that in some languages such as Java, there is no unsigned integer type. In this
            case, both input and output will be given as signed integer type and should not affect
            your implementation, as the internal binary representation of the integer is the same
            whether it is signed or unsigned.
        
        In Java, the compiler represents the signed integers using 2's
            complement notation. Therefore, in Example 2 above the input
            represents the signed integer -3 and the output represents the signed
            integer -1073741825.
        
    

     

    Follow up:

    If this function is called many times, how would you optimize it?
-----------------

# 1231_Divide_Chocolate
# 1231. Divide Chocolate

You have one chocolate bar that consists of some chunks. Each chunk has its own sweetness
        given by the array sweetness.

    You want to share the chocolate with your K friends so you start cutting
        the chocolate bar into K+1 pieces using K cuts,
        each piece consists of some consecutive chunks.

    Being generous, you will eat the piece with the minimum total sweetness and
        give the other pieces to your friends.

    Find the maximum total sweetness of the piece you can get by cutting
        the chocolate bar optimally.

     
    Example 1:

    Input: sweetness = [1,2,3,4,5,6,7,8,9], K = 5
Output: 6
Explanation: You can divide the chocolate to [1,2,3], [4,5], [6], [7], [8], [9]

    Example 2:

    Input: sweetness = [5,6,7,8,9,1,2,3,4], K = 8
Output: 1
Explanation: There is only one way to cut the bar into 9 pieces.

    Example 3:

    Input: sweetness = [1,2,2,1,2,2,1,2,2], K = 2
Output: 5
Explanation: You can divide the chocolate to [1,2,2], [1,2,2], [1,2,2]

     
    Constraints:

    
        0 <= K < sweetness.length <= 10^4
        1 <= sweetness[i] <= 10^5
-----------------

# 905_Sort_Array_By_Parity
# 905. Sort Array By Parity

Given an array A of non-negative integers, return an array consisting of all the
        even elements of A, followed by all the odd elements of A.

    You may return any answer array that satisfies this condition.
-----------------

# 169_Majority_Element
# 169. Majority Element

Given an array of size n, find the majority element. The majority element is the
        element that appears more than ⌊ n/2 ⌋ times.

    You may assume that the array is non-empty and the majority element always exist in the
        array.

    Example 1:

    Input: [3,2,3]
Output: 3

    Example 2:

    Input: [2,2,1,1,1,2,2]
Output: 2
-----------------

# 1491_Average_Salary_Excluding_the_Minimum_and_Maximum_Salary
# 1491. Average Salary Excluding the Minimum and Maximum Salary


-----------------

# 1055_Shortest_Way_to_Form_String
# 1055. Shortest Way to Form String

From any string, we can form a subsequence of that string by deleting some number of
        characters (possibly no deletions).

    Given two strings source and target, return the minimum number of
        subsequences of source such that their concatenation equals target.
        If the task is impossible, return -1.

     

    Example 1:

    Input: source = "abc", target = "abcbc"
Output: 2
Explanation: The target "abcbc" can be formed by "abc" and "bc", which are subsequences of source "abc".

    Example 2:

    Input: source = "abc", target = "acdbc"
Output: -1
Explanation: The target string cannot be constructed from the subsequences of source string due to the character "d" in target string.

    Example 3:

    Input: source = "xyz", target = "xzyxz"
Output: 3
Explanation: The target string can be constructed as follows "xz" + "y" + "xz".

     
    Constraints:

    
        Both the source and target strings consist of only lowercase
            English letters from "a"-"z".
        
        The lengths of source and target string are between
            1 and 1000.
-----------------

# 1810_Minimum_Path_Cost_in_a_Hidden_Grid
# 1810. Minimum Path Cost in a Hidden Grid


-----------------

# 1652_Defuse_the_Bomb
# 1652. Defuse the Bomb


-----------------

# 1129_Shortest_Path_with_Alternating_Colors
# 1129. Shortest Path with Alternating Colors

Consider a directed graph, with nodes labelled 0, 1, ..., n-1.  In this
        graph, each edge is either red or blue, and there could be self-edges or parallel
        edges.

    Each [i, j] in red_edges denotes a red directed edge from node
        i to node j.  Similarly, each [i, j] in blue_edges
        denotes a blue directed edge from node i to node j.

    Return an array answer of length n, where
        each answer[X] is the length of the shortest path from node
        0 to node X such that the edge colors alternate along
        the path (or -1 if such a path doesn't exist).

     
    Example 1:
    Input: n = 3, red_edges = [[0,1],[1,2]], blue_edges = []
Output: [0,1,-1]

    Example 2:
    Input: n = 3, red_edges = [[0,1]], blue_edges = [[2,1]]
Output: [0,1,-1]

    Example 3:
    Input: n = 3, red_edges = [[1,0]], blue_edges = [[2,1]]
Output: [0,-1,-1]

    Example 4:
    Input: n = 3, red_edges = [[0,1]], blue_edges = [[1,2]]
Output: [0,1,2]

    Example 5:
    Input: n = 3, red_edges = [[0,1],[0,2]], blue_edges = [[1,0]]
Output: [0,1,1]

     
    Constraints:

    
        1 <= n <= 100
        red_edges.length <= 400
        blue_edges.length <= 400
        red_edges[i].length == blue_edges[i].length == 2
        0 <= red_edges[i][j], blue_edges[i][j] < n
-----------------

# 98_Validate_Binary_Search_Tree
# 98. Validate Binary Search Tree

Given a binary tree, determine if it is a valid binary search tree (BST).

    Assume a BST is defined as follows:

    
        The left subtree of a node contains only nodes with keys less than the
            node's key.
        
        The right subtree of a node contains only nodes with keys greater than
            the node's key.
        
        Both the left and right subtrees must also be binary search trees.
    

     

    Example 1:

        2
   / \
  1   3

Input: [2,1,3]
Output: true

    Example 2:

        5
   / \
  1   4
     / \
    3   6

Input: [5,1,4,null,null,3,6]
Output: false
Explanation: The root node's value is 5 but its right child's value is 4.
-----------------

# 1194_Tournament_Winners
# 1194. Tournament Winners

Table: Players

    +-------------+-------+
| Column Name | Type  |
+-------------+-------+
| player_id   | int   |
| group_id    | int   |
+-------------+-------+
player_id is the primary key of this table.
Each row of this table indicates the group of each player.

    Table: Matches

    +---------------+---------+
| Column Name   | Type    |
+---------------+---------+
| match_id      | int     |
| first_player  | int     |
| second_player | int     |
| first_score   | int     |
| second_score  | int     |
+---------------+---------+
match_id is the primary key of this table.
Each row is a record of a match, first_player and second_player contain the player_id of each match.
first_score and second_score contain the number of points of the first_player and second_player respectively.
You may assume that, in each match, players belongs to the same group.

     

    The winner in each group is the player who scored the maximum total points within the group. In
        the case of a tie, the lowest player_id wins.

    Write an SQL query to find the winner in each group.

    The query result format is in the following example:

    Players table:
+-----------+------------+
| player_id | group_id   |
+-----------+------------+
| 15        | 1          |
| 25        | 1          |
| 30        | 1          |
| 45        | 1          |
| 10        | 2          |
| 35        | 2          |
| 50        | 2          |
| 20        | 3          |
| 40        | 3          |
+-----------+------------+

Matches table:
+------------+--------------+---------------+-------------+--------------+
| match_id   | first_player | second_player | first_score | second_score |
+------------+--------------+---------------+-------------+--------------+
| 1          | 15           | 45            | 3           | 0            |
| 2          | 30           | 25            | 1           | 2            |
| 3          | 30           | 15            | 2           | 0            |
| 4          | 40           | 20            | 5           | 2            |
| 5          | 35           | 50            | 1           | 1            |
+------------+--------------+---------------+-------------+--------------+

Result table:
+-----------+------------+
| group_id  | player_id  |
+-----------+------------+
| 1         | 15         |
| 2         | 35         |
| 3         | 40         |
+-----------+------------+
-----------------

# 652_Find_Duplicate_Subtrees
# 652. Find Duplicate Subtrees

Given a binary tree, return all duplicate subtrees. For each kind of duplicate subtrees, you
        only need to return the root node of any one of them.

    Two trees are duplicate if they have the same structure with same node values.

    Example 1: 

            1
       / \
      2   3
     /   / \
    4   2   4
       /
      4

    The following are two duplicate subtrees:

          2
     /
    4

    and

        4

    Therefore, you need to return above trees' root in the form of a list.
-----------------

# 27_Remove_Element
# 27. Remove Element

Given an array nums and a value val, remove all instances of that value in-place and return the new length.

    Do not allocate extra space for another array, you must do this by modifying the
        input array in-place
        with O(1) extra memory.

    The order of elements can be changed. It doesn't matter what you leave beyond the new
        length.

    Example 1:

    Given nums = [3,2,2,3], val = 3,

Your function should return length = 2, with the first two elements of nums being 2.

It doesn't matter what you leave beyond the returned length.

    Example 2:

    Given nums = [0,1,2,2,3,0,4,2], val = 2,

Your function should return length = 5, with the first five elements of nums containing 0, 1, 3, 0, and 4.

Note that the order of those five elements can be arbitrary.

It doesn't matter what values are set beyond the returned length.

    Clarification:

    Confused why the returned value is an integer but your answer is an array?

    Note that the input array is passed in by reference, which means
        modification to the input array will be known to the caller as well.

    Internally you can think of this:

    // nums is passed in by reference. (i.e., without making a copy)
int len = removeElement(nums, val);

// any modification to nums in your function would be known by the caller.
// using the length returned by your function, it prints the first len elements.
for (int i = 0; i < len; i++) {
    print(nums[i]);
}
-----------------

# 1689_Partitioning_Into_Minimum_Number_Of_Deci-Binary_Numbers
# 1689. Partitioning Into Minimum Number Of Deci-Binary Numbers


-----------------

# 1666_Change_the_Root_of_a_Binary_Tree
# 1666. Change the Root of a Binary Tree


-----------------

# 884_Uncommon_Words_from_Two_Sentences
# 884. Uncommon Words from Two Sentences

We are given two sentences A and B.  (A sentence is
        a string of space separated words.  Each word consists only of lowercase
        letters.)

    A word is uncommon if it appears exactly once in one of the sentences, and does
        not appear in the other sentence.

    Return a list of all uncommon words. 

    You may return the list in any order.
-----------------

# 253_Meeting_Rooms_II
# 253. Meeting Rooms II

Given an array of meeting time intervals consisting of start and end times [[s1,e1],[s2,e2],...]
        (si < ei), find the minimum number of conference rooms required.
    

    Example 1:

    Input: [[0, 30],[5, 10],[15, 20]]
Output: 2

    Example 2:

    Input: [[7,10],[2,4]]
Output: 1

    NOTE: input types have been changed on April 15, 2019. Please reset to
        default code definition to get new method signature.
-----------------

# 76_Minimum_Window_Substring
# 76. Minimum Window Substring

Given a string S and a string T, find the minimum window in S which will contain all the
        characters in T in complexity O(n).

    Example:

    Input: S = "ADOBECODEBANC", T = "ABC"
Output: "BANC"

    Note:

    
        If there is no such window in S that covers all characters in T, return the empty string
            "".
        
        If there is such window, you are guaranteed that there will always be only one unique
            minimum window in S.
-----------------

# 828_Unique_Letter_String
# 828. Unique Letter String

A character is unique in string S if it occurs exactly once in it.

    For example, in string S = "LETTER", the only unique characters are
        "L" and "R".

    Let's define UNIQ(S) as the number of unique characters in string
        S.

    For example, UNIQ("LETTER") =  2.

    Given a string S with only uppercases, calculate the sum of UNIQ(substring)
        over all non-empty substrings of S.

    If there are two or more equal substrings at different positions in S, we
        consider them different.

    Since the answer can be very large, return the answer modulo 10 ^ 9 +
        7.

     

    Example 1:

    Input: "ABC"
Output: 10
Explanation: All possible substrings are: "A","B","C","AB","BC" and "ABC".
Evey substring is composed with only unique letters.
Sum of lengths of all substring is 1 + 1 + 1 + 2 + 2 + 3 = 10

    Example 2:

    Input: "ABA"
Output: 8
Explanation: The same as example 1, except uni("ABA") = 1.

     

    Note: 0 <= S.length <= 10000.
-----------------

# 1796_Second_Largest_Digit_in_a_String
# 1796. Second Largest Digit in a String


-----------------

# 1750_Minimum_Length_of_String_After_Deleting_Similar_Ends
# 1750. Minimum Length of String After Deleting Similar Ends


-----------------

# 1831_Maximum_Transaction_Each_Day
# 1831. Maximum Transaction Each Day


-----------------

# 1504_Count_Submatrices_With_All_Ones
# 1504. Count Submatrices With All Ones


-----------------

# 237_Delete_Node_in_a_Linked_List
# 237. Delete Node in a Linked List

Write a function to delete a node (except the tail) in a singly linked list, given only
        access to that node.

    Given linked list -- head = [4,5,1,9], which looks like following:

     

    Example 1:
    

    Input: head = [4,5,1,9], node = 5
Output: [4,1,9]
Explanation: You are given the second node with value 5, the linked list should become 4 -> 1 -> 9 after calling your function.

    Example 2:
    

    Input: head = [4,5,1,9], node = 1
Output: [4,5,9]
Explanation: You are given the third node with value 1, the linked list should become 4 -> 5 -> 9 after calling your function.

     

    Note:

    
        The linked list will have at least two elements.
        All of the nodes' values will be unique.
        The given node will not be the tail and it will always be a valid node of the
            linked list.
        
        Do not return anything from your function.
-----------------

# 394_Decode_String
# 394. Decode String

Given an encoded string, return its decoded string.

    The encoding rule is: k[encoded_string], where the encoded_string inside
        the square brackets is being repeated exactly k times. Note that k is
        guaranteed to be a positive integer.

    You may assume that the input string is always valid; No extra white spaces, square brackets
        are well-formed, etc.

    Furthermore, you may assume that the original data does not contain any digits and that
        digits are only for those repeat numbers, k. For example, there won't be input
        like 3a or 2[4].

    Examples:

    s = "3[a]2[bc]", return "aaabcbc".
s = "3[a2[c]]", return "accaccacc".
s = "2[abc]3[cd]ef", return "abcabccdcdcdef".
-----------------

# 1107_New_Users_Daily_Count
# 1107. New Users Daily Count

Table: Traffic

    +---------------+---------+
| Column Name   | Type    |
+---------------+---------+
| user_id       | int     |
| activity      | enum    |
| activity_date | date    |
+---------------+---------+
There is no primary key for this table, it may have duplicate rows.
The activity column is an ENUM type of ('login', 'logout', 'jobs', 'groups', 'homepage').

     

    Write an SQL query that reports for every date within at most 90 days
        from today, the number of users that logged in for the first time on that date. Assume today
        is 2019-06-30.

    The query result format is in the following example:

    Traffic table:
+---------+----------+---------------+
| user_id | activity | activity_date |
+---------+----------+---------------+
| 1       | login    | 2019-05-01    |
| 1       | homepage | 2019-05-01    |
| 1       | logout   | 2019-05-01    |
| 2       | login    | 2019-06-21    |
| 2       | logout   | 2019-06-21    |
| 3       | login    | 2019-01-01    |
| 3       | jobs     | 2019-01-01    |
| 3       | logout   | 2019-01-01    |
| 4       | login    | 2019-06-21    |
| 4       | groups   | 2019-06-21    |
| 4       | logout   | 2019-06-21    |
| 5       | login    | 2019-03-01    |
| 5       | logout   | 2019-03-01    |
| 5       | login    | 2019-06-21    |
| 5       | logout   | 2019-06-21    |
+---------+----------+---------------+

Result table:
+------------+-------------+
| login_date | user_count  |
+------------+-------------+
| 2019-05-01 | 1           |
| 2019-06-21 | 2           |
+------------+-------------+
Note that we only care about dates with non zero user count.
The user with id 5 first logged in on 2019-03-01 so he's not counted on 2019-06-21.
-----------------

# 1552_Magnetic_Force_Between_Two_Balls
# 1552. Magnetic Force Between Two Balls


-----------------

# 1751_Maximum_Number_of_Events_That_Can_Be_Attended_II
# 1751. Maximum Number of Events That Can Be Attended II


-----------------

# 1377_Frog_Position_After_T_Seconds
# 1377. Frog Position After T Seconds


-----------------

# 174_Dungeon_Game
# 174. Dungeon Game

table.dungeon, .dungeon th, .dungeon td {
  border:3px solid black;
}

 .dungeon th, .dungeon td {
    text-align: center;
    height: 70px;
    width: 70px;
}

    
    The demons had captured the princess (P) and imprisoned her in the
        bottom-right corner of a dungeon. The dungeon consists of M x N rooms laid out in a 2D grid.
        Our valiant knight (K) was initially positioned in the top-left room and
        must fight his way through the dungeon to rescue the princess.

    The knight has an initial health point represented by a positive integer. If at any point his
        health point drops to 0 or below, he dies immediately.

    Some of the rooms are guarded by demons, so the knight loses health (negative
        integers) upon entering these rooms; other rooms are either empty (0's) or
        contain magic orbs that increase the knight's health (positive integers).

    In order to reach the princess as quickly as possible, the knight decides to move only
        rightward or downward in each step.

     

    Write a function to determine the knight's minimum initial health so that he is
        able to rescue the princess.

    For example, given the dungeon below, the initial health of the knight must be at least
        7 if he follows the optimal path RIGHT-> RIGHT -> DOWN ->
            DOWN.

    
        
        
            -2 (K)
            -3
            3
        
        
            -5
            -10
            1
        
        
            10
            30
            -5 (P)
        
        
    

     

    Note:

    
        The knight's health has no upper bound.
        Any room can contain threats or power-ups, even the first room the knight enters and the
            bottom-right room where the princess is imprisoned.
-----------------

# 617_Merge_Two_Binary_Trees
# 617. Merge Two Binary Trees

Given two binary trees and imagine that when you put one of them to cover the other, some
        nodes of the two trees are overlapped while the others are not.

    You need to merge them into a new binary tree. The merge rule is that if two nodes overlap,
        then sum node values up as the new value of the merged node. Otherwise, the NOT null node
        will be used as the node of new tree.

    Example 1:

    Input:
	Tree 1                     Tree 2
          1                         2
         / \                       / \
        3   2                     1   3
       /                           \   \
      5                             4   7
Output:
Merged tree:
	     3
	    / \
	   4   5
	  / \   \
	 5   4   7

     

    Note: The merging process must start from the root nodes of both trees.
-----------------

# 1223_Dice_Roll_Simulation
# 1223. Dice Roll Simulation

A die simulator generates a random number from 1 to 6 for each roll. You introduced a
        constraint to the generator such that it cannot roll the number i more than
        rollMax[i] (1-indexed) consecutive times. 

    Given an array of integers rollMax and an integer n,
        return the number of distinct sequences that can be obtained with exact n
        rolls.

    Two sequences are considered different if at least one element differs from each other. Since
        the answer may be too large, return it modulo 10^9 + 7.

     
    Example 1:

    Input: n = 2, rollMax = [1,1,2,2,2,3]
Output: 34
Explanation: There will be 2 rolls of die, if there are no constraints on the die, there are 6 * 6 = 36 possible combinations. In this case, looking at rollMax array, the numbers 1 and 2 appear at most once consecutively, therefore sequences (1,1) and (2,2) cannot occur, so the final answer is 36-2 = 34.

    Example 2:

    Input: n = 2, rollMax = [1,1,1,1,1,1]
Output: 30

    Example 3:

    Input: n = 3, rollMax = [1,1,1,2,2,3]
Output: 181

     
    Constraints:

    
        1 <= n <= 5000
        rollMax.length == 6
        1 <= rollMax[i] <= 15
-----------------

# 552_Student_Attendance_Record_II
# 552. Student Attendance Record II

Given a positive integer n, return the number of all possible attendance records with
        length n, which will be regarded as rewardable. The answer may be very large, return it
        after mod 109 + 7.

    A student attendance record is a string that only contains the following three
        characters:

    
    
        'A' : Absent.
        'L' : Late.
        'P' : Present.
    
    

    
        A record is regarded as rewardable if it doesn't contain more than one 'A' (absent)
        or more than two continuous 'L' (late).

    Example 1:
    Input: n = 2
Output: 8
Explanation:
There are 8 records with length 2 will be regarded as rewardable:
"PP" , "AP", "PA", "LP", "PL", "AL", "LA", "LL"
Only "AA" won't be regarded as rewardable owing to more than one absent times.

    

    Note:
        The value of n won't exceed 100,000.
-----------------

# 740_Delete_and_Earn
# 740. Delete and Earn

Given an array nums of integers, you can perform operations on the array.

    In each operation, you pick any nums[i] and delete it to earn
        nums[i] points. After, you must delete every element equal to nums[i]
            - 1 or nums[i] + 1.

    You start with 0 points. Return the maximum number of points you can earn by applying such
        operations.

    Example 1:

    Input: nums = [3, 4, 2]
Output: 6
Explanation:
Delete 4 to earn 4 points, consequently 3 is also deleted.
Then, delete 2 to earn 2 points. 6 total points are earned.

     

    Example 2:

    Input: nums = [2, 2, 3, 3, 3, 4]
Output: 9
Explanation:
Delete 3 to earn 3 points, deleting both 2's and the 4.
Then, delete 3 again to earn 3 points, and 3 again to earn 3 points.
9 total points are earned.

     

    Note:

    
        The length of nums is at most 20000.
        Each element nums[i] is an integer in the range [1, 10000].
-----------------

# 339_Nested_List_Weight_Sum
# 339. Nested List Weight Sum

Given a nested list of integers, return the sum of all integers in the list weighted by their
        depth.

    Each element is either an integer, or a list -- whose elements may also be integers or other
        lists.
-----------------

# 654_Maximum_Binary_Tree
# 654. Maximum Binary Tree

Given an integer array with no duplicates. A maximum tree building on this array is defined
        as follow:
    
        The root is the maximum number in the array.
        The left subtree is the maximum tree constructed from left part subarray divided by the
            maximum number.
        
        The right subtree is the maximum tree constructed from right part subarray divided by
            the maximum number.
        
    
    

    
        Construct the maximum tree by the given array and output the root node of this tree.
    

    Example 1:
    Input: [3,2,1,6,0,5]
Output: return the tree root node representing the following tree:

      6
    /   \
   3     5
    \    /
     2  0
       \
        1

    

    Note:
    
        The size of the given array will be in the range [1,1000].
-----------------

# 694_Number_of_Distinct_Islands
# 694. Number of Distinct Islands

Given a non-empty 2D array grid of 0's and 1's, an island is a group of
        1's (representing land) connected 4-directionally (horizontal or vertical.) You
        may assume all four edges of the grid are surrounded by water.

    Count the number of distinct islands. An island is considered to be the same as
        another if and only if one island can be translated (and not rotated or reflected) to equal
        the other.

    Example 1:
    11000
11000
00011
00011

    Given the above grid map, return 1.
    

    Example 2:
    11011
10000
00001
11011
    Given the above grid map, return 3.
    Notice that:
    11
1

    and
     1
11

    are considered different island shapes, because we do not consider reflection / rotation.
    

    Note:
        The length of each dimension in the given grid does not exceed 50.
-----------------

# 965_Univalued_Binary_Tree
# 965. Univalued Binary Tree

A binary tree is univalued if every node in the tree has the same value.

    Return true if and only if the given tree is univalued.

     

    Example 1:
    
    Input: [1,1,1,1,1,null,1]
Output: true
-----------------

# 822_Card_Flipping_Game
# 822. Card Flipping Game

On a table are N cards, with a positive integer printed on the front and back of
        each card (possibly different).

    We flip any number of cards, and after we choose one card. 

    If the number X on the back of the chosen card is not on the front of any
        card, then this number X is good.

    What is the smallest number that is good?  If no number is good, output 0.
    

    Here, fronts[i] and backs[i] represent the number on the front and
        back of card i. 

    A flip swaps the front and back numbers, so the value on the front is now on the back
        and vice versa.

    Example:

    Input: fronts = [1,2,4,4,7], backs = [1,3,4,1,3]
Output: 2
Explanation: If we flip the second card, the fronts are [1,3,4,4,7] and the backs are [1,2,4,1,3].
We choose the second card, which has number 2 on the back, and it isn't on the front of any card, so 2 is good.

     

    Note:

    
        1 <= fronts.length == backs.length <= 1000.
        1 <= fronts[i] <= 2000.
        1 <= backs[i] <= 2000.
-----------------

# 1015_Smallest_Integer_Divisible_by_K
# 1015. Smallest Integer Divisible by K

Given a positive integer K, you need find the smallest positive
        integer N such that N is divisible by K, and
        N only contains the digit 1.

    Return the length of N.  If there is no such N, return
        -1.

     

    Example 1:

    Input: 1
Output: 1
Explanation: The smallest answer is N = 1, which has length 1.

    Example 2:

    Input: 2
Output: -1
Explanation: There is no such positive integer N divisible by 2.

    Example 3:

    Input: 3
Output: 3
Explanation: The smallest answer is N = 111, which has length 3.

     

    Note:

    
        1 <= K <= 10^5
-----------------

# 968_Binary_Tree_Cameras
# 968. Binary Tree Cameras

Given a binary tree, we install cameras on the nodes of the tree. 

    Each camera at a node can monitor its parent, itself, and its immediate
        children.

    Calculate the minimum number of cameras needed to monitor all nodes of the tree.

     

    Example 1:
-----------------

# 944_Delete_Columns_to_Make_Sorted
# 944. Delete Columns to Make Sorted

We are given an array A of N lowercase letter strings, all of
        the same length.

    Now, we may choose any set of deletion indices, and for each string, we delete all the
        characters in those indices.

    For example, if we have an array A = ["abcdef","uvwxyz"]
        and deletion indices {0, 2, 3}, then the final array after deletions is ["bef",
            "vyz"], and the remaining columns of A
        are ["b","v"], ["e","y"],
        and ["f","z"].  (Formally, the c-th
        column is [A[0][c], A[1][c], ..., A[A.length-1][c]].)

    Suppose we chose a set of deletion indices D such that after deletions, each
        remaining column in A is in non-decreasing sorted order.

    Return the minimum possible value of D.length.
-----------------

# 1142_User_Activity_for_the_Past_30_Days_II
# 1142. User Activity for the Past 30 Days II

Table: Activity

    +---------------+---------+
| Column Name   | Type    |
+---------------+---------+
| user_id       | int     |
| session_id    | int     |
| activity_date | date    |
| activity_type | enum    |
+---------------+---------+
There is no primary key for this table, it may have duplicate rows.
The activity_type column is an ENUM of type ('open_session', 'end_session', 'scroll_down', 'send_message').
The table shows the user activities for a social media website.
Note that each session belongs to exactly one user.

     

    Write an SQL query to find the average number of sessions per user for a period of 30 days
        ending 2019-07-27 inclusively, rounded to 2 decimal
            places. The sessions we want to count for a user are those with at least one
        activity in that time period.

    The query result format is in the following example:

    Activity table:
+---------+------------+---------------+---------------+
| user_id | session_id | activity_date | activity_type |
+---------+------------+---------------+---------------+
| 1       | 1          | 2019-07-20    | open_session  |
| 1       | 1          | 2019-07-20    | scroll_down   |
| 1       | 1          | 2019-07-20    | end_session   |
| 2       | 4          | 2019-07-20    | open_session  |
| 2       | 4          | 2019-07-21    | send_message  |
| 2       | 4          | 2019-07-21    | end_session   |
| 3       | 2          | 2019-07-21    | open_session  |
| 3       | 2          | 2019-07-21    | send_message  |
| 3       | 2          | 2019-07-21    | end_session   |
| 3       | 5          | 2019-07-21    | open_session  |
| 3       | 5          | 2019-07-21    | scroll_down   |
| 3       | 5          | 2019-07-21    | end_session   |
| 4       | 3          | 2019-06-25    | open_session  |
| 4       | 3          | 2019-06-25    | end_session   |
+---------+------------+---------------+---------------+

Result table:
+---------------------------+
| average_sessions_per_user |
+---------------------------+
| 1.33                      |
+---------------------------+
User 1 and 2 each had 1 session in the past 30 days while user 3 had 2 sessions so the average is (1 + 1 + 2) / 3 = 1.33.
-----------------

# 94_Binary_Tree_Inorder_Traversal
# 94. Binary Tree Inorder Traversal

Given a binary tree, return the inorder traversal of its nodes' values.

    Example:

    Input: [1,null,2,3]
   1
    \
     2
    /
   3

Output: [1,3,2]

    Follow up: Recursive solution is trivial, could you do it iteratively?
-----------------

# 924_Minimize_Malware_Spread
# 924. Minimize Malware Spread

In a network of nodes, each node i is directly connected to another node
        j if and only if graph[i][j] = 1.

    Some nodes initial are initially infected by malware.  Whenever two nodes
        are directly connected and at least one of those two nodes is infected by malware, both
        nodes will be infected by malware.  This spread of malware will continue until no more
        nodes can be infected in this manner.

    Suppose M(initial) is the final number of nodes infected with malware in
        the entire network, after the spread of malware stops.

    We will remove one node from the initial list.  Return the node that if removed,
        would minimize M(initial).  If multiple nodes could be removed to
        minimize M(initial), return such a node with the smallest index.

    Note that if a node was removed from the initial list of infected nodes, it
        may still be infected later as a result of the malware spread.

     

    
    

    Example 1:

    Input: graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]
Output: 0

    Example 2:

    Input: graph = [[1,0,0],[0,1,0],[0,0,1]], initial = [0,2]
Output: 0

    Example 3:

    Input: graph = [[1,1,1],[1,1,1],[1,1,1]], initial = [1,2]
Output: 1

     

    Note:

    
        1 < graph.length = graph[0].length <= 300
        0 <= graph[i][j] == graph[j][i] <= 1
        graph[i][i] = 1
        1 <= initial.length < graph.length
        0 <= initial[i] < graph.length
-----------------

# 137_Single_Number_II
# 137. Single Number II

Given a non-empty array of integers, every element appears
        three times except for one, which appears exactly once. Find that single one.

    Note:

    Your algorithm should have a linear runtime complexity. Could you implement it without using
        extra memory?

    Example 1:

    Input: [2,2,3,2]
Output: 3

    Example 2:

    Input: [0,1,0,1,0,1,99]
Output: 99
-----------------

# 690_Employee_Importance
# 690. Employee Importance

You are given a data structure of employee information, which includes the employee's unique
        id, his importance value and his direct subordinates' id.

    For example, employee 1 is the leader of employee 2, and employee 2 is the leader of employee
        3. They have importance value 15, 10 and 5, respectively. Then employee 1 has a data
        structure like [1, 15, [2]], and employee 2 has [2, 10, [3]], and employee 3 has [3, 5, []].
        Note that although employee 3 is also a subordinate of employee 1, the relationship is not
            direct.

    Now given the employee information of a company, and an employee id, you need to return the
        total importance value of this employee and all his subordinates.

    Example 1:

    Input: [[1, 5, [2, 3]], [2, 3, []], [3, 3, []]], 1
Output: 11
Explanation:
Employee 1 has importance value 5, and he has two direct subordinates: employee 2 and employee 3. They both have importance value 3. So the total importance value of employee 1 is 5 + 3 + 3 = 11.

     

    Note:

    
        One employee has at most one direct leader and may have several subordinates.
        
        The maximum number of employees won't exceed 2000.
-----------------

# 434_Number_of_Segments_in_a_String
# 434. Number of Segments in a String

Count the number of segments in a string, where a segment is defined to be a contiguous
        sequence of non-space characters.

    Please note that the string does not contain any non-printable characters.

    Example:
    Input: "Hello, my name is John"
Output: 5
-----------------

# 885_Spiral_Matrix_III
# 885. Spiral Matrix III

On a 2 dimensional grid with R rows and C columns, we start at
        (r0, c0) facing east.

    Here, the north-west corner of the grid is at the first row and column, and the
        south-east corner of the grid is at the last row and column.

    Now, we walk in a clockwise spiral shape to visit every position in this grid. 

    Whenever we would move outside the boundary of the grid, we continue our walk outside the
        grid (but may return to the grid boundary later.) 

    Eventually, we reach all R * C spaces of the grid.

    Return a list of coordinates representing the positions of the grid in the order they were
        visited.

     

    Example 1:

    Input: R = 1, C = 4, r0 = 0, c0 = 0
Output: [[0,0],[0,1],[0,2],[0,3]]

     

    Example 2:

    Input: R = 5, C = 6, r0 = 1, c0 = 4
Output: [[1,4],[1,5],[2,5],[2,4],[2,3],[1,3],[0,3],[0,4],[0,5],[3,5],[3,4],[3,3],[3,2],[2,2],[1,2],[0,2],[4,5],[4,4],[4,3],[4,2],[4,1],[3,1],[2,1],[1,1],[0,1],[4,0],[3,0],[2,0],[1,0],[0,0]]
-----------------

# 378_Kth_Smallest_Element_in_a_Sorted_Matrix
# 378. Kth Smallest Element in a Sorted Matrix

Given a n x n matrix where each of the rows and columns are sorted in ascending
        order, find the kth smallest element in the matrix.

    
        Note that it is the kth smallest element in the sorted order, not the kth distinct element.
    

    Example:
    matrix = [
   [ 1,  5,  9],
   [10, 11, 13],
   [12, 13, 15]
],
k = 8,

return 13.

    

    Note: 
        You may assume k is always valid, 1 ≤ k ≤ n2.
-----------------

# 597_Friend_Requests_I_Overall_Acceptance_Rate
# 597. Friend Requests I: Overall Acceptance Rate

In social network like Facebook or Twitter, people send friend requests and accept others’
    requests as well. Now given two tables as below:
     
    Table: friend_request

    | sender_id | send_to_id |request_date|
|-----------|------------|------------|
| 1         | 2          | 2016_06-01 |
| 1         | 3          | 2016_06-01 |
| 1         | 4          | 2016_06-01 |
| 2         | 3          | 2016_06-02 |
| 3         | 4          | 2016-06-09 |

     
    Table: request_accepted

    | requester_id | accepter_id |accept_date |
|--------------|-------------|------------|
| 1            | 2           | 2016_06-03 |
| 1            | 3           | 2016-06-08 |
| 2            | 3           | 2016-06-08 |
| 3            | 4           | 2016-06-09 |
| 3            | 4           | 2016-06-10 |

     
    Write a query to find the overall acceptance rate of requests rounded to 2 decimals, which is
    the number of acceptance divide the number of requests.

     
    For the sample data above, your query should return the following result.

     

    |accept_rate|
|-----------|
|       0.80|

     
    Note:

    
        The accepted requests are not necessarily from the table friend_request. In
            this case, you just need to simply count the total accepted requests (no matter whether
            they are in the original requests), and divide it by the number of requests to get the
            acceptance rate.
        
        It is possible that a sender sends multiple requests to the same receiver, and a request
            could be accepted more than once. In this case, the ‘duplicated’ requests or
            acceptances are only counted once.
        
        If there is no requests at all, you should return 0.00 as the accept_rate.
    

     
    Explanation: There are 4 unique accepted requests, and there are 5 requests in total. So
    the rate is 0.80.

     
    Follow-up:

    
        Can you write a query to return the accept rate but for every month?
        How about the cumulative accept rate for every day?
-----------------

# 1774_Closest_Dessert_Cost
# 1774. Closest Dessert Cost


-----------------

# 85_Maximal_Rectangle
# 85. Maximal Rectangle

Given a 2D binary matrix filled with 0's and 1's, find the largest rectangle
        containing only 1's and return its area.

    Example:

    Input:
[
  ["1","0","1","0","0"],
  ["1","0","1","1","1"],
  ["1","1","1","1","1"],
  ["1","0","0","1","0"]
]
Output: 6
-----------------

# 1233_Remove_Sub-Folders_from_the_Filesystem
# 1233. Remove Sub-Folders from the Filesystem

Given a list of folders, remove all sub-folders in those folders and return in any
        order the folders after removing.

    If a folder[i] is located within another folder[j], it is
        called a sub-folder of it.

    The format of a path is one or more concatenated strings of the
        form: / followed by one or more lowercase English letters. For
        example, /leetcode and /leetcode/problems are
        valid paths while an empty string and / are not.

     
    Example 1:

    Input: folder = ["/a","/a/b","/c/d","/c/d/e","/c/f"]
Output: ["/a","/c/d","/c/f"]
Explanation: Folders "/a/b/" is a subfolder of "/a" and "/c/d/e" is inside of folder "/c/d" in our filesystem.

    Example 2:

    Input: folder = ["/a","/a/b/c","/a/b/d"]
Output: ["/a"]
Explanation: Folders "/a/b/c" and "/a/b/d/" will be removed because they are subfolders of "/a".

    Example 3:

    Input: folder = ["/a/b/c","/a/b/ca","/a/b/d"]
Output: ["/a/b/c","/a/b/ca","/a/b/d"]

     
    Constraints:

    
        1 <= folder.length <= 4 * 10^4
        2 <= folder[i].length <= 100
        folder[i] contains only lowercase letters and '/'
        folder[i] always starts with character '/'
        Each folder name is unique.
-----------------

# 715_Range_Module
# 715. Range Module

A Range Module is a module that tracks ranges of numbers. Your task is to design and
        implement the following interfaces in an efficient manner.

    
    addRange(int left, int right) Adds the half-open interval [left,
        right), tracking every real number in that interval. Adding an interval that
        partially overlaps with currently tracked numbers should add any numbers in the interval
        [left, right) that are not already tracked.
    
    

    
    queryRange(int left, int right) Returns true if and only if every real number
        in the interval [left, right)
        is currently being tracked.
    
    

    
    removeRange(int left, int right) Stops tracking every real number currently
        being tracked in the interval [left, right).
    
    

    Example 1:
    addRange(10, 20): null
removeRange(14, 16): null
queryRange(10, 14): true (Every number in [10, 14) is being tracked)
queryRange(13, 15): false (Numbers like 14, 14.03, 14.17 in [13, 15) are not being tracked)
queryRange(16, 17): true (The number 16 in [16, 17) is still being tracked, despite the remove operation)

    

    Note:
    A half open interval [left, right) denotes all real numbers left <= x <
        right.
    

    0 < left < right < 10^9 in all calls to addRange, queryRange,
        removeRange.
    
    The total number of calls to addRange in a single test case is at most 1000.
    
    The total number of calls to queryRange in a single test case is at most 5000.
    
    The total number of calls to removeRange in a single test case is at most
        1000.
-----------------

# 1851_Minimum_Interval_to_Include_Each_Query
# 1851. Minimum Interval to Include Each Query


-----------------

# 1570_Dot_Product_of_Two_Sparse_Vectors
# 1570. Dot Product of Two Sparse Vectors


-----------------

# 578_Get_Highest_Answer_Rate_Question
# 578. Get Highest Answer Rate Question

Get the highest answer rate question from a table survey_log with these columns:
        uid, action, question_id, answer_id, q_num,
        timestamp.

    uid means user id; action has these kind of values: "show", "answer",
        "skip"; answer_id is not null when action column is "answer", while is
        null for "show" and "skip"; q_num is the numeral order of the question
        in current session.

    Write a sql query to identify the question which has the highest answer rate.

    Example:

    Input:
+------+-----------+--------------+------------+-----------+------------+
| uid  | action    | question_id  | answer_id  | q_num     | timestamp  |
+------+-----------+--------------+------------+-----------+------------+
| 5    | show      | 285          | null       | 1         | 123        |
| 5    | answer    | 285          | 124124     | 1         | 124        |
| 5    | show      | 369          | null       | 2         | 125        |
| 5    | skip      | 369          | null       | 2         | 126        |
+------+-----------+--------------+------------+-----------+------------+
Output:
+-------------+
| survey_log  |
+-------------+
|    285      |
+-------------+
Explanation:
question 285 has answer rate 1/1, while question 369 has 0/1 answer rate, so output 285.

     

    Note: The highest answer rate meaning is: answer number's ratio in show number in
        the same question.
-----------------

# 1360_Number_of_Days_Between_Two_Dates
# 1360. Number of Days Between Two Dates


-----------------

# 723_Candy_Crush
# 723. Candy Crush

This question is about implementing a basic elimination algorithm for Candy Crush.

    Given a 2D integer array board representing the grid of candy, different
        positive integers board[i][j] represent different types of candies. A value of
        board[i][j] = 0 represents that the cell at position (i, j) is
        empty. The given board represents the state of the game following the player's move.
        Now, you need to restore the board to a stable state by crushing candies according to
        the following rules:

    
        If three or more candies of the same type are adjacent vertically or horizontally,
            "crush" them all at the same time - these positions become empty.
        
        After crushing all candies simultaneously, if an empty space on the board has candies on
            top of itself, then these candies will drop until they hit a candy or bottom at the same
            time. (No new candies will drop outside the top boundary.)
        
        After the above steps, there may exist more candies that can be crushed. If so, you need
            to repeat the above steps.
        
        If there does not exist more candies that can be crushed (ie. the board is stable),
            then return the current board.
        
    

    You need to perform the above rules until the board becomes stable, then return the current
        board.

     

    Example:

    Input:
board =
[[110,5,112,113,114],[210,211,5,213,214],[310,311,3,313,314],[410,411,412,5,414],[5,1,512,3,3],[610,4,1,613,614],[710,1,2,713,714],[810,1,2,1,1],[1,1,2,2,2],[4,1,4,4,1014]]

Output:
[[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[110,0,0,0,114],[210,0,0,0,214],[310,0,0,113,314],[410,0,0,213,414],[610,211,112,313,614],[710,311,412,613,714],[810,411,512,713,1014]]

Explanation:

     

    Note:

    
        The length of board will be in the range [3, 50].
        The length of board[i] will be in the range [3, 50].
        Each board[i][j] will initially start as an integer in the range [1, 2000].
-----------------

# 6_ZigZag_Conversion
# 6. ZigZag Conversion

The string "PAYPALISHIRING" is written in a zigzag pattern on a given
        number of rows like this: (you may want to display this pattern in a fixed font for better
        legibility)

    P   A   H   N
A P L S I I G
Y   I   R

    And then read line by line: "PAHNAPLSIIGYIR"

    Write the code that will take a string and make this conversion given a number of rows:

    string convert(string s, int numRows);

    Example 1:

    Input: s = "PAYPALISHIRING", numRows = 3
Output: "PAHNAPLSIIGYIR"

    Example 2:

    Input: s = "PAYPALISHIRING", numRows = 4
Output: "PINALSIGYAHRPI"
Explanation:

P     I    N
A   L S  I G
Y A   H R
P     I
-----------------

# 84_Largest_Rectangle_in_Histogram
# 84. Largest Rectangle in Histogram

Given n non-negative integers representing the histogram's bar height where the
        width of each bar is 1, find the area of largest rectangle in the histogram.

     

    
        
        Above is a histogram where width of each bar is 1, given height =
            [2,1,5,6,2,3].
        
    

     

    
        
        The largest rectangle is shown in the shaded area, which has area = 10
            unit.
        
    

     

    Example:

    Input: [2,1,5,6,2,3]
Output: 10
-----------------

# 1148_Article_Views_I
# 1148. Article Views I

Table: Views

    +---------------+---------+
| Column Name   | Type    |
+---------------+---------+
| article_id    | int     |
| author_id     | int     |
| viewer_id     | int     |
| view_date     | date    |
+---------------+---------+
There is no primary key for this table, it may have duplicate rows.
Each row of this table indicates that some viewer viewed an article (written by some author) on some date.
Note that equal author_id and viewer_id indicate the same person.

     

    Write an SQL query to find all the authors that viewed at least one of their own articles,
        sorted in ascending order by their id.

    The query result format is in the following example:

    Views table:
+------------+-----------+-----------+------------+
| article_id | author_id | viewer_id | view_date  |
+------------+-----------+-----------+------------+
| 1          | 3         | 5         | 2019-08-01 |
| 1          | 3         | 6         | 2019-08-02 |
| 2          | 7         | 7         | 2019-08-01 |
| 2          | 7         | 6         | 2019-08-02 |
| 4          | 7         | 1         | 2019-07-22 |
| 3          | 4         | 4         | 2019-07-21 |
| 3          | 4         | 4         | 2019-07-21 |
+------------+-----------+-----------+------------+

Result table:
+------+
| id   |
+------+
| 4    |
| 7    |
+------+
-----------------

# 1313_Decompress_Run-Length_Encoded_List
# 1313. Decompress Run-Length Encoded List


-----------------

# 1054_Distant_Barcodes
# 1054. Distant Barcodes

In a warehouse, there is a row of barcodes, where the i-th barcode
        is barcodes[i].

    Rearrange the barcodes so that no two adjacent barcodes are equal.  You may return any
        answer, and it is guaranteed an answer exists.

     

    Example 1:

    Input: [1,1,1,2,2,2]
Output: [2,1,2,1,2,1]
-----------------

# 911_Online_Election
# 911. Online Election

In an election, the i-th vote was cast for persons[i] at time
        times[i].

    Now, we would like to implement the following query function: TopVotedCandidate.q(int
        t) will return the number of the person that was leading the election at time
        t.  

    Votes cast at time t will count towards our query.  In the case of a tie,
        the most recent vote (among tied candidates) wins.
-----------------

# 133_Clone_Graph
# 133. Clone Graph

Given a reference of a node in a connected undirected graph, return a deep
        copy (clone) of the graph. Each node in the graph contains a val
        (int) and a list (List[Node]) of its neighbors.

     

    Example:

    

    Input:
{"$id":"1","neighbors":[{"$id":"2","neighbors":[{"$ref":"1"},{"$id":"3","neighbors":[{"$ref":"2"},{"$id":"4","neighbors":[{"$ref":"3"},{"$ref":"1"}],"val":4}],"val":3}],"val":2},{"$ref":"4"}],"val":1}

Explanation:
Node 1's value is 1, and it has two neighbors: Node 2 and 4.
Node 2's value is 2, and it has two neighbors: Node 1 and 3.
Node 3's value is 3, and it has two neighbors: Node 2 and 4.
Node 4's value is 4, and it has two neighbors: Node 1 and 3.

     

    Note:

    
        The number of nodes will be between 1 and 100.
        The undirected graph is a simple graph, which means no repeated edges and no
            self-loops in the graph.
        
        Since the graph is undirected, if node p has node q as neighbor,
            then node q must have node p as neighbor too.
        
        You must return the copy of the given node as a reference to the cloned
            graph.
-----------------

# 833_Find_And_Replace_in_String
# 833. Find And Replace in String

To some string S, we will perform some replacement operations that
        replace groups of letters with new ones (not necessarily the same size).

    Each replacement operation has 3 parameters: a starting index i, a
        source word x and a target word y.  The rule
        is that if x starts at position
        i in the original string
        S, then we will replace that occurrence of x with y. 
        If not, we do nothing.

    For example, if we have S = "abcd" and we have some
        replacement operation i = 2, x = "cd", y = "ffff",
        then because "cd" starts at position 2 in the original string S, we will
        replace it with "ffff".

    Using another example on S = "abcd", if we have both the replacement
        operation i = 0, x = "ab", y = "eee", as well as another
        replacement operation i = 2, x = "ec", y = "ffff",
        this second operation does nothing because in the original string S[2] = 'c',
        which doesn't match x[0] = 'e'.

    All these operations occur simultaneously.  It's guaranteed that there won't be
        any overlap in replacement: for example, S = "abc", indexes = [0, 1], sources
            = ["ab","bc"] is not a valid test case.

    Example 1:

    Input: S = "abcd", indexes = [0,2], sources = ["a","cd"], targets = ["eee","ffff"]
Output: "eeebffff"
Explanation: "a" starts at index 0 in S, so it's replaced by "eee".
"cd" starts at index 2 in S, so it's replaced by "ffff".

    Example 2:

    Input: S = "abcd", indexes = [0,2], sources = ["ab","ec"], targets = ["eee","ffff"]
Output: "eeecd"
Explanation: "ab" starts at index 0 in S, so it's replaced by "eee".
"ec" doesn't starts at index 2 in the original S, so we do nothing.

    Notes:

    
        0 <= indexes.length = sources.length = targets.length <=
            100
        0 < indexes[i] < S.length <= 1000
        All characters in given inputs are lowercase letters.
-----------------

# 377_Combination_Sum_IV
# 377. Combination Sum IV

Given an integer array with all positive numbers and no duplicates, find the number of
        possible combinations that add up to a positive integer target.

    Example:

    nums = [1, 2, 3]
target = 4

The possible combination ways are:
(1, 1, 1, 1)
(1, 1, 2)
(1, 2, 1)
(1, 3)
(2, 1, 1)
(2, 2)
(3, 1)

Note that different sequences are counted as different combinations.

Therefore the output is 7.

     

    Follow up:
        What if negative numbers are allowed in the given array?
        How does it change the problem?
        What limitation we need to add to the question to allow negative numbers?

    Credits:
        Special thanks to @pbrother for adding this
        problem and creating all test cases.
-----------------

# 729_My_Calendar_I
# 729. My Calendar I

Implement a MyCalendar class to store your events. A new event can be added if
        adding the event will not cause a double booking.

    Your class will have the method, book(int start, int end). Formally, this
        represents a booking on the half open interval [start, end), the range of real
        numbers x such that start <= x < end.

    A double booking happens when two events have some non-empty intersection (ie., there
        is some time that is common to both events.)

    For each call to the method MyCalendar.book, return true if the
        event can be added to the calendar successfully without causing a double booking. Otherwise,
        return false and do not add the event to the calendar.
    Your class will be called like this: MyCalendar cal = new MyCalendar(); MyCalendar.book(start,
    end)

    Example 1:

    MyCalendar();
MyCalendar.book(10, 20); // returns true
MyCalendar.book(15, 25); // returns false
MyCalendar.book(20, 30); // returns true
Explanation:
The first event can be booked.  The second can't because time 15 is already booked by another event.
The third event can be booked, as the first event takes every time less than 20, but not including 20.

     

    Note:

    
        The number of calls to MyCalendar.book per test case will be at most 1000.
        
        In calls to MyCalendar.book(start, end), start and
            end are integers in the range [0, 10^9].
-----------------

# 315_Count_of_Smaller_Numbers_After_Self
# 315. Count of Smaller Numbers After Self

You are given an integer array nums and you have to return a new counts array.
        The counts array has the property where counts[i] is the number of
        smaller elements to the right of nums[i].

    Example:

    Input: [5,2,6,1]
Output: [2,1,1,0]
Explanation:
To the right of 5 there are 2 smaller elements (2 and 1).
To the right of 2 there is only 1 smaller element (1).
To the right of 6 there is 1 smaller element (1).
To the right of 1 there is 0 smaller element.
-----------------

# 1164_Product_Price_at_a_Given_Date
# 1164. Product Price at a Given Date

Table: Products

    +---------------+---------+
| Column Name   | Type    |
+---------------+---------+
| product_id    | int     |
| new_price     | int     |
| change_date   | date    |
+---------------+---------+
(product_id, change_date) is the primary key of this table.
Each row of this table indicates that the price of some product was changed to a new price at some date.

     

    Write an SQL query to find the prices of all products on 2019-08-16. Assume
        the price of all products before any change is 10.

    The query result format is in the following example:

    Products table:
+------------+-----------+-------------+
| product_id | new_price | change_date |
+------------+-----------+-------------+
| 1          | 20        | 2019-08-14  |
| 2          | 50        | 2019-08-14  |
| 1          | 30        | 2019-08-15  |
| 1          | 35        | 2019-08-16  |
| 2          | 65        | 2019-08-17  |
| 3          | 20        | 2019-08-18  |
+------------+-----------+-------------+

Result table:
+------------+-------+
| product_id | price |
+------------+-------+
| 2          | 50    |
| 1          | 35    |
| 3          | 10    |
+------------+-------+
-----------------

# 263_Ugly_Number
# 263. Ugly Number

Write a program to check whether a given number is an ugly number.

    Ugly numbers are positive numbers whose prime factors only include 2,
        3, 5.

    Example 1:

    Input: 6
Output: true
Explanation: 6 = 2 × 3

    Example 2:

    Input: 8
Output: true
Explanation: 8 = 2 × 2 × 2

    Example 3:

    Input: 14
Output: false
Explanation: 14 is not ugly since it includes another prime factor 7.

    Note:

    
        1 is typically treated as an ugly number.
        Input is within the 32-bit signed integer range: [−231, 
            231 − 1].
-----------------

# 1133_Largest_Unique_Number
# 1133. Largest Unique Number

Given an array of integers A, return the largest integer that only occurs once.
    

    If no integer occurs once, return -1.

     

    Example 1:

    Input: [5,7,3,9,4,9,8,3,1]
Output: 8
Explanation: 
The maximum integer in the array is 9 but it is repeated. The number 8 occurs only once, so it's the answer.

    Example 2:

    Input: [9,9,8,8]
Output: -1
Explanation: 
There is no number that occurs only once.

     

    Note:

    
        1 <= A.length <= 2000
        0 <= A[i] <= 1000
-----------------

# 1473_Paint_House_III
# 1473. Paint House III


-----------------

# 91_Decode_Ways
# 91. Decode Ways

A message containing letters from A-Z is being encoded to numbers using the
        following mapping:

    'A' -> 1
'B' -> 2
...
'Z' -> 26

    Given a non-empty string containing only digits, determine the total number
        of ways to decode it.

    Example 1:

    Input: "12"
Output: 2
Explanation: It could be decoded as "AB" (1 2) or "L" (12).

    Example 2:

    Input: "226"
Output: 3
Explanation: It could be decoded as "BZ" (2 26), "VF" (22 6), or "BBF" (2 2 6).
-----------------

# 384_Shuffle_an_Array
# 384. Shuffle an Array

Shuffle a set of numbers without duplicates.
    

    Example:
    // Init an array with set 1, 2, and 3.
int[] nums = {1,2,3};
Solution solution = new Solution(nums);

// Shuffle the array [1,2,3] and return its result. Any permutation of [1,2,3] must equally likely to be returned.
solution.shuffle();

// Resets the array back to its original configuration [1,2,3].
solution.reset();

// Returns the random shuffling of array [1,2,3].
solution.shuffle();
-----------------

# 503_Next_Greater_Element_II
# 503. Next Greater Element II

Given a circular array (the next element of the last element is the first element of the
        array), print the Next Greater Number for every element. The Next Greater Number of a number
        x is the first greater number to its traversing-order next in the array, which means you
        could search circularly to find its next greater number. If it doesn't exist, output -1 for
        this number.
    

    Example 1:
    Input: [1,2,1]
Output: [2,-1,2]
Explanation: The first 1's next greater number is 2; The number 2 can't find next greater number; 
        The second 1's next greater number needs to search circularly, which is also 2.

    

    Note:
        The length of given array won't exceed 10000.
-----------------

# 437_Path_Sum_III
# 437. Path Sum III

You are given a binary tree in which each node contains an integer value.

    Find the number of paths that sum to a given value.

    The path does not need to start or end at the root or a leaf, but it must go downwards
        (traveling only from parent nodes to child nodes).

    The tree has no more than 1,000 nodes and the values are in the range -1,000,000 to
        1,000,000.

    Example:
    root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8

      10
     /  \
    5   -3
   / \    \
  3   2   11
 / \   \
3  -2   1

Return 3. The paths that sum to 8 are:

1.  5 -> 3
2.  5 -> 2 -> 1
3. -3 -> 11
-----------------

# 773_Sliding_Puzzle
# 773. Sliding Puzzle

On a 2x3 board, there are 5 tiles represented by the integers 1 through 5, and
        an empty square represented by 0.

    A move consists of choosing 0 and a 4-directionally adjacent number and
        swapping it.

    The state of the board is solved if and only if the board is [[1,2,3],[4,5,0]].
    

    Given a puzzle board, return the least number of moves required so that the state of the
        board is solved. If it is impossible for the state of the board to be solved, return -1.

    Examples:

    Input: board = [[1,2,3],[4,0,5]]
Output: 1
Explanation: Swap the 0 and the 5 in one move.

    Input: board = [[1,2,3],[5,4,0]]
Output: -1
Explanation: No number of moves will make the board solved.

    Input: board = [[4,1,2],[5,0,3]]
Output: 5
Explanation: 5 is the smallest number of moves that solves the board.
An example path:
After move 0: [[4,1,2],[5,0,3]]
After move 1: [[4,1,2],[0,5,3]]
After move 2: [[0,1,2],[4,5,3]]
After move 3: [[1,0,2],[4,5,3]]
After move 4: [[1,2,0],[4,5,3]]
After move 5: [[1,2,3],[4,5,0]]

    Input: board = [[3,2,4],[1,5,0]]
Output: 14

    Note:

    
        board will be a 2 x 3 array as described above.
        board[i][j] will be a permutation of [0, 1, 2, 3, 4, 5].
-----------------

# 672_Bulb_Switcher_II
# 672. Bulb Switcher II

There is a room with n lights which are turned on initially and 4 buttons on the
        wall. After performing exactly m unknown operations towards buttons, you need
        to return how many different kinds of status of the n lights could be.

    Suppose n lights are labeled as number [1, 2, 3 ..., n], function of these 4
        buttons are given below:

    
        Flip all the lights.
        Flip lights with even numbers.
        Flip lights with odd numbers.
        Flip lights with (3k + 1) numbers, k = 0, 1, 2, ...
    

     

    Example 1:

    Input: n = 1, m = 1.
Output: 2
Explanation: Status can be: [on], [off]

     

    Example 2:

    Input: n = 2, m = 1.
Output: 3
Explanation: Status can be: [on, off], [off, on], [off, off]

     

    Example 3:

    Input: n = 3, m = 1.
Output: 4
Explanation: Status can be: [off, on, off], [on, off, on], [off, off, off], [off, on, on].

     

    Note: n and m both fit in range [0, 1000].
-----------------

# 1370_Increasing_Decreasing_String
# 1370. Increasing Decreasing String


-----------------

# 520_Detect_Capital
# 520. Detect Capital

Given a word, you need to judge whether the usage of capitals in it is right or not.

    We define the usage of capitals in a word to be right when one of the following cases
        holds:

    
        All letters in this word are capitals, like "USA".
        All letters in this word are not capitals, like "leetcode".
        Only the first letter in this word is capital, like "Google".
    
    Otherwise, we define that this word doesn't use capitals in a right way.

     

    Example 1:

    Input: "USA"
Output: True

     

    Example 2:

    Input: "FlaG"
Output: False

     

    Note: The input will be a non-empty word consisting of uppercase and lowercase latin
        letters.
-----------------

# 977_Squares_of_a_Sorted_Array
# 977. Squares of a Sorted Array

Given an array of integers A sorted in non-decreasing order, return an
        array of the squares of each number, also in sorted non-decreasing order.
-----------------

# 963_Minimum_Area_Rectangle_II
# 963. Minimum Area Rectangle II

Given a set of points in the xy-plane, determine the minimum area of any
        rectangle formed from these points, with sides not necessarily parallel to
        the x and y axes.

    If there isn't any rectangle, return 0.

     

    Example 1:

    

    Input: [[1,2],[2,1],[1,0],[0,1]]
Output: 2.00000
Explanation: The minimum area rectangle occurs at [1,2],[2,1],[1,0],[0,1], with an area of 2.
-----------------

# 1663_Smallest_String_With_A_Given_Numeric_Value
# 1663. Smallest String With A Given Numeric Value


-----------------

# 116_Populating_Next_Right_Pointers_in_Each_Node
# 116. Populating Next Right Pointers in Each Node

You are given a perfect binary tree where all leaves are on the
        same level, and every parent has two children. The binary tree has the following definition:
    

    struct Node {
  int val;
  Node *left;
  Node *right;
  Node *next;
}

    Populate each next pointer to point to its next right node. If there is no next right node,
        the next pointer should be set to NULL.

    Initially, all next pointers are set to NULL.

     

    Example:

    

    Input: {"$id":"1","left":{"$id":"2","left":{"$id":"3","left":null,"next":null,"right":null,"val":4},"next":null,"right":{"$id":"4","left":null,"next":null,"right":null,"val":5},"val":2},"next":null,"right":{"$id":"5","left":{"$id":"6","left":null,"next":null,"right":null,"val":6},"next":null,"right":{"$id":"7","left":null,"next":null,"right":null,"val":7},"val":3},"val":1}

Output: {"$id":"1","left":{"$id":"2","left":{"$id":"3","left":null,"next":{"$id":"4","left":null,"next":{"$id":"5","left":null,"next":{"$id":"6","left":null,"next":null,"right":null,"val":7},"right":null,"val":6},"right":null,"val":5},"right":null,"val":4},"next":{"$id":"7","left":{"$ref":"5"},"next":null,"right":{"$ref":"6"},"val":3},"right":{"$ref":"4"},"val":2},"next":null,"right":{"$ref":"7"},"val":1}

Explanation: Given the above perfect binary tree (Figure A), your function should populate each next pointer to point to its next right node, just like in Figure B.

     

    Note:

    
        You may only use constant extra space.
        Recursive approach is fine, implicit stack space does not count as extra space for this
            problem.
-----------------

# 1439_Find_the_Kth_Smallest_Sum_of_a_Matrix_With_Sorted_Rows
# 1439. Find the Kth Smallest Sum of a Matrix With Sorted Rows


-----------------

# 497_Random_Point_in_Non-overlapping_Rectangles
# 497. Random Point in Non-overlapping Rectangles

Given a list of non-overlapping axis-aligned rectangles
        rects, write a function pick which randomly and uniformily picks
        an integer point in the space covered by the rectangles.

    Note:

    
        An integer point is a point that has integer coordinates. 
        
        A point on the perimeter of a rectangle is included in
            the space covered by the rectangles. 
        
        ith rectangle = rects[i] = [x1,y1,x2,y2],
            where [x1, y1] are the integer coordinates of the bottom-left corner,
            and [x2, y2] are the integer coordinates of the top-right corner.
        
        length and width of each rectangle does not exceed 2000.
        1 <= rects.length <= 100
        pick return a point as an array of integer coordinates [p_x,
            p_y]
        pick is called at most 10000 times.
-----------------

# 611_Valid_Triangle_Number
# 611. Valid Triangle Number

Given an array consists of non-negative integers, your task is to count the number of triplets
    chosen from the array that can make triangles if we take them as side lengths of a triangle.

    Example 1:
    Input: [2,2,3,4]
Output: 3
Explanation:
Valid combinations are:
2,3,4 (using the first 2)
2,3,4 (using the second 2)
2,2,3

    

    Note:
    
        The length of the given array won't exceed 1000.
        The integers in the given array are in the range of [0, 1000].
-----------------

# 220_Contains_Duplicate_III
# 220. Contains Duplicate III

Given an array of integers, find out whether there are two distinct indices i and
        j in the array such that the absolute difference between nums[i] and
        nums[j] is at most t and the absolute difference between i and
        j is at most k.
-----------------

# 1668_Maximum_Repeating_Substring
# 1668. Maximum Repeating Substring


-----------------

# 1346_Check_If_N_and_Its_Double_Exist
# 1346. Check If N and Its Double Exist


-----------------

# 1453_Maximum_Number_of_Darts_Inside_of_a_Circular_Dartboard
# 1453. Maximum Number of Darts Inside of a Circular Dartboard


-----------------

# 1801_Number_of_Orders_in_the_Backlog
# 1801. Number of Orders in the Backlog


-----------------

# 73_Set_Matrix_Zeroes
# 73. Set Matrix Zeroes

Given a m x n matrix, if an element is 0, set its entire row and column to
        0. Do it in-place.
    

    Example 1:

    Input:
[
  [1,1,1],
  [1,0,1],
  [1,1,1]
]
Output:
[
  [1,0,1],
  [0,0,0],
  [1,0,1]
]

    Example 2:

    Input:
[
  [0,1,2,0],
  [3,4,5,2],
  [1,3,1,5]
]
Output:
[
  [0,0,0,0],
  [0,4,5,0],
  [0,3,1,0]
]

    Follow up:

    
        A straight forward solution using O(mn) space is probably a bad idea.
        
        A simple improvement uses O(m + n) space, but still not the best
            solution.
        
        Could you devise a constant space solution?
-----------------

# 1701_Average_Waiting_Time
# 1701. Average Waiting Time


-----------------

# 1723_Find_Minimum_Time_to_Finish_All_Jobs
# 1723. Find Minimum Time to Finish All Jobs


-----------------

# 480_Sliding_Window_Median
# 480. Sliding Window Median

Median is the middle value in an ordered integer list. If the size of the list is even, there
        is no middle value. So the median is the mean of the two middle value.
    Examples: 
    [2,3,4] , the median is 3
    [2,3], the median is (2 + 3) / 2 = 2.5

    Given an array nums, there is a sliding window of size k which is moving from
        the very left of the array to the very right. You can only see the k numbers in the
        window. Each time the sliding window moves right by one position. Your job is to output the
        median array for each window in the original array.

    For example,
        Given nums = [1,3,-1,-3,5,3,6,7], and k = 3.

    Window position                Median
---------------               -----
[1  3  -1] -3  5  3  6  7       1
 1 [3  -1  -3] 5  3  6  7       -1
 1  3 [-1  -3  5] 3  6  7       -1
 1  3  -1 [-3  5  3] 6  7       3
 1  3  -1  -3 [5  3  6] 7       5
 1  3  -1  -3  5 [3  6  7]      6

    Therefore, return the median sliding window as [1,-1,-1,3,5,6].

    Note: 
        You may assume k is always valid, ie: k is always smaller than
        input array's size for non-empty array.
-----------------

# 1502_Can_Make_Arithmetic_Progression_From_Sequence
# 1502. Can Make Arithmetic Progression From Sequence


-----------------

# 68_Text_Justification
# 68. Text Justification

Given an array of words and a width maxWidth, format the text such that each
        line has exactly maxWidth characters and is fully (left and right) justified.

    You should pack your words in a greedy approach; that is, pack as many words as you can in
        each line. Pad extra spaces ' ' when necessary so that each line has
        exactly maxWidth characters.

    Extra spaces between words should be distributed as evenly as possible. If the number of
        spaces on a line do not divide evenly between words, the empty slots on the left will be
        assigned more spaces than the slots on the right.

    For the last line of text, it should be left justified and no extra space is
        inserted between words.

    Note:

    
        A word is defined as a character sequence consisting of non-space characters
            only.
        
        Each word's length is guaranteed to be greater than 0 and not exceed maxWidth.
        
        The input array words contains at least one word.
    

    Example 1:

    Input:
words = ["This", "is", "an", "example", "of", "text", "justification."]
maxWidth = 16
Output:
[
   "This    is    an",
   "example  of text",
   "justification.  "
]

    Example 2:

    Input:
words = ["What","must","be","acknowledgment","shall","be"]
maxWidth = 16
Output:
[
  "What   must   be",
  "acknowledgment  ",
  "shall be        "
]
Explanation: Note that the last line is "shall be    " instead of "shall     be",
             because the last line must be left-justified instead of fully-justified.
             Note that the second line is also left-justified becase it contains only one word.

    Example 3:

    Input:
words = ["Science","is","what","we","understand","well","enough","to","explain",
         "to","a","computer.","Art","is","everything","else","we","do"]
maxWidth = 20
Output:
[
  "Science  is  what we",
  "understand      well",
  "enough to explain to",
  "a  computer.  Art is",
  "everything  else  we",
  "do                  "
]
-----------------

# 636_Exclusive_Time_of_Functions
# 636. Exclusive Time of Functions

On a single threaded CPU, we execute some functions.  Each function has
        a unique id between 0 and N-1.

    We store logs in timestamp order that describe when a function is entered or exited.

    Each log is a string with this format: "{function_id}:{"start" | "end"}:{timestamp}". 
        For example, "0:start:3" means the function with id
        0 started at the beginning of timestamp 3. 
        "1:end:2" means the function with id 1 ended at
            the end of timestamp 2.

    A function's exclusive time is the number of units of time spent in this
        function.  Note that this does not include any recursive calls to
        child functions.

    The CPU is single threaded which means that only one function is being
        executed at a given time unit.

    Return the exclusive time of each function, sorted by their function id.

     

    Example 1:

    

    Input:
n = 2
logs = ["0:start:0","1:start:2","1:end:5","0:end:6"]
Output: [3, 4]
Explanation:
Function 0 starts at the beginning of time 0, then it executes 2 units of time and reaches the end of time 1.
Now function 1 starts at the beginning of time 2, executes 4 units of time and ends at time 5.
Function 0 is running again at the beginning of time 6, and also ends at the end of time 6, thus executing for 1 unit of time.
So function 0 spends 2 + 1 = 3 units of total time executing, and function 1 spends 4 units of total time executing.

     

    Note:

    
        1 <= n <= 100
        Two functions won't start or end at the same time.
        Functions will always log when they exit.
-----------------

# 573_Squirrel_Simulation
# 573. Squirrel Simulation

There's a tree, a squirrel, and several nuts. Positions are represented by the cells in a 2D
    grid. Your goal is to find the minimal distance for the squirrel to collect all the nuts
    and put them under the tree one by one. The squirrel can only take at most one nut at one
    time and can move in four directions - up, down, left and right, to the adjacent cell. The
    distance is represented by the number of moves.
    Example 1:

    Input:
Height : 5
Width : 7
Tree position : [2,2]
Squirrel : [4,4]
Nuts : [[3,0], [2,5]]
Output: 12
Explanation:
​​​​​

    Note:

    
        All given positions won't overlap.
        The squirrel can take at most one nut at one time.
        The given positions of nuts have no order.
        Height and width are positive integers. 3 <= height * width <= 10,000.
        The given positions contain at least one nut, only one tree and one squirrel.
-----------------

# 536_Construct_Binary_Tree_from_String
# 536. Construct Binary Tree from String

You need to construct a binary tree from a string consisting of parenthesis and
        integers. 

    The whole input represents a binary tree. It contains an integer followed by zero, one or two
        pairs of parenthesis. The integer represents the root's value and a pair of parenthesis
        contains a child binary tree with the same structure. 

    You always start to construct the left child node of the parent first if it exists.
    

    Example:
    Input: "4(2(3)(1))(6(5))"
Output: return the tree root node representing the following tree:

       4
     /   \
    2     6
   / \   /
  3   1 5

    

    Note:
    
        There will only be '(', ')', '-' and
            '0' ~ '9' in the input string.
        
        An empty tree is represented by "" instead of "()".
-----------------

# 1615_Maximal_Network_Rank
# 1615. Maximal Network Rank


-----------------

# 865_Smallest_Subtree_with_all_the_Deepest_Nodes
# 865. Smallest Subtree with all the Deepest Nodes

Given a binary tree rooted at root, the depth of each node is the
        shortest distance to the root.

    A node is deepest if it has the largest depth possible among any node in the
        entire tree.

    The subtree of a node is that node, plus the set of all descendants of that node.

    Return the node with the largest depth such that it contains all the deepest nodes in its
        subtree.

     

    Example 1:

    Input: [3,5,1,6,2,0,8,null,null,7,4]
Output: [2,7,4]
Explanation:

We return the node with value 2, colored in yellow in the diagram.
The nodes colored in blue are the deepest nodes of the tree.
The input "[3, 5, 1, 6, 2, 0, 8, null, null, 7, 4]" is a serialization of the given tree.
The output "[2, 7, 4]" is a serialization of the subtree rooted at the node with value 2.
Both the input and output have TreeNode type.

     

    Note:

    
        The number of nodes in the tree will be between 1 and 500.
        The values of each node are unique.
-----------------

# 1712_Ways_to_Split_Array_Into_Three_Subarrays
# 1712. Ways to Split Array Into Three Subarrays


-----------------

# 477_Total_Hamming_Distance
# 477. Total Hamming Distance

The Hamming
        distance between two integers is the number of positions at which the corresponding bits
        are different.

    Now your job is to find the total Hamming distance between all pairs of the given numbers.

    Example:
    Input: 4, 14, 2

Output: 6

Explanation: In binary representation, the 4 is 0100, 14 is 1110, and 2 is 0010 (just
showing the four bits relevant in this case). So the answer will be:
HammingDistance(4, 14) + HammingDistance(4, 2) + HammingDistance(14, 2) = 2 + 2 + 2 = 6.

    

    Note:
    
        Elements of the given array are in the range of 0  to 10^9
        Length of the array will not exceed 10^4.
-----------------

# 1559_Detect_Cycles_in_2D_Grid
# 1559. Detect Cycles in 2D Grid


-----------------

# 812_Largest_Triangle_Area
# 812. Largest Triangle Area

You have a list of points in the plane. Return the area of the largest triangle that can be
        formed by any 3 of the points.

    Example:
Input: points = [[0,0],[0,1],[1,0],[0,2],[2,0]]
Output: 2
Explanation:
The five points are show in the figure below. The red triangle is the largest.

    

    Notes: 

    
        3 <= points.length <= 50.
        No points will be duplicated.
         -50 <= points[i][j] <= 50.
        Answers within 10^-6 of the true value will be accepted as
            correct.
-----------------

# 207_Course_Schedule
# 207. Course Schedule

There are a total of n courses you have to take, labeled from 0 to n-1.
    

    Some courses may have prerequisites, for example to take course 0 you have to first take
        course 1, which is expressed as a pair: [0,1]

    Given the total number of courses and a list of prerequisite pairs, is it possible for
        you to finish all courses?

    Example 1:

    Input: 2, [[1,0]]
Output: true
Explanation: There are a total of 2 courses to take.
             To take course 1 you should have finished course 0. So it is possible.

    Example 2:

    Input: 2, [[1,0],[0,1]]
Output: false
Explanation: There are a total of 2 courses to take.
             To take course 1 you should have finished course 0, and to take course 0 you should
             also have finished course 1. So it is impossible.

    Note:

    
        The input prerequisites is a graph represented by a list of edges, not adjacency
            matrices. Read more about how a graph is represented.
        
        You may assume that there are no duplicate edges in the input prerequisites.
-----------------

# 1459_Rectangles_Area
# 1459. Rectangles Area


-----------------

# 50_Pow(x,_n)
# 50. Pow(x, n)

Implement pow(x,
        n), which calculates x raised to the power n
        (xn).

    Example 1:

    Input: 2.00000, 10
Output: 1024.00000

    Example 2:

    Input: 2.10000, 3
Output: 9.26100

    Example 3:

    Input: 2.00000, -2
Output: 0.25000
Explanation: 2-2 = 1/22 = 1/4 = 0.25

    Note:

    
        -100.0 < x < 100.0
        n is a 32-bit signed integer, within the range [−231, 231 −
            1]
-----------------

# 950_Reveal_Cards_In_Increasing_Order
# 950. Reveal Cards In Increasing Order

In a deck of cards, every card has a unique integer.  You can order the deck in any
        order you want.

    Initially, all the cards start face down (unrevealed) in one deck.

    Now, you do the following steps repeatedly, until all cards are revealed:

    
        Take the top card of the deck, reveal it, and take it out of the deck.
        If there are still cards in the deck, put the next top card of the deck at the
            bottom of the deck.
        
        If there are still unrevealed cards, go back to step 1.  Otherwise, stop.
    

    Return an ordering of the deck that would reveal the cards in increasing
        order.

    The first entry in the answer is considered to be the top of the deck.
-----------------

# 1420_Build_Array_Where_You_Can_Find_The_Maximum_Exactly_K_Comparisons
# 1420. Build Array Where You Can Find The Maximum Exactly K Comparisons


-----------------

# 624_Maximum_Distance_in_Arrays
# 624. Maximum Distance in Arrays

Given m arrays, and each array is sorted in ascending order. Now you can pick
        up two integers from two different arrays (each array picks one) and calculate the distance.
        We define the distance between two integers a and b to be their
        absolute difference |a-b|. Your task is to find the maximum distance.
    

    Example 1:
    Input:
[[1,2,3],
 [4,5],
 [1,2,3]]
Output: 4
Explanation:
One way to reach the maximum distance 4 is to pick 1 in the first or third array and pick 5 in the second array.

    

    Note:
    
        Each given array will have at least 1 number. There will be at least two non-empty
            arrays.
        
        The total number of the integers in all the m arrays will be in the
            range of [2, 10000].
        
        The integers in the m arrays will be in the range of [-10000, 10000].
-----------------

# 1709_Biggest_Window_Between_Visits
# 1709. Biggest Window Between Visits


-----------------

# 1600_Throne_Inheritance
# 1600. Throne Inheritance


-----------------

# 1490_Clone_N-ary_Tree
# 1490. Clone N-ary Tree


-----------------

# 1530_Number_of_Good_Leaf_Nodes_Pairs
# 1530. Number of Good Leaf Nodes Pairs


-----------------

# 113_Path_Sum_II
# 113. Path Sum II

Given a binary tree and a sum, find all root-to-leaf paths where each path's sum equals
        the given sum.

    Note: A leaf is a node with no children.

    Example:

    Given the below binary tree and sum = 22,

          5
     / \
    4   8
   /   / \
  11  13  4
 /  \    / \
7    2  5   1

    Return:

    [
   [5,4,11,2],
   [5,8,4,5]
]
-----------------

# 782_Transform_to_Chessboard
# 782. Transform to Chessboard

An N x N board contains only 0s and 1s. In each move,
        you can swap any 2 rows with each other, or any 2 columns with each other.

    What is the minimum number of moves to transform the board into a "chessboard" - a
        board where no 0s and no 1s are 4-directionally adjacent? If the
        task is impossible, return -1.

    Examples:
Input: board = [[0,1,1,0],[0,1,1,0],[1,0,0,1],[1,0,0,1]]
Output: 2
Explanation:
One potential sequence of moves is shown below, from left to right:

0110     1010     1010
0110 --> 1010 --> 0101
1001     0101     1010
1001     0101     0101

The first move swaps the first and second column.
The second move swaps the second and third row.

Input: board = [[0, 1], [1, 0]]
Output: 0
Explanation:
Also note that the board with 0 in the top left corner,
01
10

is also a valid chessboard.

Input: board = [[1, 0], [1, 0]]
Output: -1
Explanation:
No matter what sequence of moves you make, you cannot end with a valid chessboard.

    Note:

    
        board will have the same number of rows and columns, a number in the range
            [2, 30].
        
        board[i][j] will be only 0s or 1s.
-----------------

# 1843_Suspicious_Bank_Accounts
# 1843. Suspicious Bank Accounts


-----------------

# 365_Water_and_Jug_Problem
# 365. Water and Jug Problem

You are given two jugs with capacities x and y litres. There is an infinite
        amount of water supply available. You need to determine whether it is possible to measure
        exactly z litres using these two jugs.

    If z liters of water is measurable, you must have z liters of water contained
        within one or both buckets by the end.

    Operations allowed:

    
        Fill any of the jugs completely with water.
        Empty any of the jugs.
        Pour water from one jug into another till the other jug is completely full or the first
            jug itself is empty.
        
    

    Example 1: (From the famous "Die Hard" example)
    

    Input: x = 3, y = 5, z = 4
Output: True

    Example 2:

    Input: x = 2, y = 6, z = 5
Output: False
-----------------

# 1489_Find_Critical_and_Pseudo-Critical_Edges_in_Minimum_Spanning_Tree
# 1489. Find Critical and Pseudo-Critical Edges in Minimum Spanning Tree


-----------------

# 301_Remove_Invalid_Parentheses
# 301. Remove Invalid Parentheses

Remove the minimum number of invalid parentheses in order to make the input string valid.
        Return all possible results.

    Note: The input string may contain letters other than the parentheses
        ( and ).

    Example 1:

    Input: "()())()"
Output: ["()()()", "(())()"]

    Example 2:

    Input: "(a)())()"
Output: ["(a)()()", "(a())()"]

    Example 3:

    Input: ")("
Output: [""]
-----------------

# 1180_Count_Substrings_with_Only_One_Distinct_Letter
# 1180. Count Substrings with Only One Distinct Letter

Given a string S, return the number of substrings that have only
        one distinct letter.

     
    Example 1:

    Input: S = "aaaba"
Output: 8
Explanation: The substrings with one distinct letter are "aaa", "aa", "a", "b".
"aaa" occurs 1 time.
"aa" occurs 2 times.
"a" occurs 4 times.
"b" occurs 1 time.
So the answer is 1 + 2 + 4 + 1 = 8.

    Example 2:

    Input: S = "aaaaaaaaaa"
Output: 55

     
    Constraints:

    
        1 <= S.length <= 1000
        S[i] consists of only lowercase English letters.
-----------------

# 1632_Rank_Transform_of_a_Matrix
# 1632. Rank Transform of a Matrix


-----------------

# 753_Cracking_the_Safe
# 753. Cracking the Safe

There is a box protected by a password. The password is a sequence of n
        digits where each digit can be one of the first k digits 0, 1, ...,
            k-1.

    While entering a password, the last n digits entered will automatically be
        matched against the correct password.

    For example, assuming the correct password is "345", if you type
        "012345", the box will open because the correct password matches the
        suffix of the entered password.

    Return any password of minimum length that is guaranteed to open the box at
        some point of entering it.

     

    Example 1:

    Input: n = 1, k = 2
Output: "01"
Note: "10" will be accepted too.

    Example 2:

    Input: n = 2, k = 2
Output: "00110"
Note: "01100", "10011", "11001" will be accepted too.

     

    Note:

    
        n will be in the range [1, 4].
        k will be in the range [1, 10].
        k^n will be at most 4096.
-----------------

# 1277_Count_Square_Submatrices_with_All_Ones
# 1277. Count Square Submatrices with All Ones


-----------------

# 1572_Matrix_Diagonal_Sum
# 1572. Matrix Diagonal Sum


-----------------

# 468_Validate_IP_Address
# 468. Validate IP Address

Write a function to check whether an input string is a valid IPv4 address or IPv6 address or
        neither.
    

    
        IPv4 addresses are canonically represented in dot-decimal notation, which consists of
        four decimal numbers, each ranging from 0 to 255, separated by dots ("."), e.g.,172.16.254.1;
    

    
        Besides, leading zeros in the IPv4 is invalid. For example, the address
        172.16.254.01 is invalid.
    

    
        IPv6 addresses are represented as eight groups of four hexadecimal digits, each group
        representing 16 bits. The groups are separated by colons (":"). For example, the address
        2001:0db8:85a3:0000:0000:8a2e:0370:7334 is a valid one. Also, we could omit
        some leading zeros among four hexadecimal digits and some low-case characters in the address
        to upper-case ones, so 2001:db8:85a3:0:0:8A2E:0370:7334 is also a valid IPv6
        address(Omit leading zeros and using upper cases).
    

    
        However, we don't replace a consecutive group of zero value with a single empty group using
        two consecutive colons (::) to pursue simplicity. For example, 2001:0db8:85a3::8A2E:0370:7334
        is an invalid IPv6 address.
    

    
        Besides, extra leading zeros in the IPv6 is also invalid. For example, the address 02001:0db8:85a3:0000:0000:8a2e:0370:7334
        is invalid.
    

    Note:
        You may assume there is no extra space or special characters in the input string.
    

    Example 1:
    Input: "172.16.254.1"

Output: "IPv4"

Explanation: This is a valid IPv4 address, return "IPv4".

    

    Example 2:
    Input: "2001:0db8:85a3:0:0:8A2E:0370:7334"

Output: "IPv6"

Explanation: This is a valid IPv6 address, return "IPv6".

    

    Example 3:
    Input: "256.256.256.256"

Output: "Neither"

Explanation: This is neither a IPv4 address nor a IPv6 address.
-----------------

# 1013_Partition_Array_Into_Three_Parts_With_Equal_Sum
# 1013. Partition Array Into Three Parts With Equal Sum

Given an array A of integers, return true if and only if we can
        partition the array into three non-empty parts with equal sums.

    Formally, we can partition the array if we can find indexes i+1 < j with
        (A[0] + A[1] + ... + A[i] == A[i+1] + A[i+2] + ... + A[j-1] == A[j] + A[j-1] + ... +
            A[A.length - 1])

     

    Example 1:

    Input: [0,2,1,-6,6,-7,9,1,2,0,1]
Output: true
Explanation: 0 + 2 + 1 = -6 + 6 - 7 + 9 + 1 = 2 + 0 + 1
-----------------

# 785_Is_Graph_Bipartite
# 785. Is Graph Bipartite?

Given an undirected graph, return true if and only if it is
        bipartite.

    Recall that a graph is bipartite if we can split it's set of nodes into two
        independent subsets A and B such that every edge in the graph has one node in A and
        another node in B.

    The graph is given in the following form: graph[i] is a list of indexes
        j for which the edge between nodes i and j exists. 
        Each node is an integer between 0 and graph.length - 1. 
        There are no self edges or parallel edges: graph[i] does not contain
        i, and it doesn't contain any element twice.

    Example 1:
Input: [[1,3], [0,2], [1,3], [0,2]]
Output: true
Explanation:
The graph looks like this:
0----1
|    |
|    |
3----2
We can divide the vertices into two groups: {0, 2} and {1, 3}.

    Example 2:
Input: [[1,2,3], [0,2], [0,1,3], [0,2]]
Output: false
Explanation:
The graph looks like this:
0----1
| \  |
|  \ |
3----2
We cannot find a way to divide the set of nodes into two independent subsets.

     

    Note:

    
        graph will have length in range [1, 100].
        graph[i] will contain integers in range [0, graph.length - 1].
        
        graph[i] will not contain i or duplicate values.
        The graph is undirected: if any element j is in graph[i], then
            i will be in graph[j].
-----------------

# 127_Word_Ladder
# 127. Word Ladder

Given two words (beginWord and endWord), and a dictionary's word list,
        find the length of shortest transformation sequence from beginWord to
        endWord, such that:

    
        Only one letter can be changed at a time.
        Each transformed word must exist in the word list. Note that beginWord is not
            a transformed word.
        
    

    Note:

    
        Return 0 if there is no such transformation sequence.
        All words have the same length.
        All words contain only lowercase alphabetic characters.
        You may assume no duplicates in the word list.
        You may assume beginWord and endWord are non-empty and are not the
            same.
        
    

    Example 1:

    Input:
beginWord = "hit",
endWord = "cog",
wordList = ["hot","dot","dog","lot","log","cog"]

Output: 5

Explanation: As one shortest transformation is "hit" -> "hot" -> "dot" -> "dog" -> "cog",
return its length 5.

    Example 2:

    Input:
beginWord = "hit"
endWord = "cog"
wordList = ["hot","dot","dog","lot","log"]

Output: 0

Explanation: The endWord "cog" is not in wordList, therefore no possible transformation.
-----------------

# 1172_Dinner_Plate_Stacks
# 1172. Dinner Plate Stacks

You have an infinite number of stacks arranged in a row and numbered (left to right) from 0,
        each of the stacks has the same maximum capacity.

    Implement the DinnerPlates class:

    
        DinnerPlates(int capacity) Initializes the object with the maximum capacity
            of the stacks.
        
        void push(int val) pushes the given positive integer val
            into the leftmost stack with size less than capacity.
        
        int pop() returns the value at the top of the rightmost non-empty
            stack and removes it from that stack, and returns -1 if all stacks are
            empty.
        
        int popAtStack(int index) returns the value at the top of the stack
            with the given index and removes it from that stack, and returns -1 if the
            stack with that given index is empty.
        
    

    Example:

    Input: 
["DinnerPlates","push","push","push","push","push","popAtStack","push","push","popAtStack","popAtStack","pop","pop","pop","pop","pop"]
[[2],[1],[2],[3],[4],[5],[0],[20],[21],[0],[2],[],[],[],[],[]]
Output: 
[null,null,null,null,null,null,2,null,null,20,21,5,4,3,1,-1]

Explanation: 
DinnerPlates D = DinnerPlates(2);  // Initialize with capacity = 2
D.push(1);
D.push(2);
D.push(3);
D.push(4);
D.push(5);         // The stacks are now:  2  4
                                           1  3  5
                                           ﹈ ﹈ ﹈
D.popAtStack(0);   // Returns 2.  The stacks are now:     4
                                                       1  3  5
                                                       ﹈ ﹈ ﹈
D.push(20);        // The stacks are now: 20  4
                                           1  3  5
                                           ﹈ ﹈ ﹈
D.push(21);        // The stacks are now: 20  4 21
                                           1  3  5
                                           ﹈ ﹈ ﹈
D.popAtStack(0);   // Returns 20.  The stacks are now:     4 21
                                                        1  3  5
                                                        ﹈ ﹈ ﹈
D.popAtStack(2);   // Returns 21.  The stacks are now:     4
                                                        1  3  5
                                                        ﹈ ﹈ ﹈
D.pop()            // Returns 5.  The stacks are now:      4
                                                        1  3
                                                        ﹈ ﹈
D.pop()            // Returns 4.  The stacks are now:   1  3
                                                        ﹈ ﹈
D.pop()            // Returns 3.  The stacks are now:   1
                                                        ﹈
D.pop()            // Returns 1.  There are no stacks.
D.pop()            // Returns -1.  There are still no stacks.

     
    Constraints:

    
        1 <= capacity <= 20000
        1 <= val <= 20000
        0 <= index <= 100000
        At most 200000 calls will be made to push,
            pop, and popAtStack.
-----------------

# 322_Coin_Change
# 322. Coin Change

You are given coins of different denominations and a total amount of money amount.
        Write a function to compute the fewest number of coins that you need to make up that amount.
        If that amount of money cannot be made up by any combination of the coins, return
        -1.

    Example 1:

    Input: coins = [1, 2, 5], amount = 11
Output: 3
Explanation: 11 = 5 + 5 + 1

    Example 2:

    Input: coins = [2], amount = 3
Output: -1

    Note:
        You may assume that you have an infinite number of each kind of coin.
-----------------

# 326_Power_of_Three
# 326. Power of Three

Given an integer, write a function to determine if it is a power of three.

    Example 1:

    Input: 27
Output: true

    Example 2:

    Input: 0
Output: false

    Example 3:

    Input: 9
Output: true

    Example 4:

    Input: 45
Output: false

    Follow up:
        Could you do it without using any loop / recursion?
-----------------

# 1767_Find_the_Subtasks_That_Did_Not_Execute
# 1767. Find the Subtasks That Did Not Execute


-----------------

# 1544_Make_The_String_Great
# 1544. Make The String Great


-----------------

# 1339_Maximum_Product_of_Splitted_Binary_Tree
# 1339. Maximum Product of Splitted Binary Tree


-----------------

# 1555_Bank_Account_Summary
# 1555. Bank Account Summary


-----------------

# 45_Jump_Game_II
# 45. Jump Game II

Given an array of non-negative integers, you are initially positioned at the first index of
        the array.

    Each element in the array represents your maximum jump length at that position.

    Your goal is to reach the last index in the minimum number of jumps.

    Example:

    Input: [2,3,1,1,4]
Output: 2
Explanation: The minimum number of jumps to reach the last index is 2.
    Jump 1 step from index 0 to 1, then 3 steps to the last index.

    Note:

    You can assume that you can always reach the last index.
-----------------

# 1280_Students_and_Examinations
# 1280. Students and Examinations


-----------------

# 571_Find_Median_Given_Frequency_of_Numbers
# 571. Find Median Given Frequency of Numbers

The Numbers table keeps the value of number and its frequency.

    +----------+-------------+
|  Number  |  Frequency  |
+----------+-------------|
|  0       |  7          |
|  1       |  1          |
|  2       |  3          |
|  3       |  1          |
+----------+-------------+

    In this table, the numbers are 0, 0, 0, 0, 0, 0, 0, 1, 2, 2, 2, 3, so the median
        is (0 + 0) / 2 = 0.

    +--------+
| median |
+--------|
| 0.0000 |
+--------+

    Write a query to find the median of all numbers and name the result as median.
-----------------

# 1790_Check_if_One_String_Swap_Can_Make_Strings_Equal
# 1790. Check if One String Swap Can Make Strings Equal


-----------------

# 853_Car_Fleet
# 853. Car Fleet

N cars are going to the same destination along a one lane road.  The
        destination is target miles away.

    Each car i has a constant speed speed[i] (in miles per
        hour), and initial position position[i] miles towards the target along the
        road.

    A car can never pass another car ahead of it, but it can catch up to it, and drive bumper to
        bumper at the same speed.

    The distance between these two cars is ignored - they are assumed to have the same
        position.

    A car fleet is some non-empty set of cars driving at the same position and same
        speed.  Note that a single car is also a car fleet.

    If a car catches up to a car fleet right at the destination point, it will still be considered
        as one car fleet.

    
        How many car fleets will arrive at the destination?

     

    Example 1:

    Input: target = 12, position = [10,8,0,5,3], speed = [2,4,1,1,3]
Output: 3
Explanation:
The cars starting at 10 and 8 become a fleet, meeting each other at 12.
The car starting at 0 doesn't catch up to any other car, so it is a fleet by itself.
The cars starting at 5 and 3 become a fleet, meeting each other at 6.
Note that no other cars meet these fleets before the destination, so the answer is 3.

    
        Note:

    
        0 <= N <= 10 ^ 4
        0 < target <= 10 ^ 6
        0 < speed[i] <= 10 ^ 6
        0 <= position[i] < target
        All initial positions are different.
-----------------

# 817_Linked_List_Components
# 817. Linked List Components

We are given head, the head node of a linked list
        containing unique integer values.

    We are also given the list G, a subset of the values in the linked list.
    

    Return the number of connected components in G, where two values are connected
        if they appear consecutively in the linked list.

    Example 1:

    Input:
head: 0->1->2->3
G = [0, 1, 3]
Output: 2
Explanation:
0 and 1 are connected, so [0, 1] and [3] are the two connected components.

    Example 2:

    Input:
head: 0->1->2->3->4
G = [0, 3, 1, 4]
Output: 2
Explanation:
0 and 1 are connected, 3 and 4 are connected, so [0, 1] and [3, 4] are the two connected components.

    Note: 

    
        If N is the length of the linked list given by head, 1
            <= N <= 10000.
        
        The value of each node in the linked list will be in the range [0, N - 1].
        
        1 <= G.length <= 10000.
        G is a subset of all values in the linked list.
-----------------

# 1248_Count_Number_of_Nice_Subarrays
# 1248. Count Number of Nice Subarrays

Given an array of integers nums and an integer k.
        A subarray is called nice if there
        are k odd numbers on it.

    Return the number of nice sub-arrays.

     
    Example 1:

    Input: nums = [1,1,2,1,1], k = 3
Output: 2
Explanation: The only sub-arrays with 3 odd numbers are [1,1,2,1] and [1,2,1,1].

    Example 2:

    Input: nums = [2,4,6], k = 1
Output: 0
Explanation: There is no odd numbers in the array.

    Example 3:

    Input: nums = [2,2,2,1,2,2,1,2,2,2], k = 2
Output: 16

     
    Constraints:

    
        1 <= nums.length <= 50000
        1 <= nums[i] <= 10^5
        1 <= k <= nums.length
-----------------

# 1227_Airplane_Seat_Assignment_Probability
# 1227. Airplane Seat Assignment Probability

n passengers board an airplane with exactly n seats. The first passenger has lost the ticket
        and picks a seat randomly. But after that, the rest of passengers will:

    
        Take their own seat if it is still available, 
        Pick other seats randomly when they find their seat occupied 
    

    What is the probability that the n-th person can get his own seat?

     
    Example 1:

    Input: n = 1
Output: 1.00000
Explanation: The first person can only get the first seat.

    Example 2:

    Input: n = 2
Output: 0.50000
Explanation: The second person has a probability of 0.5 to get the second seat (when first person gets the first seat).

     
    Constraints:

    
        1 <= n <= 10^5
-----------------

# 1135_Connecting_Cities_With_Minimum_Cost
# 1135. Connecting Cities With Minimum Cost

There are N cities numbered from 1 to N.

    You are given connections, where each connections[i] = [city1, city2,
        cost] represents the cost to connect city1 and city2
        together.  (A connection is bidirectional: connecting city1 and
        city2 is the same as connecting city2 and city1.)

    Return the minimum cost so that for every pair of cities, there exists a path of
        connections (possibly of length 1) that connects those two cities together.  The cost
        is the sum of the connection costs used. If the task is impossible, return -1.

     

    Example 1:

    

    Input: N = 3, connections = [[1,2,5],[1,3,6],[2,3,1]]
Output: 6
Explanation: 
Choosing any 2 edges will connect all cities so we choose the minimum 2.

    Example 2:

    

    Input: N = 4, connections = [[1,2,3],[3,4,4]]
Output: -1
Explanation: 
There is no way to connect all cities even if all edges are used.

     

    Note:

    
        1 <= N <= 10000
        1 <= connections.length <= 10000
        1 <= connections[i][0], connections[i][1] <= N
        0 <= connections[i][2] <= 10^5
        connections[i][0] != connections[i][1]
-----------------

# 604_Design_Compressed_String_Iterator
# 604. Design Compressed String Iterator

Design and implement a data structure for a compressed string iterator. It should support
        the following operations: next and hasNext.
    

    
        The given compressed string will be in the form of each letter followed by a positive
        integer representing the number of this letter existing in the original uncompressed string.
    

    
        next() - if the original string still has uncompressed characters, return the
        next letter; Otherwise return a white space.
        hasNext() - Judge whether there is any letter needs to be uncompressed.
    

    
        Note:
        Please remember to RESET your class variables declared in StringIterator, as
        static/class variables are persisted across multiple test cases. Please see here for more details.
    

    Example:
    StringIterator iterator = new StringIterator("L1e2t1C1o1d1e1");

iterator.next(); // return 'L'
iterator.next(); // return 'e'
iterator.next(); // return 'e'
iterator.next(); // return 't'
iterator.next(); // return 'C'
iterator.next(); // return 'o'
iterator.next(); // return 'd'
iterator.hasNext(); // return true
iterator.next(); // return 'e'
iterator.hasNext(); // return false
iterator.next(); // return ' '
-----------------

# 1618_Maximum_Font_to_Fit_a_Sentence_in_a_Screen
# 1618. Maximum Font to Fit a Sentence in a Screen


-----------------

# 1151_Minimum_Swaps_to_Group_All_1's_Together
# 1151. Minimum Swaps to Group All 1's Together

Given a binary array data, return the minimum number of swaps required
        to group all 1’s present in the array together in any
            place in the array.

     

    Example 1:

    Input: [1,0,1,0,1]
Output: 1
Explanation: 
There are 3 ways to group all 1's together:
[1,1,1,0,0] using 1 swap.
[0,1,1,1,0] using 2 swaps.
[0,0,1,1,1] using 1 swap.
The minimum is 1.

    Example 2:

    Input: [0,0,0,1,0]
Output: 0
Explanation: 
Since there is only one 1 in the array, no swaps needed.

    Example 3:

    Input: [1,0,1,0,1,0,0,1,1,0,1]
Output: 3
Explanation: 
One possible solution that uses 3 swaps is [0,0,0,0,0,1,1,1,1,1,1].

     

    Note:

    
        1 <= data.length <= 10^5
        0 <= data[i] <= 1
-----------------

# 1372_Longest_ZigZag_Path_in_a_Binary_Tree
# 1372. Longest ZigZag Path in a Binary Tree


-----------------

# 144_Binary_Tree_Preorder_Traversal
# 144. Binary Tree Preorder Traversal

Given a binary tree, return the preorder traversal of its nodes' values.

    Example:

    Input: [1,null,2,3]
   1
    \
     2
    /
   3

Output: [1,2,3]

    Follow up: Recursive solution is trivial, could you do it iteratively?
-----------------

# 803_Bricks_Falling_When_Hit
# 803. Bricks Falling When Hit

We have a grid of 1s and 0s; the 1s in a cell represent bricks.  A brick will not drop
        if and only if it is directly connected to the top of the grid, or at least one of its
        (4-way) adjacent bricks will not drop.

    We will do some erasures sequentially. Each time we want to do the erasure at the
        location (i, j), the brick (if it exists) on that location will disappear, and then some
        other bricks may drop because of that erasure.

    Return an array representing the number of bricks that will drop after each erasure in
        sequence.

    Example 1:
Input:
grid = [[1,0,0,0],[1,1,1,0]]
hits = [[1,0]]
Output: [2]
Explanation: 
If we erase the brick at (1, 0), the brick at (1, 1) and (1, 2) will drop. So we should return 2.

    Example 2:
Input:
grid = [[1,0,0,0],[1,1,0,0]]
hits = [[1,1],[1,0]]
Output: [0,0]
Explanation: 
When we erase the brick at (1, 0), the brick at (1, 1) has already disappeared due to the last move. So each erasure will cause no bricks dropping.  Note that the erased brick (1, 0) will not be counted as a dropped brick.

     

    Note:

    
        The number of rows and columns in the grid will be in the range [1, 200].
        The number of erasures will not exceed the area of the grid.
        It is guaranteed that each erasure will be different from any other erasure, and located
            inside the grid.
        
        An erasure may refer to a location with no brick - if it does, no bricks drop.
-----------------

# 531_Lonely_Pixel_I
# 531. Lonely Pixel I

Given a picture consisting of black and white pixels, find the number of black lonely
        pixels.

    The picture is represented by a 2D char array consisting of 'B' and 'W', which means black
        and white pixels respectively. 

    A black lonely pixel is character 'B' that located at a specific position where the same row
        and same column don't have any other black pixels.

    Example:
    Input:
[['W', 'W', 'B'],
 ['W', 'B', 'W'],
 ['B', 'W', 'W']]

Output: 3
Explanation: All the three 'B's are black lonely pixels.

    

    Note:
    
        The range of width and height of the input 2D array is [1,500].
-----------------

# 932_Beautiful_Array
# 932. Beautiful Array

For some fixed N, an array A is beautiful if it is a
        permutation of the integers 1, 2, ..., N, such that:

    For every i < j, there is no k with i
        < k < j such that A[k] * 2 = A[i] + A[j].

    Given N, return any beautiful array A.  (It
        is guaranteed that one exists.)

     

    Example 1:

    Input: 4
Output: [2,1,4,3]
-----------------

# 1216_Valid_Palindrome_III
# 1216. Valid Palindrome III

Given a string s and an integer k, find out if the given
        string is a K-Palindrome or not.

    A string is K-Palindrome if it can be transformed into a palindrome by removing at
        most k characters from it.

     
    Example 1:

    Input: s = "abcdeca", k = 2
Output: true
Explanation: Remove 'b' and 'e' characters.

     
    Constraints:

    
        1 <= s.length <= 1000
        s has only lowercase English letters.
        1 <= k <= s.length
-----------------

# 991_Broken_Calculator
# 991. Broken Calculator

On a broken calculator that has a number showing on its display, we can perform two
        operations:

    
        Double: Multiply the number on the display by 2, or;
        Decrement: Subtract 1 from the number on the display.
    

    Initially, the calculator is displaying the number X.

    Return the minimum number of operations needed to display the number Y.

     

    Example 1:

    Input: X = 2, Y = 3
Output: 2
Explanation: Use double operation and then decrement operation {2 -> 4 -> 3}.

    Example 2:

    Input: X = 5, Y = 8
Output: 2
Explanation: Use decrement and then double {5 -> 4 -> 8}.

    Example 3:

    Input: X = 3, Y = 10
Output: 3
Explanation:  Use double, decrement and double {3 -> 6 -> 5 -> 10}.

    Example 4:

    Input: X = 1024, Y = 1
Output: 1023
Explanation: Use decrement operations 1023 times.

     

    Note:

    
        1 <= X <= 10^9
        1 <= Y <= 10^9
-----------------

# 335_Self_Crossing
# 335. Self Crossing

You are given an array x of n positive numbers. You start at point (0,0)
        and moves x[0] metres to the north, then x[1] metres to the west,
        x[2] metres to the south, x[3] metres to the east and so on. In
        other words, after each move your direction changes counter-clockwise.

    Write a one-pass algorithm with O(1) extra space to determine, if your path
        crosses itself, or not.

     

    Example 1:

    ┌───┐
│   │
└───┼──>
    │

Input: [2,1,1,2]
Output: true

    Example 2:

    ┌──────┐
│      │
│
│
└────────────>

Input: [1,2,3,4]
Output: false

    Example 3:

    ┌───┐
│   │
└───┼>

Input: [1,1,1,1]
Output: true
-----------------

# 188_Best_Time_to_Buy_and_Sell_Stock_IV
# 188. Best Time to Buy and Sell Stock IV

Say you have an array for which the i-th element is the price of a given stock on
        day i.

    Design an algorithm to find the maximum profit. You may complete at most k
        transactions.

    Note:
        You may not engage in multiple transactions at the same time (ie, you must sell the stock
        before you buy again).

    Example 1:

    Input: [2,4,1], k = 2
Output: 2
Explanation: Buy on day 1 (price = 2) and sell on day 2 (price = 4), profit = 4-2 = 2.

    Example 2:

    Input: [3,2,6,5,0,3], k = 2
Output: 7
Explanation: Buy on day 2 (price = 2) and sell on day 3 (price = 6), profit = 6-2 = 4.
             Then buy on day 5 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.
-----------------

# 1528_Shuffle_String
# 1528. Shuffle String


-----------------

# 1770_Maximum_Score_from_Performing_Multiplication_Operations
# 1770. Maximum Score from Performing Multiplication Operations


-----------------

# 293_Flip_Game
# 293. Flip Game

You are playing the following Flip Game with your friend: Given a string that contains only
        these two characters: + and -, you and your friend take turns to
        flip two consecutive "++" into "--".
        The game ends when a person can no longer make a move and therefore the other person will be
        the winner.

    Write a function to compute all possible states of the string after one valid move.

    Example:

    Input: s = "++++"
Output:
[
  "--++",
  "+--+",
  "++--"
]

    Note: If there is no valid move, return an empty list [].
-----------------

# 321_Create_Maximum_Number
# 321. Create Maximum Number

Given two arrays of length m and n with digits 0-9
        representing two numbers. Create the maximum number of length k <= m + n
        from digits of the two. The relative order of the digits from the same array must be
        preserved. Return an array of the k digits.

    Note: You should try to optimize your time and space complexity.

    Example 1:

    Input:
nums1 = [3, 4, 6, 5]
nums2 = [9, 1, 2, 5, 8, 3]
k = 5
Output:
[9, 8, 6, 5, 3]

    Example 2:

    Input:
nums1 = [6, 7]
nums2 = [6, 0, 4]
k = 5
Output:
[6, 7, 6, 0, 4]

    Example 3:

    Input:
nums1 = [3, 9]
nums2 = [8, 9]
k = 3
Output:
[9, 8, 9]
-----------------

# 195_Tenth_Line
# 195. Tenth Line

Given a text file file.txt, print just the 10th line of the file.
    

    Example:

    Assume that file.txt has the following content:

    Line 1
Line 2
Line 3
Line 4
Line 5
Line 6
Line 7
Line 8
Line 9
Line 10

    Your script should output the tenth line, which is:

    Line 10
-----------------

# 1088_Confusing_Number_II
# 1088. Confusing Number II

We can rotate digits by 180 degrees to form new digits. When 0, 1, 6, 8, 9 are rotated 180
        degrees, they become 0, 1, 9, 8, 6 respectively. When 2, 3, 4, 5 and 7 are rotated 180
        degrees, they become invalid.

    A confusing number is a number that when rotated 180 degrees becomes a different
        number with each digit valid.(Note that the rotated number can be greater than the original
        number.)

    Given a positive integer N, return the number of confusing numbers between
        1 and N inclusive.

     

    Example 1:

    Input: 20
Output: 6
Explanation: 
The confusing numbers are [6,9,10,16,18,19].
6 converts to 9.
9 converts to 6.
10 converts to 01 which is just 1.
16 converts to 91.
18 converts to 81.
19 converts to 61.

    Example 2:

    Input: 100
Output: 19
Explanation: 
The confusing numbers are [6,9,10,16,18,19,60,61,66,68,80,81,86,89,90,91,98,99,100].

     

    Note:

    
        1 <= N <= 10^9
-----------------

# 888_Fair_Candy_Swap
# 888. Fair Candy Swap

Alice and Bob have candy bars of different sizes: A[i] is the size of the i-th
        bar of candy that Alice has, and B[j] is the size of the j-th bar
        of candy that Bob has.

    Since they are friends, they would like to exchange one candy bar each so that after the
        exchange, they both have the same total amount of candy.  (The total amount of
            candy a person has is the sum of the sizes of candy bars they have.)

    Return an integer array ans where ans[0] is the size of the
        candy bar that Alice must exchange, and ans[1] is the size of the candy bar
        that Bob must exchange.

    If there are multiple answers, you may return any one of them.  It is guaranteed an
        answer exists.
-----------------

# 1477_Find_Two_Non-overlapping_Sub-arrays_Each_With_Target_Sum
# 1477. Find Two Non-overlapping Sub-arrays Each With Target Sum


-----------------

# 473_Matchsticks_to_Square
# 473. Matchsticks to Square

Remember the story of Little Match Girl? By now, you know exactly what matchsticks the little
        match girl has, please find out a way you can make one square by using up all those
        matchsticks. You should not break any stick, but you can link them up, and each matchstick
        must be used exactly one time.

     Your input will be several matchsticks the girl has, represented with their stick length.
        Your output will either be true or false, to represent whether you could make one square
        using all the matchsticks the little match girl has.

    Example 1:
    Input: [1,1,2,2,2]
Output: true

Explanation: You can form a square with length 2, one side of the square came two sticks with length 1.

    

    Example 2:
    Input: [3,3,3,3,4]
Output: false

Explanation: You cannot find a way to form a square with all the matchsticks.

    

    Note:
    
        The length sum of the given matchsticks is in the range of 0 to
            10^9.
        The length of the given matchstick array will not exceed 15.
-----------------

# 732_My_Calendar_III
# 732. My Calendar III

Implement a MyCalendarThree class to store your events. A new event can always
        be added.

    Your class will have one method, book(int start, int end). Formally, this
        represents a booking on the half open interval [start, end), the range of real
        numbers x such that start <= x < end.

    A K-booking happens when K events have some non-empty intersection (ie., there
        is some time that is common to all K events.)

    For each call to the method MyCalendar.book, return an integer K
        representing the largest integer such that there exists a K-booking in the
        calendar.
    Your class will be called like this: MyCalendarThree cal = new MyCalendarThree();
    MyCalendarThree.book(start, end)

    Example 1:

    MyCalendarThree();
MyCalendarThree.book(10, 20); // returns 1
MyCalendarThree.book(50, 60); // returns 1
MyCalendarThree.book(10, 40); // returns 2
MyCalendarThree.book(5, 15); // returns 3
MyCalendarThree.book(5, 10); // returns 3
MyCalendarThree.book(25, 55); // returns 3
Explanation:
The first two events can be booked and are disjoint, so the maximum K-booking is a 1-booking.
The third event [10, 40) intersects the first event, and the maximum K-booking is a 2-booking.
The remaining events cause the maximum K-booking to be only a 3-booking.
Note that the last event locally causes a 2-booking, but the answer is still 3 because
eg. [10, 20), [10, 40), and [5, 15) are still triple booked.

     

    Note:

    
        The number of calls to MyCalendarThree.book per test case will be at most
            400.
        
        In calls to MyCalendarThree.book(start, end), start and end
            are integers in the range [0, 10^9].
-----------------

# 1263_Minimum_Moves_to_Move_a_Box_to_Their_Target_Location
# 1263. Minimum Moves to Move a Box to Their Target Location


-----------------

# 65_Valid_Number
# 65. Valid Number

Validate if a given string can be interpreted as a decimal number.

    Some examples:
        "0" => true
        " 0.1 " => true
        "abc" => false
        "1 a" => false
        "2e10" => true
        " -90e3   " => true
        " 1e" => false
        "e3" => false
        " 6e-1" => true
        " 99e2.5 " => false
        "53.5e93" => true
        " --6 " => false
        "-+3" => false
        "95a54e53" => false

    Note: It is intended for the problem statement to be ambiguous. You should
        gather all requirements up front before implementing one. However, here is a list of
        characters that can be in a valid decimal number:

    
        Numbers 0-9
        Exponent - "e"
        Positive/negative sign - "+"/"-"
        Decimal point - "."
    

    Of course, the context of these characters also matters in the input.

    Update (2015-02-10):
        The signature of the C++ function had been updated. If you still see your
        function signature accepts a const char * argument, please click the reload
        button to reset your code definition.
-----------------

# 744_Find_Smallest_Letter_Greater_Than_Target
# 744. Find Smallest Letter Greater Than Target

Given a list of sorted characters letters containing only lowercase letters,
        and given a target letter target, find the smallest element in the list that is
        larger than the given target.
    
    
        Letters also wrap around. For example, if the target is target = 'z' and letters
        = ['a', 'b'], the answer is 'a'.
    

    Examples:
    Input:
letters = ["c", "f", "j"]
target = "a"
Output: "c"

Input:
letters = ["c", "f", "j"]
target = "c"
Output: "f"

Input:
letters = ["c", "f", "j"]
target = "d"
Output: "f"

Input:
letters = ["c", "f", "j"]
target = "g"
Output: "j"

Input:
letters = ["c", "f", "j"]
target = "j"
Output: "c"

Input:
letters = ["c", "f", "j"]
target = "k"
Output: "c"

    

    Note:
    
        letters has a length in range [2, 10000].
        letters consists of lowercase letters, and contains at least 2 unique
            letters.
        
        target is a lowercase letter.
-----------------

# 845_Longest_Mountain_in_Array
# 845. Longest Mountain in Array

Let's call any (contiguous) subarray B (of A) a mountain if the following
        properties hold:

    
        B.length >= 3
        There exists some 0 < i < B.length - 1 such that B[0] <
            B[1] < ... B[i-1] < B[i] > B[i+1] > ... > B[B.length - 1]
    

    (Note that B could be any subarray of A, including the entire array A.)

    Given an array A of integers, return the length of the
        longest mountain. 

    Return 0 if there is no mountain.

    Example 1:

    Input: [2,1,4,7,3,2,5]
Output: 5
Explanation: The largest mountain is [1,4,7,3,2] which has length 5.

    Example 2:

    Input: [2,2,2]
Output: 0
Explanation: There is no mountain.

    Note:

    
        0 <= A.length <= 10000
        0 <= A[i] <= 10000
    

    Follow up:

    
        Can you solve it using only one pass?
        Can you solve it in O(1) space?
-----------------

# 1474_Delete_N_Nodes_After_M_Nodes_of_a_Linked_List
# 1474. Delete N Nodes After M Nodes of a Linked List


-----------------

# 415_Add_Strings
# 415. Add Strings

Given two non-negative integers num1 and num2 represented as
        string, return the sum of num1 and num2.

    Note:
    
        The length of both num1 and num2 is < 5100.
        Both num1 and num2 contains only digits 0-9.
        Both num1 and num2 does not contain any leading zero.
        You must not use any built-in BigInteger library or convert the inputs to
            integer directly.
-----------------

# 428_Serialize_and_Deserialize_N-ary_Tree
# 428. Serialize and Deserialize N-ary Tree

Serialization is the process of converting a data structure or object into a sequence of bits
        so that it can be stored in a file or memory buffer, or transmitted across a network
        connection link to be reconstructed later in the same or another computer environment.

    Design an algorithm to serialize and deserialize an N-ary tree. An N-ary tree is a rooted
        tree in which each node has no more than N children. There is no restriction on how your
        serialization/deserialization algorithm should work. You just need to ensure that an N-ary
        tree can be serialized to a string and this string can be deserialized to the original tree
        structure.

    For example, you may serialize the following 3-ary tree

     

    
        

     

    as [1 [3[5 6] 2 4]]. You do not necessarily need to follow this format, so
        please be creative and come up with different approaches yourself.

     

    Note:

    
        N is in the range of  [1, 1000]
        Do not use class member/global/static variables to store states. Your serialize and
            deserialize algorithms should be stateless.
-----------------

# 810_Chalkboard_XOR_Game
# 810. Chalkboard XOR Game

We are given non-negative integers nums[i] which are written on a chalkboard.  Alice and
        Bob take turns erasing exactly one number from the chalkboard, with Alice starting first. 
        If erasing a number causes the bitwise XOR of all the elements of the chalkboard to
        become 0, then that player loses.  (Also, we'll say the bitwise XOR of one
        element is that element itself, and the bitwise XOR of no elements is 0.)

    Also, if any player starts their turn with the bitwise XOR of all the elements of the
        chalkboard equal to 0, then that player wins.

    Return True if and only if Alice wins the game, assuming both players play optimally.

    Example:
Input: nums = [1, 1, 2]
Output: false
Explanation:
Alice has two choices: erase 1 or erase 2.
If she erases 1, the nums array becomes [1, 2]. The bitwise XOR of all the elements of the chalkboard is 1 XOR 2 = 3. Now Bob can remove any element he wants, because Alice will be the one to erase the last element and she will lose.
If Alice erases 2 first, now nums becomes [1, 1]. The bitwise XOR of all the elements of the chalkboard is 1 XOR 1 = 0. Alice will lose.

    Notes: 

    
        1 <= N <= 1000. 
        0 <= nums[i] <= 2^16.
-----------------

# 1621_Number_of_Sets_of_K_Non-Overlapping_Line_Segments
# 1621. Number of Sets of K Non-Overlapping Line Segments


-----------------

# 487_Max_Consecutive_Ones_II
# 487. Max Consecutive Ones II

Given a binary array, find the maximum number of consecutive 1s in this array if you can
        flip at most one 0.
    

    Example 1:
    Input: [1,0,1,1,0]
Output: 4
Explanation: Flip the first zero will get the the maximum number of consecutive 1s.
    After flipping, the maximum number of consecutive 1s is 4.

    

    Note:
    
        The input array will only contain 0 and 1.
        The length of input array is a positive integer and will not exceed 10,000
    
    

    Follow up:
        What if the input numbers come in one by one as an infinite stream? In other words,
        you can't store all numbers coming from the stream as it's too large to hold in memory.
        Could you solve it efficiently?
-----------------

# 650_2_Keys_Keyboard
# 650. 2 Keys Keyboard

Initially on a notepad only one character 'A' is present. You can perform two
        operations on this notepad for each step:

    
        Copy All: You can copy all the characters present on the notepad (partial
            copy is not allowed).
        
        Paste: You can paste the characters which are copied last time.
    

     

    Given a number n. You have to get exactly n 'A' on
        the notepad by performing the minimum number of steps permitted. Output the minimum number
        of steps to get n 'A'.

    Example 1:

    Input: 3
Output: 3
Explanation:
Intitally, we have one character 'A'.
In step 1, we use Copy All operation.
In step 2, we use Paste operation to get 'AA'.
In step 3, we use Paste operation to get 'AAA'.

     

    Note:

    
        The n will be in the range [1, 1000].
-----------------

# 1458_Max_Dot_Product_of_Two_Subsequences
# 1458. Max Dot Product of Two Subsequences


-----------------

# 385_Mini_Parser
# 385. Mini Parser

Given a nested list of integers represented as a string, implement a parser to deserialize
        it.

    Each element is either an integer, or a list -- whose elements may also be integers or other
        lists.

    Note:
        You may assume that the string is well-formed:
    
        String is non-empty.
        String does not contain white spaces.
        String contains only digits 0-9, [, -
            ,, ].
        
    
    

    Example 1:
    Given s = "324",

You should return a NestedInteger object which contains a single integer 324.

    

    Example 2:
    Given s = "[123,[456,[789]]]",

Return a NestedInteger object containing a nested list with 2 elements:

1. An integer containing value 123.
2. A nested list containing two elements:
    i.  An integer containing value 456.
    ii. A nested list with one element:
         a. An integer containing value 789.
-----------------

# 1854_Maximum_Population_Year
# 1854. Maximum Population Year


-----------------

# 1393_Capital_GainLoss
# 1393. Capital Gain/Loss


-----------------

# 595_Big_Countries
# 595. Big Countries

There is a table World

    +-----------------+------------+------------+--------------+---------------+
| name            | continent  | area       | population   | gdp           |
+-----------------+------------+------------+--------------+---------------+
| Afghanistan     | Asia       | 652230     | 25500100     | 20343000      |
| Albania         | Europe     | 28748      | 2831741      | 12960000      |
| Algeria         | Africa     | 2381741    | 37100000     | 188681000     |
| Andorra         | Europe     | 468        | 78115        | 3712000       |
| Angola          | Africa     | 1246700    | 20609294     | 100990000     |
+-----------------+------------+------------+--------------+---------------+

    A country is big if it has an area of bigger than 3 million square km or a population of more
        than 25 million.

    Write a SQL solution to output big countries' name, population and area.

    For example, according to the above table, we should output:

    +--------------+-------------+--------------+
| name         | population  | area         |
+--------------+-------------+--------------+
| Afghanistan  | 25500100    | 652230       |
| Algeria      | 37100000    | 2381741      |
+--------------+-------------+--------------+
-----------------

# 568_Maximum_Vacation_Days
# 568. Maximum Vacation Days

LeetCode wants to give one of its best employees the option to travel among N cities
        to collect algorithm problems. But all work and no play makes Jack a dull boy, you could
        take vacations in some particular cities and weeks. Your job is to schedule the traveling to
        maximize the number of vacation days you could take, but there are certain rules and
        restrictions you need to follow.
    

    Rules and restrictions:
    
        You can only travel among N cities, represented by indexes from 0 to N-1.
            Initially, you are in the city indexed 0 on Monday.
        
        The cities are connected by flights. The flights are represented as a N*N matrix
            (not necessary symmetrical), called flights representing the airline status from
            the city i to the city j. If there is no flight from the city i to the city j, flights[i][j]
                = 0; Otherwise, flights[i][j] = 1. Also, flights[i][i] = 0 for all
            i.
        
        You totally have K weeks (each week has 7 days) to travel. You can only
            take flights at most once per day and can only take flights on each week's Monday
            morning. Since flight time is so short, we don't consider the impact of flight time.
        
        For each city, you can only have restricted vacation days in different weeks, given an
            N*K matrix called days representing this relationship. For the value of
            days[i][j], it represents the maximum days you could take vacation in the city
            i in the week j.
        
    
    

    You're given the flights matrix and days matrix, and you need to output the
        maximum vacation days you could take during K weeks.

    Example 1:
    Input:flights = [[0,1,1],[1,0,1],[1,1,0]], days = [[1,3,1],[6,0,3],[3,3,3]]
Output: 12
Explanation: Ans = 6 + 3 + 3 = 12. 
One of the best strategies is:
1st week : fly from city 0 to city 1 on Monday, and play 6 days and work 1 day. (Although you start at city 0, we could also fly to and start at other cities since it is Monday.)
2nd week : fly from city 1 to city 2 on Monday, and play 3 days and work 4 days.
3rd week : stay at city 2, and play 3 days and work 4 days.

    

    Example 2:
    Input:flights = [[0,0,0],[0,0,0],[0,0,0]], days = [[1,1,1],[7,7,7],[7,7,7]]
Output: 3
Explanation: Ans = 1 + 1 + 1 = 3. 
Since there is no flights enable you to move to another city, you have to stay at city 0 for the whole 3 weeks. For each week, you only have one day to play and six days to work. So the maximum number of vacation days is 3.

    

    Example 3:
    Input:flights = [[0,1,1],[1,0,1],[1,1,0]], days = [[7,0,0],[0,7,0],[0,0,7]]
Output: 21
Explanation:Ans = 7 + 7 + 7 = 21
One of the best strategies is:
1st week : stay at city 0, and play 7 days.
2nd week : fly from city 0 to city 1 on Monday, and play 7 days.
3rd week : fly from city 1 to city 2 on Monday, and play 7 days.

    

    Note:
    
        N and K are positive integers, which are in the range of [1, 100].
        In the matrix flights, all the values are integers in the range of [0, 1].
        In the matrix days, all the values are integers in the range [0, 7].
        You could stay at a city beyond the number of vacation days, but you should work
            on the extra days, which won't be counted as vacation days.
        
        If you fly from the city A to the city B and take the vacation on that day, the
            deduction towards vacation days will count towards the vacation days of city B in that
            week.
        
        We don't consider the impact of flight hours towards the calculation of vacation days.
-----------------

# 895_Maximum_Frequency_Stack
# 895. Maximum Frequency Stack

Implement FreqStack, a class which simulates the operation of a stack-like data
        structure.

    FreqStack has two functions:

    
        push(int x), which pushes an integer x onto the stack.
        pop(), which removes and returns the most frequent element
            in the stack.
            
                If there is a tie for most frequent element, the element closest to the top of
                    the stack is removed and returned.
                
            
        
    

     

    Example 1:

    Input: 
["FreqStack","push","push","push","push","push","push","pop","pop","pop","pop"],
[[],[5],[7],[5],[7],[4],[5],[],[],[],[]]
Output: [null,null,null,null,null,null,null,5,7,5,4]
Explanation:
After making six .push operations, the stack is [5,7,5,7,4,5] from bottom to top.  Then:

pop() -> returns 5, as 5 is the most frequent.
The stack becomes [5,7,5,7,4].

pop() -> returns 7, as 5 and 7 is the most frequent, but 7 is closest to the top.
The stack becomes [5,7,5,4].

pop() -> returns 5.
The stack becomes [5,7,4].

pop() -> returns 4.
The stack becomes [5,7].

     

    Note:

    
        Calls to FreqStack.push(int x) will be such that 0 <= x <=
            10^9.
        
        It is guaranteed that FreqStack.pop() won't be called if the stack has
            zero elements.
        
        The total number of FreqStack.push calls will not exceed 10000
            in a single test case.
        
        The total number of FreqStack.pop calls will not exceed
            10000 in a single test case.
        
        The total number of FreqStack.push and FreqStack.pop calls
            will not exceed 150000 across all test cases.
-----------------

# 160_Intersection_of_Two_Linked_Lists
# 160. Intersection of Two Linked Lists

Write a program to find the node at which the intersection of two singly linked lists
        begins.

    For example, the following two linked lists:
    

    begin to intersect at node c1.

     

    Example 1:
    

    Input: intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3
Output: Reference of the node with value = 8
Input Explanation: The intersected node's value is 8 (note that this must not be 0 if the two lists intersect). From the head of A, it reads as [4,1,8,4,5]. From the head of B, it reads as [5,0,1,8,4,5]. There are 2 nodes before the intersected node in A; There are 3 nodes before the intersected node in B.

     

    Example 2:
    

    Input: intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1
Output: Reference of the node with value = 2
Input Explanation: The intersected node's value is 2 (note that this must not be 0 if the two lists intersect). From the head of A, it reads as [0,9,1,2,4]. From the head of B, it reads as [3,2,4]. There are 3 nodes before the intersected node in A; There are 1 node before the intersected node in B.

     

    Example 3:
    

    Input: intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2
Output: null
Input Explanation: From the head of A, it reads as [2,6,4]. From the head of B, it reads as [1,5]. Since the two lists do not intersect, intersectVal must be 0, while skipA and skipB can be arbitrary values.
Explanation: The two lists do not intersect, so return null.

     

    Notes:

    
        If the two linked lists have no intersection at all, return null.
        The linked lists must retain their original structure after the function returns.
        You may assume there are no cycles anywhere in the entire linked structure.
        Your code should preferably run in O(n) time and use only O(1) memory.
-----------------

# 223_Rectangle_Area
# 223. Rectangle Area

Find the total area covered by two rectilinear rectangles in a
        2D plane.

    Each rectangle is defined by its bottom left corner and top right corner as shown in the
        figure.

    

    Example:

    Input: A = -3, B = 0, C = 3, D = 4, E = 0, F = -1, G = 9, H = 2
Output: 45

    Note:

    Assume that the total area is never beyond the maximum possible value of int.
-----------------

# 735_Asteroid_Collision
# 735. Asteroid Collision

We are given an array asteroids of integers representing asteroids in a row.
    
    
        For each asteroid, the absolute value represents its size, and the sign represents its
        direction (positive meaning right, negative meaning left). Each asteroid moves at the same
        speed.
    
    
        Find out the state of the asteroids after all collisions. If two asteroids meet, the smaller
        one will explode. If both are the same size, both will explode. Two asteroids moving in the
        same direction will never meet.
    

    Example 1:
    Input:
asteroids = [5, 10, -5]
Output: [5, 10]
Explanation:
The 10 and -5 collide resulting in 10.  The 5 and 10 never collide.

    

    Example 2:
    Input:
asteroids = [8, -8]
Output: []
Explanation:
The 8 and -8 collide exploding each other.

    

    Example 3:
    Input:
asteroids = [10, 2, -5]
Output: [10]
Explanation:
The 2 and -5 collide resulting in -5.  The 10 and -5 collide resulting in 10.

    

    Example 4:
    Input:
asteroids = [-2, -1, 1, 2]
Output: [-2, -1, 1, 2]
Explanation:
The -2 and -1 are moving left, while the 1 and 2 are moving right.
Asteroids moving the same direction never meet, so no asteroids will meet each other.

    

    Note:
    The length of asteroids will be at most 10000.
    Each asteroid will be a non-zero integer in the range [-1000, 1000]..
-----------------

# 1190_Reverse_Substrings_Between_Each_Pair_of_Parentheses
# 1190. Reverse Substrings Between Each Pair of Parentheses

You are given a string s that consists of lower case English letters and
        brackets. 

    Reverse the strings in each pair of matching parentheses, starting from the
        innermost one.

    Your result should not contain any brackets.

     
    Example 1:

    Input: s = "(abcd)"
Output: "dcba"

    Example 2:

    Input: s = "(u(love)i)"
Output: "iloveu"
Explanation: The substring "love" is reversed first, then the whole string is reversed.

    Example 3:

    Input: s = "(ed(et(oc))el)"
Output: "leetcode"
Explanation: First, we reverse the substring "oc", then "etco", and finally, the whole string.

    Example 4:

    Input: s = "a(bcdefghijkl(mno)p)q"
Output: "apmnolkjihgfedcbq"

     
    Constraints:

    
        0 <= s.length <= 2000
        s only contains lower case English characters and parentheses.
        It's guaranteed that all parentheses are balanced.
-----------------

# 1388_Pizza_With_3n_Slices
# 1388. Pizza With 3n Slices


-----------------

# 1390_Four_Divisors
# 1390. Four Divisors


-----------------

# 2_Add_Two_Numbers
# 2. Add Two Numbers

You are given two non-empty linked lists representing two non-negative integers. The
        digits are stored in reverse order and each of their nodes contain a single digit.
        Add the two numbers and return it as a linked list.

    You may assume the two numbers do not contain any leading zero, except the number 0
        itself.

    Example:

    Input: (2 -> 4 -> 3) + (5 -> 6 -> 4)
Output: 7 -> 0 -> 8
Explanation: 342 + 465 = 807.
-----------------

# 1300_Sum_of_Mutated_Array_Closest_to_Target
# 1300. Sum of Mutated Array Closest to Target


-----------------

# 958_Check_Completeness_of_a_Binary_Tree
# 958. Check Completeness of a Binary Tree

Given a binary tree, determine if it is a complete binary tree.

    Definition of a complete binary tree from Wikipedia:
        In a complete binary tree every level, except possibly the last, is completely filled, and
        all nodes in the last level are as far left as possible. It can have between 1 and
        2h nodes inclusive at the last level h.

     

    Example 1:

    

    Input: [1,2,3,4,5,6]
Output: true
Explanation: Every level before the last is full (ie. levels with node-values {1} and {2, 3}), and all nodes in the last level ({4, 5, 6}) are as far left as possible.
-----------------

# 1036_Escape_a_Large_Maze
# 1036. Escape a Large Maze

In a 1 million by 1 million grid, the coordinates of each grid square are (x, y)
        with 0 <= x, y < 10^6.

    We start at the source square and want to reach the target square. 
        Each move, we can walk to a 4-directionally adjacent square in the grid that isn't in
        the given list of blocked squares.

    Return true if and only if it is possible to reach the target square through a
        sequence of moves.

     

    Example 1:

    Input: blocked = [[0,1],[1,0]], source = [0,0], target = [0,2]
Output: false
Explanation: 
The target square is inaccessible starting from the source square, because we can't walk outside the grid.

    Example 2:

    Input: blocked = [], source = [0,0], target = [999999,999999]
Output: true
Explanation: 
Because there are no blocked cells, it's possible to reach the target square.

     

    Note:

    
        0 <= blocked.length <= 200
        blocked[i].length == 2
        0 <= blocked[i][j] < 10^6
        source.length == target.length == 2
        0 <= source[i][j], target[i][j] < 10^6
        source != target
-----------------

# 903_Valid_Permutations_for_DI_Sequence
# 903. Valid Permutations for DI Sequence

We are given S, a length n string of characters from the set {'D',
        'I'}. (These letters stand for "decreasing" and "increasing".)
    

    A valid permutation is a permutation P[0], P[1], ..., P[n] of
        integers {0, 1, ..., n}, such that for all i:

    
        If S[i] == 'D', then P[i] > P[i+1], and;
        If S[i] == 'I', then P[i] < P[i+1].
    

    How many valid permutations are there?  Since the answer may be large, return
        your answer modulo 10^9 + 7.

     

    Example 1:

    Input: "DID"
Output: 5
Explanation: 
The 5 valid permutations of (0, 1, 2, 3) are:
(1, 0, 3, 2)
(2, 0, 3, 1)
(2, 1, 3, 0)
(3, 0, 2, 1)
(3, 1, 2, 0)

     

    Note:

    
        1 <= S.length <= 200
        S consists only of characters from the set {'D',
            'I'}.
-----------------

# 120_Triangle
# 120. Triangle

Given a triangle, find the minimum path sum from top to bottom. Each step you may move to
        adjacent numbers on the row below.

    For example, given the following triangle

    [
     [2],
    [3,4],
   [6,5,7],
  [4,1,8,3]
]

    The minimum path sum from top to bottom is 11 (i.e., 2 +
        3 + 5 + 1 = 11).

    Note:

    Bonus point if you are able to do this using only O(n) extra space, where
        n is the total number of rows in the triangle.
-----------------

# 24_Swap_Nodes_in_Pairs
# 24. Swap Nodes in Pairs

Given a linked list, swap every two adjacent nodes and return its head.

    You may not modify the values in the list's nodes, only nodes itself may
        be changed.

     

    Example:

    Given 1->2->3->4, you should return the list as 2->1->4->3.
-----------------

# 352_Data_Stream_as_Disjoint_Intervals
# 352. Data Stream as Disjoint Intervals

Given a data stream input of non-negative integers a1, a2, ...,
        an, ..., summarize the numbers seen so far as a list of disjoint intervals.

    For example, suppose the integers from the data stream are 1, 3, 7, 2, 6, ..., then the
        summary will be:

    [1, 1]
[1, 1], [3, 3]
[1, 1], [3, 3], [7, 7]
[1, 3], [7, 7]
[1, 3], [6, 7]

     

    Follow up:

    What if there are lots of merges and the number of disjoint intervals are small compared to
        the data stream's size?
-----------------

# 1840_Maximum_Building_Height
# 1840. Maximum Building Height


-----------------

# 1437_Check_If_All_1's_Are_at_Least_Length_K_Places_Away
# 1437. Check If All 1's Are at Least Length K Places Away


-----------------

# 1252_Cells_with_Odd_Values_in_a_Matrix
# 1252. Cells with Odd Values in a Matrix

Given n and m which are the dimensions of a
        matrix initialized by zeros and given an array indices where indices[i]
            = [ri, ci]. For each pair of [ri, ci] you have to increment all
        cells in row ri and column ci by 1.

    Return the number of cells with odd values in the matrix after applying the
        increment to all indices.

     
    Example 1:
    
    Input: n = 2, m = 3, indices = [[0,1],[1,1]]
Output: 6
Explanation: Initial matrix = [[0,0,0],[0,0,0]].
After applying first increment it becomes [[1,2,1],[0,1,0]].
The final matrix will be [[1,3,1],[1,3,1]] which contains 6 odd numbers.

    Example 2:
    
    Input: n = 2, m = 2, indices = [[1,1],[0,0]]
Output: 0
Explanation: Final matrix = [[2,2],[2,2]]. There is no odd number in the final matrix.

     
    Constraints:

    
        1 <= n <= 50
        1 <= m <= 50
        1 <= indices.length <= 100
        0 <= indices[i][0] < n
        0 <= indices[i][1] < m
-----------------

# 751_IP_to_CIDR
# 751. IP to CIDR

Given a start IP address ip and a number of ips we need to cover n,
        return a representation of the range as a list (of smallest possible length) of CIDR blocks.
    
    
        A CIDR block is a string consisting of an IP, followed by a slash, and then the prefix
        length. For example: "123.45.67.89/20". That prefix length "20" represents the number of
        common prefix bits in the specified range.
    

    Example 1:
    Input: ip = "255.0.0.7", n = 10
Output: ["255.0.0.7/32","255.0.0.8/29","255.0.0.16/32"]
Explanation:
The initial ip address, when converted to binary, looks like this (spaces added for clarity):
255.0.0.7 -> 11111111 00000000 00000000 00000111
The address "255.0.0.7/32" specifies all addresses with a common prefix of 32 bits to the given address,
ie. just this one address.

The address "255.0.0.8/29" specifies all addresses with a common prefix of 29 bits to the given address:
255.0.0.8 -> 11111111 00000000 00000000 00001000
Addresses with common prefix of 29 bits are:
11111111 00000000 00000000 00001000
11111111 00000000 00000000 00001001
11111111 00000000 00000000 00001010
11111111 00000000 00000000 00001011
11111111 00000000 00000000 00001100
11111111 00000000 00000000 00001101
11111111 00000000 00000000 00001110
11111111 00000000 00000000 00001111

The address "255.0.0.16/32" specifies all addresses with a common prefix of 32 bits to the given address,
ie. just 11111111 00000000 00000000 00010000.

In total, the answer specifies the range of 10 ips starting with the address 255.0.0.7 .

There were other representations, such as:
["255.0.0.7/32","255.0.0.8/30", "255.0.0.12/30", "255.0.0.16/32"],
but our answer was the shortest possible.

Also note that a representation beginning with say, "255.0.0.7/30" would be incorrect,
because it includes addresses like 255.0.0.4 = 11111111 00000000 00000000 00000100
that are outside the specified range.

    

    Note:
    
        ip will be a valid IPv4 address.
        Every implied address ip + x (for x < n) will be a valid IPv4
            address.
        
        n will be an integer in the range [1, 1000].
-----------------

# 1102_Path_With_Maximum_Minimum_Value
# 1102. Path With Maximum Minimum Value

Given a matrix of integers A with R rows
        and C columns, find the maximum score of
        a path starting at [0,0] and ending at [R-1,C-1].

    The score of a path is the minimum value in that path.  For
        example, the value of the path 8 →  4 →  5 →  9 is 4.

    A path moves some number of times from one visited cell to any neighbouring
        unvisited cell in one of the 4 cardinal directions (north, east, west, south).

     

    Example 1:

    

    Input: [[5,4,5],[1,2,6],[7,4,6]]
Output: 4
Explanation: 
The path with the maximum score is highlighted in yellow.

    Example 2:

    

    Input: [[2,2,1,2,2,2],[1,2,2,2,1,2]]
Output: 2

    Example 3:

    
    

    Input: [[3,4,6,3,4],[0,2,1,1,7],[8,8,3,2,7],[3,2,4,9,8],[4,1,2,0,0],[4,6,5,4,3]]
Output: 3

     

    Note:

    
        1 <= R, C <= 100
        0 <= A[i][j] <= 10^9
-----------------

# 13_Roman_to_Integer
# 13. Roman to Integer

Roman numerals are represented by seven different symbols: I,
        V, X, L, C, D and
        M.

    Symbol       Value
I             1
V             5
X             10
L             50
C             100
D             500
M             1000

    For example, two is written as II in Roman numeral, just two one's
        added together. Twelve is written as, XII, which is simply X +
        II. The number twenty seven is written as XXVII, which is
        XX + V + II.

    Roman numerals are usually written largest to smallest from left to right. However, the
        numeral for four is not IIII. Instead, the number four is written as
        IV. Because the one is before the five we subtract it making four. The same
        principle applies to the number nine, which is written as IX. There are six
        instances where subtraction is used:

    
        I can be placed before V (5) and X (10) to make 4
            and 9. 
        
        X can be placed before L (50) and C (100) to make
            40 and 90. 
        
        C can be placed before D (500) and M (1000) to
            make 400 and 900.
        
    

    Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range
        from 1 to 3999.

    Example 1:

    Input: "III"
Output: 3

    Example 2:

    Input: "IV"
Output: 4

    Example 3:

    Input: "IX"
Output: 9

    Example 4:

    Input: "LVIII"
Output: 58
Explanation: L = 50, V= 5, III = 3.

    Example 5:

    Input: "MCMXCIV"
Output: 1994
Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.
-----------------

# 988_Smallest_String_Starting_From_Leaf
# 988. Smallest String Starting From Leaf

Given the root of a binary tree, each node has a value from 0 to
        25 representing the letters 'a' to
        'z': a value of 0 represents 'a', a
        value of 1 represents 'b', and so on.

    Find the lexicographically smallest string that starts at a leaf of this tree and ends at the
        root.

    (As a reminder, any shorter prefix of a string is lexicographically smaller: for example,
        "ab" is lexicographically smaller than "aba". 
        A leaf of a node is a node that has no children.)
-----------------

# 1686_Stone_Game_VI
# 1686. Stone Game VI


-----------------

# 1794_Count_Pairs_of_Equal_Substrings_With_Minimum_Difference
# 1794. Count Pairs of Equal Substrings With Minimum Difference


-----------------

# 837_New_21_Game
# 837. New 21 Game

Alice plays the following game, loosely based on the card game "21".

    Alice starts with 0 points, and draws numbers while she has less than
        K points.  During each draw, she gains an integer number of points
        randomly from the range [1, W], where W is an integer.  Each
        draw is independent and the outcomes have equal probabilities.

    Alice stops drawing numbers when she gets K or more points.  What is the
        probability that she has N or less points?

    Example 1:

    Input: N = 10, K = 1, W = 10
Output: 1.00000
Explanation:  Alice gets a single card, then stops.

    Example 2:

    Input: N = 6, K = 1, W = 10
Output: 0.60000
Explanation:  Alice gets a single card, then stops.
In 6 out of W = 10 possibilities, she is at or below N = 6 points.

    Example 3:

    Input: N = 21, K = 17, W = 10
Output: 0.73278

    Note:

    
        0 <= K <= N <= 10000
        1 <= W <= 10000
        Answers will be accepted as correct if they are within 10^-5 of the correct
            answer.
        
        The judging time limit has been reduced for this question.
-----------------

# 1254_Number_of_Closed_Islands
# 1254. Number of Closed Islands

Given a 2D grid consists of 0s (land) and 1s
        (water).  An island is a maximal 4-directionally connected group of
        0s and a closed island is an island
        totally (all left, top, right, bottom) surrounded by 1s.
    

    Return the number of closed islands.

     
    Example 1:

    

    Input: grid = [[1,1,1,1,1,1,1,0],[1,0,0,0,0,1,1,0],[1,0,1,0,1,1,1,0],[1,0,0,0,0,1,0,1],[1,1,1,1,1,1,1,0]]
Output: 2
Explanation:
Islands in gray are closed because they are completely surrounded by water (group of 1s).

    Example 2:

    

    Input: grid = [[0,0,1,0,0],[0,1,0,1,0],[0,1,1,1,0]]
Output: 1

    Example 3:

    Input: grid = [[1,1,1,1,1,1,1],
               [1,0,0,0,0,0,1],
               [1,0,1,1,1,0,1],
               [1,0,1,0,1,0,1],
               [1,0,1,1,1,0,1],
               [1,0,0,0,0,0,1],
               [1,1,1,1,1,1,1]]
Output: 2

     
    Constraints:

    
        1 <= grid.length, grid[0].length <= 100
        0 <= grid[i][j] <=1
-----------------

# 1678_Goal_Parser_Interpretation
# 1678. Goal Parser Interpretation


-----------------

# 1230_Toss_Strange_Coins
# 1230. Toss Strange Coins

You have some coins.  The i-th coin has a probability prob[i]
        of facing heads when tossed.

    Return the probability that the number of coins facing heads equals target if
        you toss every coin exactly once.

     
    Example 1:
    Input: prob = [0.4], target = 1
Output: 0.40000

    Example 2:
    Input: prob = [0.5,0.5,0.5,0.5,0.5], target = 0
Output: 0.03125

     
    Constraints:

    
        1 <= prob.length <= 1000
        0 <= prob[i] <= 1
        0 <= target <= prob.length
        Answers will be accepted as correct if they are within 10^-5 of the correct
            answer.
-----------------

# 939_Minimum_Area_Rectangle
# 939. Minimum Area Rectangle

Given a set of points in the xy-plane, determine the minimum area of a rectangle formed from
        these points, with sides parallel to the x and y axes.

    If there isn't any rectangle, return 0.
-----------------

# 212_Word_Search_II
# 212. Word Search II

Given a 2D board and a list of words from the dictionary, find all words in the board.

    Each word must be constructed from letters of sequentially adjacent cell, where "adjacent"
        cells are those horizontally or vertically neighboring. The same letter cell may not be used
        more than once in a word.

     

    Example:

    Input:
board = [
  ['o','a','a','n'],
  ['e','t','a','e'],
  ['i','h','k','r'],
  ['i','f','l','v']
]
words = ["oath","pea","eat","rain"]

Output: ["eat","oath"]

     

    Note:

    
        All inputs are consist of lowercase letters a-z.
        The values of words are distinct.
-----------------

# 1319_Number_of_Operations_to_Make_Network_Connected
# 1319. Number of Operations to Make Network Connected


-----------------

# 1837_Sum_of_Digits_in_Base_K
# 1837. Sum of Digits in Base K


-----------------

# 882_Reachable_Nodes_In_Subdivided_Graph
# 882. Reachable Nodes In Subdivided Graph

Starting with an undirected graph (the "original graph") with
        nodes from 0 to N-1, subdivisions are made to some of the edges.
    

    The graph is given as follows: edges[k] is a list of integer pairs (i, j,
        n) such that (i, j) is an edge of the original graph,

    and n is the total number of new nodes on that edge. 

    Then, the edge (i, j) is deleted from the original graph, n new
        nodes (x_1, x_2, ..., x_n) are added to the original graph,

    and n+1 new edges (i, x_1), (x_1, x_2), (x_2, x_3), ..., (x_{n-1},
        x_n), (x_n, j) are added to the original graph.

    Now, you start at node 0 from the original graph, and in each move, you
        travel along one edge. 

    Return how many nodes you can reach in at most M moves.

     

    Example 1:

    Input: edges = [[0,1,10],[0,2,1],[1,2,2]], M = 6, N = 3
Output: 13
Explanation: 
The nodes that are reachable in the final graph after M = 6 moves are indicated below.
-----------------

# 58_Length_of_Last_Word
# 58. Length of Last Word

Given a string s consists of upper/lower-case alphabets and empty space characters
        ' ', return the length of last word in the string.

    If the last word does not exist, return 0.

    Note: A word is defined as a character sequence consists of non-space characters only.
    

    Example:

    Input: "Hello World"
Output: 5
-----------------

# 166_Fraction_to_Recurring_Decimal
# 166. Fraction to Recurring Decimal

Given two integers representing the numerator and denominator of a fraction, return the
        fraction in string format.

    If the fractional part is repeating, enclose the repeating part in parentheses.

    Example 1:

    Input: numerator = 1, denominator = 2
Output: "0.5"

    Example 2:

    Input: numerator = 2, denominator = 1
Output: "2"

    Example 3:

    Input: numerator = 2, denominator = 3
Output: "0.(6)"
-----------------

# 1747_Leetflex_Banned_Accounts
# 1747. Leetflex Banned Accounts


-----------------

# 844_Backspace_String_Compare
# 844. Backspace String Compare

Given two strings S and T, return if they are
        equal when both are typed into empty text editors. # means a backspace
        character.
-----------------

# 1807_Evaluate_the_Bracket_Pairs_of_a_String
# 1807. Evaluate the Bracket Pairs of a String


-----------------

# 1493_Longest_Subarray_of_1's_After_Deleting_One_Element
# 1493. Longest Subarray of 1's After Deleting One Element


-----------------

# 1314_Matrix_Block_Sum
# 1314. Matrix Block Sum


-----------------

# 1693_Daily_Leads_and_Partners
# 1693. Daily Leads and Partners


-----------------

# 271_Encode_and_Decode_Strings
# 271. Encode and Decode Strings

Design an algorithm to encode a list of strings to a string. The encoded string
        is then sent over the network and is decoded back to the original list of strings.

    Machine 1 (sender) has the function:

    string encode(vector<string> strs) {
  // ... your code
  return encoded_string;
}
    Machine 2 (receiver) has the function:

    vector<string> decode(string s) {
  //... your code
  return strs;
}

    So Machine 1 does:

    string encoded_string = encode(strs);

    and Machine 2 does:

    vector<string> strs2 = decode(encoded_string);

    strs2 in Machine 2 should be the same as strs in Machine 1.

    Implement the encode and decode methods.

     

    Note:

    
        The string may contain any possible characters out of 256 valid ascii characters. Your
            algorithm should be generalized enough to work on any possible characters.
        
        Do not use class member/global/static variables to store states. Your encode and decode
            algorithms should be stateless.
        
        Do not rely on any library method such as eval or serialize methods. You
            should implement your own encode/decode algorithm.
-----------------

# 1363_Largest_Multiple_of_Three
# 1363. Largest Multiple of Three


-----------------

# 449_Serialize_and_Deserialize_BST
# 449. Serialize and Deserialize BST

Serialization is the process of converting a data structure or object into a sequence of bits
        so that it can be stored in a file or memory buffer, or transmitted across a network
        connection link to be reconstructed later in the same or another computer environment.

    Design an algorithm to serialize and deserialize a binary search tree. There is no
        restriction on how your serialization/deserialization algorithm should work. You just need
        to ensure that a binary search tree can be serialized to a string and this string can be
        deserialized to the original tree structure.

    The encoded string should be as compact as possible.

    Note: Do not use class member/global/static variables to store states. Your serialize
        and deserialize algorithms should be stateless.
-----------------

# 1149_Article_Views_II
# 1149. Article Views II

Table: Views

    +---------------+---------+
| Column Name   | Type    |
+---------------+---------+
| article_id    | int     |
| author_id     | int     |
| viewer_id     | int     |
| view_date     | date    |
+---------------+---------+
There is no primary key for this table, it may have duplicate rows.
Each row of this table indicates that some viewer viewed an article (written by some author) on some date.
Note that equal author_id and viewer_id indicate the same person.

     

    Write an SQL query to find all the people who viewed more than one article on the same date,
        sorted in ascending order by their id.

    The query result format is in the following example:

    Views table:
+------------+-----------+-----------+------------+
| article_id | author_id | viewer_id | view_date  |
+------------+-----------+-----------+------------+
| 1          | 3         | 5         | 2019-08-01 |
| 3          | 4         | 5         | 2019-08-01 |
| 1          | 3         | 6         | 2019-08-02 |
| 2          | 7         | 7         | 2019-08-01 |
| 2          | 7         | 6         | 2019-08-02 |
| 4          | 7         | 1         | 2019-07-22 |
| 3          | 4         | 4         | 2019-07-21 |
| 3          | 4         | 4         | 2019-07-21 |
+------------+-----------+-----------+------------+

Result table:
+------+
| id   |
+------+
| 5    |
| 6    |
+------+
-----------------

# 165_Compare_Version_Numbers
# 165. Compare Version Numbers

Compare two version numbers version1 and version2.
        If version1 > version2 return 1; if
        version1 < version2 return -1;otherwise
        return 0.

    You may assume that the version strings are non-empty and contain only digits and the
        . character.
    The . character does not represent a decimal point and is used to separate
        number sequences.
    For instance, 2.5 is not "two and a half" or "half way to version
        three", it is the fifth second-level revision of the second first-level revision.
    You may assume the default revision number for each level of a version number to be
        0. For example, version number 3.4 has a revision number of 3
        and 4 for its first and second level revision number. Its third and fourth
        level revision number are both 0.

     

    Example 1:
    Input: version1 = "0.1", version2 = "1.1"
Output: -1

    Example 2:
    Input: version1 = "1.0.1", version2 = "1"
Output: 1

    Example 3:
    Input: version1 = "7.5.2.4", version2 = "7.5.3"
Output: -1

    Example 4:
    Input: version1 = "1.01", version2 = "1.001"
Output: 0
Explanation: Ignoring leading zeroes, both “01” and “001" represent the same number “1”

    Example 5:
    Input: version1 = "1.0", version2 = "1.0.0"
Output: 0
Explanation: The first version number does not have a third level revision number, which means its third level revision number is default to "0"

     

    Note:
    
        Version strings are composed of numeric strings separated by dots . and
            this numeric strings may have leading zeroes.
        
        Version strings do not start or end with dots, and they will not be two consecutive
            dots.
-----------------

# 1798_Maximum_Number_of_Consecutive_Values_You_Can_Make
# 1798. Maximum Number of Consecutive Values You Can Make


-----------------

# 820_Short_Encoding_of_Words
# 820. Short Encoding of Words

Given a list of words, we may encode it by writing a reference string S and a
        list of indexes A.

    For example, if the list of words is ["time", "me", "bell"],
        we can write it as S = "time#bell#" and indexes = [0, 2,
            5].

    Then for each index, we will recover the word by reading from the reference string from that
        index until we reach a "#" character.

    What is the length of the shortest reference string S possible that encodes the given
        words?

    Example:

    Input: words = ["time", "me", "bell"]
Output: 10
Explanation: S = "time#bell#" and indexes = [0, 2, 5].

     

    Note:

    
        1 <= words.length <= 2000.
        1 <= words[i].length <= 7.
        Each word has only lowercase letters.
-----------------

# 1620_Coordinate_With_Maximum_Network_Quality
# 1620. Coordinate With Maximum Network Quality


-----------------

# 1061_Lexicographically_Smallest_Equivalent_String
# 1061. Lexicographically Smallest Equivalent String

Given strings A and B of the same length, we say A[i] and B[i] are
        equivalent characters. For example, if A = "abc" and B = "cde",
        then we have 'a' == 'c', 'b' == 'd', 'c' ==
            'e'.

    Equivalent characters follow the usual rules of any equivalence relation:

    
        Reflexivity: 'a' == 'a'
        Symmetry: 'a' == 'b' implies 'b' == 'a'
        Transitivity: 'a' == 'b' and 'b' == 'c' implies 'a'
            == 'c'
        
    

    For example, given the equivalency information from A and B above,
        S = "eed", "acd", and
        "aab" are equivalent strings, and "aab" is the
        lexicographically smallest equivalent string of S.

    Return the lexicographically smallest equivalent string of S by using the
        equivalency information from A and B.

     

    Example 1:

    Input: A = "parker", B = "morris", S = "parser"
Output: "makkek"
Explanation: Based on the equivalency information in A and B, we can group their characters as [m,p], [a,o], [k,r,s], [e,i]. The characters in each group are equivalent and sorted in lexicographical order. So the answer is "makkek".

    Example 2:

    Input: A = "hello", B = "world", S = "hold"
Output: "hdld"
Explanation:  Based on the equivalency information in A and B, we can group their characters as [h,w], [d,e,o], [l,r]. So only the second letter 'o' in S is changed to 'd', the answer is "hdld".

    Example 3:

    Input: A = "leetcode", B = "programs", S = "sourcecode"
Output: "aauaaaaada"
Explanation:  We group the equivalent characters in A and B as [a,o,e,r,s,c], [l,p], [g,t] and [d,m], thus all letters in S except 'u' and 'd' are transformed to 'a', the answer is "aauaaaaada".

     

    Note:

    
        String A, B and S consist of only lowercase
            English letters from 'a' - 'z'.
        
        The lengths of string A, B and S are between
            1 and 1000.
        
        String A and B are of the same length.
-----------------

# 1472_Design_Browser_History
# 1472. Design Browser History


-----------------

# 329_Longest_Increasing_Path_in_a_Matrix
# 329. Longest Increasing Path in a Matrix

Given an integer matrix, find the length of the longest increasing path.

    From each cell, you can either move to four directions: left, right, up or down. You may NOT
        move diagonally or move outside of the boundary (i.e. wrap-around is not allowed).

    Example 1:

    Input: nums =
[
  [9,9,4],
  [6,6,8],
  [2,1,1]
]
Output: 4
Explanation: The longest increasing path is [1, 2, 6, 9].

    Example 2:

    Input: nums =
[
  [3,4,5],
  [3,2,6],
  [2,2,1]
]
Output: 4
Explanation: The longest increasing path is [3, 4, 5, 6]. Moving diagonally is not allowed.
-----------------

# 1424_Diagonal_Traverse_II
# 1424. Diagonal Traverse II


-----------------

# 235_Lowest_Common_Ancestor_of_a_Binary_Search_Tree
# 235. Lowest Common Ancestor of a Binary Search Tree

Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in
        the BST.

    According to the definition of LCA on Wikipedia: “The lowest
        common ancestor is defined between two nodes p and q as the lowest node in T that has
        both p and q as descendants (where we allow a node to be a descendant of itself).”
    

    Given binary search tree:  root = [6,2,8,0,4,7,9,null,null,3,5]
    
     

    Example 1:

    Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8
Output: 6
Explanation: The LCA of nodes 2 and 8 is 6.

    Example 2:

    Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4
Output: 2
Explanation: The LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition.

     

    Note:

    
        All of the nodes' values will be unique.
        p and q are different and both values will exist in the BST.
-----------------

# 334_Increasing_Triplet_Subsequence
# 334. Increasing Triplet Subsequence

Given an unsorted array return whether an increasing subsequence of length 3 exists or not in
        the array.

    Formally the function should:

    Return true if there exists i, j, k 
        such that arr[i] < arr[j] < arr[k] given 0 ≤ i < j
        < k ≤ n-1 else return false.
    

    Note: Your algorithm should run in O(n) time complexity and
        O(1) space complexity.
-----------------

# 1176_Diet_Plan_Performance
# 1176. Diet Plan Performance

A dieter consumes calories[i] calories on the i-th day. 
    

    Given an integer k, for every consecutive sequence of
        k days (calories[i], calories[i+1], ..., calories[i+k-1] for
        all 0 <= i <= n-k), they look at T, the total calories consumed
        during that sequence of k days (calories[i] + calories[i+1] + ... +
            calories[i+k-1]):

    
        If T < lower, they performed poorly on their diet and lose 1 point; 
        
        If T > upper, they performed well on their diet and gain 1 point;
        Otherwise, they performed normally and there is no change in points.
    

    Initially, the dieter has zero points. Return the total number of points the dieter has after
        dieting for calories.length days.

    Note that the total points can be negative.

     
    Example 1:

    Input: calories = [1,2,3,4,5], k = 1, lower = 3, upper = 3
Output: 0
Explanation: Since k = 1, we consider each element of the array separately and compare it to lower and upper.
calories[0] and calories[1] are less than lower so 2 points are lost.
calories[3] and calories[4] are greater than upper so 2 points are gained.

    Example 2:

    Input: calories = [3,2], k = 2, lower = 0, upper = 1
Output: 1
Explanation: Since k = 2, we consider subarrays of length 2.
calories[0] + calories[1] > upper so 1 point is gained.

    Example 3:

    Input: calories = [6,5,0,0], k = 2, lower = 1, upper = 5
Output: 0
Explanation:
calories[0] + calories[1] > upper so 1 point is gained.
lower <= calories[1] + calories[2] <= upper so no change in points.
calories[2] + calories[3] < lower so 1 point is lost.

     
    Constraints:

    
        1 <= k <= calories.length <= 10^5
        0 <= calories[i] <= 20000
        0 <= lower <= upper
-----------------

# 1804_Implement_Trie_II_(Prefix_Tree)
# 1804. Implement Trie II (Prefix Tree)


-----------------

# 128_Longest_Consecutive_Sequence
# 128. Longest Consecutive Sequence

Given an unsorted array of integers, find the length of the longest consecutive elements
        sequence.

    Your algorithm should run in O(n) complexity.

    Example:

    Input: [100, 4, 200, 1, 3, 2]
Output: 4
Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4.
-----------------

# 443_String_Compression
# 443. String Compression

Given an array of characters, compress it in-place.
    

    The length after compression must always be smaller than or equal to the original array.

    Every element of the array should be a character (not int) of length 1.

    After you are done modifying the input array in-place,
        return the new length of the array.
     

    Follow up:
        Could you solve it using only O(1) extra space?
     

    Example 1:

    Input:
["a","a","b","b","c","c","c"]

Output:
Return 6, and the first 6 characters of the input array should be: ["a","2","b","2","c","3"]

Explanation:
"aa" is replaced by "a2". "bb" is replaced by "b2". "ccc" is replaced by "c3".

     

    Example 2:

    Input:
["a"]

Output:
Return 1, and the first 1 characters of the input array should be: ["a"]

Explanation:
Nothing is replaced.

     

    Example 3:

    Input:
["a","b","b","b","b","b","b","b","b","b","b","b","b"]

Output:
Return 4, and the first 4 characters of the input array should be: ["a","b","1","2"].

Explanation:
Since the character "a" does not repeat, it is not compressed. "bbbbbbbbbbbb" is replaced by "b12".
Notice each digit has it's own entry in the array.

     

    Note:

    
        All characters have an ASCII value in [35, 126].
        1 <= len(chars) <= 1000.
-----------------

# 451_Sort_Characters_By_Frequency
# 451. Sort Characters By Frequency

Given a string, sort it in decreasing order based on the frequency of characters.

    Example 1:
    Input:
"tree"

Output:
"eert"

Explanation:
'e' appears twice while 'r' and 't' both appear once.
So 'e' must appear before both 'r' and 't'. Therefore "eetr" is also a valid answer.

    

    Example 2:
    Input:
"cccaaa"

Output:
"cccaaa"

Explanation:
Both 'c' and 'a' appear three times, so "aaaccc" is also a valid answer.
Note that "cacaca" is incorrect, as the same characters must be together.

    

    Example 3:
    Input:
"Aabb"

Output:
"bbAa"

Explanation:
"bbaA" is also a valid answer, but "Aabb" is incorrect.
Note that 'A' and 'a' are treated as two different characters.
-----------------

# 1208_Get_Equal_Substrings_Within_Budget
# 1208. Get Equal Substrings Within Budget

You are given two strings s and t of the same length. You want to
        change s to t. Changing the i-th character of
        s to i-th character of t costs |s[i] -
            t[i]| that is, the absolute difference between the ASCII values of the
        characters.

    You are also given an integer maxCost.

    Return the maximum length of a substring of s that can be changed to be the same
        as the corresponding substring of twith a cost less than or equal to maxCost.
    

    If there is no substring from s that can be changed to its corresponding
        substring from t, return 0.

     
    Example 1:

    Input: s = "abcd", t = "bcdf", maxCost = 3
Output: 3
Explanation: "abc" of s can change to "bcd". That costs 3, so the maximum length is 3.

    Example 2:

    Input: s = "abcd", t = "cdef", maxCost = 3
Output: 1
Explanation: Each character in s costs 2 to change to charactor in t, so the maximum length is 1.

    Example 3:

    Input: s = "abcd", t = "acde", maxCost = 0
Output: 1
Explanation: You can't make any change, so the maximum length is 1.

     
    Constraints:

    
        1 <= s.length, t.length <= 10^5
        0 <= maxCost <= 10^6
        s and t only contain lower case English letters.
-----------------

# 529_Minesweeper
# 529. Minesweeper

Let's play the minesweeper game (Wikipedia, online game)!

    You are given a 2D char matrix representing the game board. 'M' represents an
        unrevealed mine, 'E' represents an unrevealed empty square, 'B'
        represents a revealed blank square that has no adjacent (above, below, left, right,
        and all 4 diagonals) mines, digit ('1' to '8') represents how many
        mines are adjacent to this revealed square, and finally 'X' represents
        a revealed mine.

    Now given the next click position (row and column indices) among all the unrevealed
        squares ('M' or 'E'), return the board after revealing this position
        according to the following rules:

    
        If a mine ('M') is revealed, then the game is over - change it to
            'X'.
        
        If an empty square ('E') with no adjacent mines is revealed, then change
            it to revealed blank ('B') and all of its adjacent unrevealed squares
            should be revealed recursively.
        
        If an empty square ('E') with at least one adjacent mine is revealed,
            then change it to a digit ('1' to '8') representing the number of
            adjacent mines.
        
        Return the board when no more squares will be revealed.
    

     

    Example 1:

    Input:

[['E', 'E', 'E', 'E', 'E'],
 ['E', 'E', 'M', 'E', 'E'],
 ['E', 'E', 'E', 'E', 'E'],
 ['E', 'E', 'E', 'E', 'E']]

Click : [3,0]

Output:

[['B', '1', 'E', '1', 'B'],
 ['B', '1', 'M', '1', 'B'],
 ['B', '1', '1', '1', 'B'],
 ['B', 'B', 'B', 'B', 'B']]

Explanation:

    Example 2:

    Input:

[['B', '1', 'E', '1', 'B'],
 ['B', '1', 'M', '1', 'B'],
 ['B', '1', '1', '1', 'B'],
 ['B', 'B', 'B', 'B', 'B']]

Click : [1,2]

Output:

[['B', '1', 'E', '1', 'B'],
 ['B', '1', 'X', '1', 'B'],
 ['B', '1', '1', '1', 'B'],
 ['B', 'B', 'B', 'B', 'B']]

Explanation:

     

    Note:

    
        The range of the input matrix's height and width is [1,50].
        The click position will only be an unrevealed square ('M' or 'E'), which
            also means the input board contains at least one clickable square.
        
        The input board won't be a stage when game is over (some mines have been
            revealed).
        
        For simplicity, not mentioned rules should be ignored in this problem. For example, you
            don't need to reveal all the unrevealed mines when the game is over, consider
            any cases that you will win the game or flag any squares.
-----------------

# 1483_Kth_Ancestor_of_a_Tree_Node
# 1483. Kth Ancestor of a Tree Node


-----------------

# 1739_Building_Boxes
# 1739. Building Boxes


-----------------

# 1637_Widest_Vertical_Area_Between_Two_Points_Containing_No_Points
# 1637. Widest Vertical Area Between Two Points Containing No Points


-----------------

# 419_Battleships_in_a_Board
# 419. Battleships in a Board

Given an 2D board, count how many battleships are in it. The battleships are represented with
    'X's, empty slots are represented with '.'s. You may assume the
    following rules:

    
        You receive a valid board, made of only battleships or empty slots.
        Battleships can only be placed horizontally or vertically. In other words, they can only
            be made of the shape 1xN (1 row, N columns) or Nx1 (N rows, 1
            column), where N can be of any size.
        
        At least one horizontal or vertical cell separates between two battleships - there are
            no adjacent battleships.
        
    

    Example:
    X..X
...X
...X

    In the above board there are 2 battleships.

    Invalid Example:
    ...X
XXXX
...X

    This is an invalid board that you will not receive - as battleships will always have a cell
    separating between them.
    
    Follow up:Could you do it in one-pass, using only O(1) extra memory
        and without modifying the value of the board?
-----------------

# 893_Groups_of_Special-Equivalent_Strings
# 893. Groups of Special-Equivalent Strings

You are given an array A of strings.

    Two strings S and T are special-equivalent if
        after any number of moves, S == T.

    A move consists of choosing two indices i and j with
        i % 2 == j % 2, and swapping S[i] with S[j].

    Now, a group of special-equivalent strings from A is a non-empty
        subset S of A such that any string not in S is not special-equivalent
        with any string in S.

    Return the number of groups of special-equivalent strings from A.
-----------------

# 561_Array_Partition_I
# 561. Array Partition I

Given an array of 2n integers, your task is to group these integers into n
        pairs of integer, say (a1, b1), (a2, b2), ...,
        (an, bn) which makes sum of min(ai, bi) for all
        i from 1 to n as large as possible.
    

    Example 1:
    Input: [1,4,3,2]

Output: 4
Explanation: n is 2, and the maximum sum of pairs is 4 = min(1, 2) + min(3, 4).

    

    Note:
    
        n is a positive integer, which is in the range of [1, 10000].
        All the integers in the array will be in the range of [-10000, 10000].
-----------------

# 475_Heaters
# 475. Heaters

Winter is coming! Your first job during the contest is to design a standard heater with fixed
        warm radius to warm all the houses.

    Now, you are given positions of houses and heaters on a horizontal line, find out minimum
        radius of heaters so that all houses could be covered by those heaters.

    So, your input will be the positions of houses and heaters seperately, and your expected
        output will be the minimum radius standard of heaters.

    Note:

    
        Numbers of houses and heaters you are given are non-negative and will not exceed
            25000.
        
        Positions of houses and heaters you are given are non-negative and will not exceed
            10^9.
        
        As long as a house is in the heaters' warm radius range, it can be warmed.
        All the heaters follow your radius standard and the warm radius will the same.
    

     

    Example 1:

    Input: [1,2,3],[2]
Output: 1
Explanation: The only heater was placed in the position 2, and if we use the radius 1 standard, then all the houses can be warmed.

     

    Example 2:

    Input: [1,2,3,4],[1,4]
Output: 1
Explanation: The two heater was placed in the position 1 and 4. We need to use radius 1 standard, then all the houses can be warmed.
-----------------

# 1822_Sign_of_the_Product_of_an_Array
# 1822. Sign of the Product of an Array


-----------------

# 1511_Customer_Order_Frequency
# 1511. Customer Order Frequency


-----------------

# 138_Copy_List_with_Random_Pointer
# 138. Copy List with Random Pointer

A linked list is given such that each node contains an additional random pointer which could
        point to any node in the list or null.

    Return a deep copy of the list.

     

    Example 1:

    

    Input:
{"$id":"1","next":{"$id":"2","next":null,"random":{"$ref":"2"},"val":2},"random":{"$ref":"2"},"val":1}

Explanation:
Node 1's value is 1, both of its next and random pointer points to Node 2.
Node 2's value is 2, its next pointer points to null and its random pointer points to itself.

     

    Note:

    
        You must return the copy of the given head as a reference to the
            cloned list.
-----------------

# 1688_Count_of_Matches_in_Tournament
# 1688. Count of Matches in Tournament


-----------------

# 546_Remove_Boxes
# 546. Remove Boxes

Given several boxes with different colors represented by different positive numbers. 
        You may experience several rounds to remove boxes until there is no box left. Each time you
        can choose some continuous boxes with the same color (composed of k boxes, k >= 1), remove
        them and get k*k points.
        Find the maximum points you can get.
    

    Example 1:
        Input:
    [1, 3, 2, 2, 2, 3, 4, 3, 1]

    Output:
    23

    Explanation:
    [1, 3, 2, 2, 2, 3, 4, 3, 1]
----> [1, 3, 3, 4, 3, 1] (3*3=9 points)
----> [1, 3, 3, 3, 1] (1*1=1 points)
----> [1, 1] (3*3=9 points)
----> [] (2*2=4 points)

    

    Note:
        The number of boxes n would not exceed 100.
-----------------

# 1827_Minimum_Operations_to_Make_the_Array_Increasing
# 1827. Minimum Operations to Make the Array Increasing


-----------------

# 764_Largest_Plus_Sign
# 764. Largest Plus Sign

In a 2D grid from (0, 0) to (N-1, N-1), every cell contains a 1,
        except those cells in the given list mines which are 0. What is
        the largest axis-aligned plus sign of 1s contained in the grid? Return the
        order of the plus sign. If there is none, return 0.
    
    
        An "axis-aligned plus sign of 1s of order k" has some center
        grid[x][y] = 1 along with 4 arms of length k-1 going up, down,
        left, and right, and made of 1s. This is demonstrated in the diagrams below.
        Note that there could be 0s or 1s beyond the arms of the plus
        sign, only the relevant area of the plus sign is checked for 1s.
    
    

    Examples of Axis-Aligned Plus Signs of Order k:
    Order 1:
000
010
000

Order 2:
00000
00100
01110
00100
00000

Order 3:
0000000
0001000
0001000
0111110
0001000
0001000
0000000

    

    Example 1:
    Input: N = 5, mines = [[4, 2]]
Output: 2
Explanation:
11111
11111
11111
11111
11011
In the above grid, the largest plus sign can only be order 2.  One of them is marked in bold.

    

    Example 2:
    Input: N = 2, mines = []
Output: 1
Explanation:
There is no plus sign of order 2, but there is of order 1.

    

    Example 3:
    Input: N = 1, mines = [[0, 0]]
Output: 0
Explanation:
There is no plus sign, so return 0.

    

    Note:
    
        N will be an integer in the range [1, 500].
        mines will have length at most 5000.
        mines[i] will be length 2 and consist of integers in the range [0,
            N-1].
        
        (Additionally, programs submitted in C, C++, or C# will be judged with a slightly
            smaller time limit.)
-----------------

# 1369_Get_the_Second_Most_Recent_Activity
# 1369. Get the Second Most Recent Activity


-----------------

# 345_Reverse_Vowels_of_a_String
# 345. Reverse Vowels of a String

Write a function that takes a string as input and reverse only the vowels of a string.

    Example 1:

    Input: "hello"
Output: "holle"
-----------------

# 1098_Unpopular_Books
# 1098. Unpopular Books

Table: Books

    +----------------+---------+
| Column Name    | Type    |
+----------------+---------+
| book_id        | int     |
| name           | varchar |
| available_from | date    |
+----------------+---------+
book_id is the primary key of this table.

    Table: Orders

    +----------------+---------+
| Column Name    | Type    |
+----------------+---------+
| order_id       | int     |
| book_id        | int     |
| quantity       | int     |
| dispatch_date  | date    |
+----------------+---------+
order_id is the primary key of this table.
book_id is a foreign key to the Books table.

     

    Write an SQL query that reports the books that have sold less
        than 10 copies in the last year, excluding books that have been available for less
        than 1 month from today. Assume today is 2019-06-23.

    The query result format is in the following example:

    Books table:
+---------+--------------------+----------------+
| book_id | name               | available_from |
+---------+--------------------+----------------+
| 1       | "Kalila And Demna" | 2010-01-01     |
| 2       | "28 Letters"       | 2012-05-12     |
| 3       | "The Hobbit"       | 2019-06-10     |
| 4       | "13 Reasons Why"   | 2019-06-01     |
| 5       | "The Hunger Games" | 2008-09-21     |
+---------+--------------------+----------------+

Orders table:
+----------+---------+----------+---------------+
| order_id | book_id | quantity | dispatch_date |
+----------+---------+----------+---------------+
| 1        | 1       | 2        | 2018-07-26    |
| 2        | 1       | 1        | 2018-11-05    |
| 3        | 3       | 8        | 2019-06-11    |
| 4        | 4       | 6        | 2019-06-05    |
| 5        | 4       | 5        | 2019-06-20    |
| 6        | 5       | 9        | 2009-02-02    |
| 7        | 5       | 8        | 2010-04-13    |
+----------+---------+----------+---------------+

Result table:
+-----------+--------------------+
| book_id   | name               |
+-----------+--------------------+
| 1         | "Kalila And Demna" |
| 2         | "28 Letters"       |
| 5         | "The Hunger Games" |
+-----------+--------------------+
-----------------

# 797_All_Paths_From_Source_to_Target
# 797. All Paths From Source to Target

Given a directed, acyclic graph of N nodes.  Find all possible paths from
        node 0 to node N-1, and return them in any order.

    The graph is given as follows:  the nodes are 0, 1, ..., graph.length - 1. 
        graph[i] is a list of all nodes j for which the edge (i, j) exists.

    Example:
Input: [[1,2], [3], [3], []]
Output: [[0,1,3],[0,2,3]]
Explanation: The graph looks like this:
0--->1
|    |
v    v
2--->3
There are two paths: 0 -> 1 -> 3 and 0 -> 2 -> 3.

    Note:

    
        The number of nodes in the graph will be in the range [2, 15].
        You can print different paths in any order, but you should keep the order of nodes
            inside one path.
-----------------

# 1542_Find_Longest_Awesome_Substring
# 1542. Find Longest Awesome Substring


-----------------

# 1407_Top_Travellers
# 1407. Top Travellers


-----------------

# 1622_Fancy_Sequence
# 1622. Fancy Sequence


-----------------

# 721_Accounts_Merge
# 721. Accounts Merge

Given a list accounts, each element accounts[i] is a list of
        strings, where the first element accounts[i][0] is a name, and the rest
        of the elements are emails representing emails of the account.

    Now, we would like to merge these accounts. Two accounts definitely belong to the same person
        if there is some email that is common to both accounts. Note that even if two accounts have
        the same name, they may belong to different people as people could have the same name. A
        person can have any number of accounts initially, but all of their accounts definitely have
        the same name.

    After merging the accounts, return the accounts in the following format: the first element of
        each account is the name, and the rest of the elements are emails in sorted order.
        The accounts themselves can be returned in any order.

    Example 1:
    Input:
accounts = [["John", "johnsmith@mail.com", "john00@mail.com"], ["John", "johnnybravo@mail.com"], ["John", "johnsmith@mail.com", "john_newyork@mail.com"], ["Mary", "mary@mail.com"]]
Output: [["John", 'john00@mail.com', 'john_newyork@mail.com', 'johnsmith@mail.com'],  ["John", "johnnybravo@mail.com"], ["Mary", "mary@mail.com"]]
Explanation:
The first and third John's are the same person as they have the common email "johnsmith@mail.com".
The second John and Mary are different people as none of their email addresses are used by other accounts.
We could return these lists in any order, for example the answer [['Mary', 'mary@mail.com'], ['John', 'johnnybravo@mail.com'],
['John', 'john00@mail.com', 'john_newyork@mail.com', 'johnsmith@mail.com']] would still be accepted.

    

    Note:
    The length of accounts will be in the range [1, 1000].
    The length of accounts[i] will be in the range [1, 10].
    The length of accounts[i][j] will be in the range [1, 30].
-----------------

# 418_Sentence_Screen_Fitting
# 418. Sentence Screen Fitting

Given a rows x cols screen and a sentence represented by a list of
        non-empty words, find how many times the given sentence can be fitted on the
        screen.
    

    Note:
    
        A word cannot be split into two lines.
        The order of words in the sentence must remain unchanged.
        Two consecutive words in a line must be separated by a single space.
        Total words in the sentence won't exceed 100.
        Length of each word is greater than 0 and won't exceed 10.
        1 ≤ rows, cols ≤ 20,000.
    
    

    
        Example 1:
    Input:
rows = 2, cols = 8, sentence = ["hello", "world"]

Output:
1

Explanation:
hello---
world---

The character '-' signifies an empty space on the screen.

    

    
        Example 2:
    Input:
rows = 3, cols = 6, sentence = ["a", "bcd", "e"]

Output:
2

Explanation:
a-bcd-
e-a---
bcd-e-

The character '-' signifies an empty space on the screen.

    

    
        Example 3:
    Input:
rows = 4, cols = 5, sentence = ["I", "had", "apple", "pie"]

Output:
1

Explanation:
I-had
apple
pie-I
had--

The character '-' signifies an empty space on the screen.
-----------------

# 1599_Maximum_Profit_of_Operating_a_Centennial_Wheel
# 1599. Maximum Profit of Operating a Centennial Wheel


-----------------

# 1278_Palindrome_Partitioning_III
# 1278. Palindrome Partitioning III


-----------------

# 532_K-diff_Pairs_in_an_Array
# 532. K-diff Pairs in an Array

Given an array of integers and an integer k, you need to find the number of
        unique k-diff pairs in the array. Here a k-diff pair is defined as an integer
        pair (i, j), where i and j are both numbers in the array and their absolute difference is
        k.
    

    Example 1:
    Input: [3, 1, 4, 1, 5], k = 2
Output: 2
Explanation: There are two 2-diff pairs in the array, (1, 3) and (3, 5).Although we have two 1s in the input, we should only return the number of unique pairs.

    

    Example 2:
    Input:[1, 2, 3, 4, 5], k = 1
Output: 4
Explanation: There are four 1-diff pairs in the array, (1, 2), (2, 3), (3, 4) and (4, 5).

    

    Example 3:
    Input: [1, 3, 1, 5, 4], k = 0
Output: 1
Explanation: There is one 0-diff pair in the array, (1, 1).

    

    Note:
    
        The pairs (i, j) and (j, i) count as the same pair.
        The length of the array won't exceed 10,000.
        All the integers in the given input belong to the range: [-1e7, 1e7].
-----------------

# 1382_Balance_a_Binary_Search_Tree
# 1382. Balance a Binary Search Tree


-----------------

# 1170_Compare_Strings_by_Frequency_of_the_Smallest_Character
# 1170. Compare Strings by Frequency of the Smallest Character

Let's define a function f(s) over a non-empty string s, which
        calculates the frequency of the smallest character in s. For example, if
        s = "dcce" then f(s) = 2 because the smallest character
        is "c" and its frequency is 2.

    Now, given string arrays queries and words, return an integer
        array answer, where each answer[i] is the number of words
        such that f(queries[i]) < f(W), where W is
        a word in words.

     
    Example 1:

    Input: queries = ["cbd"], words = ["zaaaz"]
Output: [1]
Explanation: On the first query we have f("cbd") = 1, f("zaaaz") = 3 so f("cbd") < f("zaaaz").

    Example 2:

    Input: queries = ["bbb","cc"], words = ["a","aa","aaa","aaaa"]
Output: [1,2]
Explanation: On the first query only f("bbb") < f("aaaa"). On the second query both f("aaa") and f("aaaa") are both > f("cc").

     
    Constraints:

    
        1 <= queries.length <= 2000
        1 <= words.length <= 2000
        1 <= queries[i].length, words[i].length <= 10
        queries[i][j], words[i][j] are English lowercase letters.
-----------------

# 1775_Equal_Sum_Arrays_With_Minimum_Number_of_Operations
# 1775. Equal Sum Arrays With Minimum Number of Operations


-----------------

# 1617_Count_Subtrees_With_Max_Distance_Between_Cities
# 1617. Count Subtrees With Max Distance Between Cities


-----------------

# 1619_Mean_of_Array_After_Removing_Some_Elements
# 1619. Mean of Array After Removing Some Elements


-----------------

# 719_Find_K-th_Smallest_Pair_Distance
# 719. Find K-th Smallest Pair Distance

Given an integer array, return the k-th smallest distance among all the pairs. The
        distance of a pair (A, B) is defined as the absolute difference between A and B. 

    Example 1:
    Input:
nums = [1,3,1]
k = 1
Output: 0
Explanation:
Here are all the pairs:
(1,3) -> 2
(1,1) -> 0
(3,1) -> 2
Then the 1st smallest distance pair is (1,1), and its distance is 0.

    

    Note:
    
        2 <= len(nums) <= 10000.
        0 <= nums[i] < 1000000.
        1 <= k <= len(nums) * (len(nums) - 1) / 2.
-----------------

# 708_Insert_into_a_Cyclic_Sorted_List
# 708. Insert into a Cyclic Sorted List

Given a node from a cyclic linked list which is sorted in ascending order, write a function
        to insert a value into the list such that it remains a cyclic sorted list. The given node
        can be a reference to any single node in the list, and may not be necessarily the
        smallest value in the cyclic list.

    If there are multiple suitable places for insertion, you may choose any place to insert the
        new value. After the insertion, the cyclic list should remain sorted.

    If the list is empty (i.e., given node is null), you should create a new single
        cyclic list and return the reference to that single node. Otherwise, you should return the
        original given node.

    The following example may help you understand the problem better:

     

    
        
        In the figure above, there is a cyclic sorted list of three elements. You are given a
            reference to the node with value 3, and we need to insert 2 into the list.
        
    

     

    
        The new node should insert between node 1 and node 3. After the insertion, the list
            should look like this, and we should still return node 3.
-----------------

# 698_Partition_to_K_Equal_Sum_Subsets
# 698. Partition to K Equal Sum Subsets

Given an array of integers nums and a positive integer k, find
        whether it's possible to divide this array into k non-empty subsets whose
        sums are all equal.

     

    Example 1:

    Input: nums = [4, 3, 2, 3, 5, 2, 1], k = 4
Output: True
Explanation: It's possible to divide it into 4 subsets (5), (1, 4), (2,3), (2,3) with equal sums.

     

    Note:

    
        1 <= k <= len(nums) <= 16.
        0 < nums[i] < 10000.
-----------------

# 1512_Number_of_Good_Pairs
# 1512. Number of Good Pairs


-----------------

# 1631_Path_With_Minimum_Effort
# 1631. Path With Minimum Effort


-----------------

# 1111_Maximum_Nesting_Depth_of_Two_Valid_Parentheses_Strings
# 1111. Maximum Nesting Depth of Two Valid Parentheses Strings

A string is a valid parentheses string (denoted VPS) if and only if it consists
        of "(" and ")" characters only, and:

    
        It is the empty string, or
        It can be written as AB (A concatenated with B),
            where A and B are VPS's, or
        
        It can be written as (A), where A is a VPS.
        
    

    We can similarly define the nesting depth depth(S) of any VPS
        S as follows:

    
        depth("") = 0
        depth(A + B) = max(depth(A), depth(B)), where A and
            B are VPS's
        
        depth("(" + A + ")") = 1 + depth(A), where
            A is a VPS.
        
    

    For example,  "", "()()",
        and "()(()())" are VPS's (with nesting depths 0, 1, and
        2), and ")(" and "(()" are not VPS's.

     

    Given a VPS seq, split it into two disjoint subsequences A
        and B, such that A and B are VPS's (and A.length
            + B.length = seq.length).

    Now choose any such A and B such that max(depth(A),
        depth(B)) is the minimum possible value.

    Return an answer array (of length seq.length) that encodes such a choice
        of A and B:  answer[i] = 0 if
        seq[i] is part of A, else answer[i] = 1.  Note
        that even though multiple answers may exist, you may return any of them.

     
    Example 1:

    Input: seq = "(()())"
Output: [0,1,1,1,1,0]

    Example 2:

    Input: seq = "()(())()"
Output: [0,0,0,1,1,0,1,1]

     
    Constraints:

    
        1 <= seq.size <= 10000
-----------------

# 261_Graph_Valid_Tree
# 261. Graph Valid Tree

Given n nodes labeled from 0 to n-1 and a list of
        undirected edges (each edge is a pair of nodes), write a function to check whether these
        edges make up a valid tree.

    Example 1:

    Input: n = 5, and edges = [[0,1], [0,2], [0,3], [1,4]]
Output: true

    Example 2:

    Input: n = 5, and edges = [[0,1], [1,2], [2,3], [1,3], [1,4]]
Output: false

    Note: you can assume that no duplicate edges will appear in edges. Since
        all edges are undirected, [0,1] is the same as [1,0] and thus will
        not appear together in edges.
-----------------

# 288_Unique_Word_Abbreviation
# 288. Unique Word Abbreviation

An abbreviation of a word follows the form <first letter><number><last letter>.
        Below are some examples of word abbreviations:

    a) it                      --> it    (no abbreviation)

     1
     ↓
b) d|o|g                   --> d1g

              1    1  1
     1---5----0----5--8
     ↓   ↓    ↓    ↓  ↓
c) i|nternationalizatio|n  --> i18n

              1
     1---5----0
     ↓   ↓    ↓
d) l|ocalizatio|n          --> l10n

    Assume you have a dictionary and given a word, find whether its abbreviation is unique in the
        dictionary. A word's abbreviation is unique if no other word from the dictionary
        has the same abbreviation.

    Example:

    Given dictionary = [ "deer", "door", "cake", "card" ]

isUnique("dear") -> false
isUnique("cart") -> true
isUnique("cane") -> false
isUnique("make") -> true
-----------------

# 1066_Campus_Bikes_II
# 1066. Campus Bikes II

On a campus represented as a 2D grid, there are N workers and M
        bikes, with N <= M. Each worker and bike is a 2D coordinate on this grid.
    

    We assign one unique bike to each worker so that the sum of the Manhattan distances between
        each worker and their assigned bike is minimized.

    The Manhattan distance between two points p1 and p2 is Manhattan(p1,
        p2) = |p1.x - p2.x| + |p1.y - p2.y|.

    Return the minimum possible sum of Manhattan distances between each worker and their assigned
        bike.

     

    Example 1:

    

    Input: workers = [[0,0],[2,1]], bikes = [[1,2],[3,3]]
Output: 6
Explanation: 
We assign bike 0 to worker 0, bike 1 to worker 1. The Manhattan distance of both assignments is 3, so the output is 6.

    Example 2:

    

    Input: workers = [[0,0],[1,1],[2,0]], bikes = [[1,0],[2,2],[2,1]]
Output: 4
Explanation: 
We first assign bike 0 to worker 0, then assign bike 1 to worker 1 or worker 2, bike 2 to worker 2 or worker 1. Both assignments lead to sum of the Manhattan distances as 4.

     

    Note:

    
        0 <= workers[i][0], workers[i][1], bikes[i][0], bikes[i][1] < 1000
        
        All worker and bike locations are distinct.
        1 <= workers.length <= bikes.length <= 10
-----------------

# 1146_Snapshot_Array
# 1146. Snapshot Array

Implement a SnapshotArray that supports the following interface:

    
        SnapshotArray(int length) initializes an array-like data structure with the
            given length.  Initially, each element equals 0.
        
        void set(index, val) sets the element at the given index to be
            equal to val.
        
        int snap() takes a snapshot of the array and returns the
            snap_id: the total number of times we called snap() minus
            1.
        
        int get(index, snap_id) returns the value at the given
            index, at the time we took the snapshot with the given snap_id
        
    

     
    Example 1:

    Input: ["SnapshotArray","set","snap","set","get"]
[[3],[0,5],[],[0,6],[0,0]]
Output: [null,null,0,null,5]
Explanation: 
SnapshotArray snapshotArr = new SnapshotArray(3); // set the length to be 3
snapshotArr.set(0,5);  // Set array[0] = 5
snapshotArr.snap();  // Take a snapshot, return snap_id = 0
snapshotArr.set(0,6);
snapshotArr.get(0,0);  // Get the value of array[0] with snap_id = 0, return 5

     
    Constraints:

    
        1 <= length <= 50000
        At most 50000 calls will be made to set,
            snap, and get.
        
        0 <= index < length
        0 <= snap_id < (the total number of times we call snap())
        
        0 <= val <= 10^9
-----------------

# 1591_Strange_Printer_II
# 1591. Strange Printer II


-----------------

# 835_Image_Overlap
# 835. Image Overlap

Two images A and B are given, represented as binary, square
        matrices of the same size.  (A binary matrix has only 0s and 1s as values.)

    We translate one image however we choose (sliding it left, right, up, or down any number of
        units), and place it on top of the other image.  After, the overlap of this
        translation is the number of positions that have a 1 in both images.

    (Note also that a translation does not include any kind of rotation.)

    What is the largest possible overlap?

    Example 1:

    Input: A = [[1,1,0],
            [0,1,0],
            [0,1,0]]
       B = [[0,0,0],
            [0,1,1],
            [0,0,1]]
Output: 3
Explanation: We slide A to right by 1 unit and down by 1 unit.

    Notes: 

    
        1 <= A.length = A[0].length = B.length = B[0].length <= 30
        0 <= A[i][j], B[i][j] <= 1
-----------------

# 898_Bitwise_ORs_of_Subarrays
# 898. Bitwise ORs of Subarrays

We have an array A of non-negative integers.

    For every (contiguous) subarray B = [A[i], A[i+1], ..., A[j]] (with i
        <= j), we take the bitwise OR of all the elements in B, obtaining a
        result A[i] | A[i+1] | ... | A[j].

    Return the number of possible results.  (Results that occur more than once are only
        counted once in the final answer.)
-----------------

# 1160_Find_Words_That_Can_Be_Formed_by_Characters
# 1160. Find Words That Can Be Formed by Characters

You are given an array of strings words and a
        string chars.

    A string is good if it can be formed by characters from
        chars (each character can only be used once).

    Return the sum of lengths of all good strings in words.

     

    Example 1:

    Input: words = ["cat","bt","hat","tree"], chars = "atach"
Output: 6
Explanation: 
The strings that can be formed are "cat" and "hat" so the answer is 3 + 3 = 6.

    Example 2:

    Input: words = ["hello","world","leetcode"], chars = "welldonehoneyr"
Output: 10
Explanation: 
The strings that can be formed are "hello" and "world" so the answer is 5 + 5 = 10.

     

    Note:

    
        1 <= words.length <= 1000
        1 <= words[i].length, chars.length <= 100
        All strings contain lowercase English letters only.
-----------------

# 1272_Remove_Interval
# 1272. Remove Interval


-----------------

# 1692_Count_Ways_to_Distribute_Candies
# 1692. Count Ways to Distribute Candies


-----------------

# 1463_Cherry_Pickup_II
# 1463. Cherry Pickup II


-----------------

# 1783_Grand_Slam_Titles
# 1783. Grand Slam Titles


-----------------

# 923_3Sum_With_Multiplicity
# 923. 3Sum With Multiplicity

Given an integer array A, and an integer target, return the number
        of tuples i, j, k  such that i < j < k and A[i]
            + A[j] + A[k] == target.

    As the answer can be very large, return it modulo 10^9 + 7.
    

     

    Example 1:

    Input: A = [1,1,2,2,3,3,4,4,5,5], target = 8
Output: 20
Explanation: 
Enumerating by the values (A[i], A[j], A[k]):
(1, 2, 5) occurs 8 times;
(1, 3, 4) occurs 8 times;
(2, 2, 4) occurs 2 times;
(2, 3, 3) occurs 2 times.
-----------------

# 1844_Replace_All_Digits_with_Characters
# 1844. Replace All Digits with Characters


-----------------

# 287_Find_the_Duplicate_Number
# 287. Find the Duplicate Number

Given an array nums containing n + 1 integers where each integer is between 1
        and n (inclusive), prove that at least one duplicate number must exist. Assume that
        there is only one duplicate number, find the duplicate one.

    Example 1:

    Input: [1,3,4,2,2]
Output: 2

    Example 2:

    Input: [3,1,3,4,2]
Output: 3

    Note:

    
        You must not modify the array (assume the array is read only).
        You must use only constant, O(1) extra space.
        Your runtime complexity should be less than O(n2).
        There is only one duplicate number in the array, but it could be repeated more than
            once.
-----------------

# 149_Max_Points_on_a_Line
# 149. Max Points on a Line

Given n points on a 2D plane, find the maximum number of points that lie on the same
        straight line.

    Example 1:

    Input: [[1,1],[2,2],[3,3]]
Output: 3
Explanation:
^
|
|        o
|     o
|  o  
+------------->
0  1  2  3  4

    Example 2:

    Input: [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]
Output: 4
Explanation:
^
|
|  o
|     o        o
|        o
|  o        o
+------------------->
0  1  2  3  4  5  6

    NOTE: input types have been changed on April 15, 2019. Please reset to
        default code definition to get new method signature.
-----------------

# 1506_Find_Root_of_N-Ary_Tree
# 1506. Find Root of N-Ary Tree


-----------------

# 859_Buddy_Strings
# 859. Buddy Strings

Given two strings A and B of lowercase letters, return true
        if and only if we can swap two letters in A so that the result equals
        B.

     

    Example 1:
-----------------

# 786_K-th_Smallest_Prime_Fraction
# 786. K-th Smallest Prime Fraction

A sorted list A contains 1, plus some number of primes.  Then, for every p
        < q in the list, we consider the fraction p/q.

    What is the K-th smallest fraction considered?  Return your answer as an
        array of ints, where answer[0] = p and answer[1] = q.

    Examples:
Input: A = [1, 2, 3, 5], K = 3
Output: [2, 5]
Explanation:
The fractions to be considered in sorted order are:
1/5, 1/3, 2/5, 1/2, 3/5, 2/3.
The third fraction is 2/5.

Input: A = [1, 7], K = 1
Output: [1, 7]

    Note:

    
        A will have length between 2 and 2000.
        Each A[i] will be between 1 and 30000.
        K will be between 1 and A.length * (A.length - 1) /
            2.
-----------------

# 1575_Count_All_Possible_Routes
# 1575. Count All Possible Routes


-----------------

# 1033_Moving_Stones_Until_Consecutive
# 1033. Moving Stones Until Consecutive

Three stones are on a number line at positions a, b, and
        c.

    Each turn, you pick up a stone at an endpoint (ie., either the lowest or highest position
        stone), and move it to an unoccupied position between those endpoints.  Formally,
        let's say the stones are currently at positions x, y, z with x < y
            < z.  You pick up the stone at either position x or position
        z, and move that stone to an integer position k, with x <
            k < z and k != y.

    The game ends when you cannot make any more moves, ie. the stones are in consecutive
        positions.

    When the game ends, what is the minimum and maximum number of moves that you could have made? 
        Return the answer as an length 2 array: answer = [minimum_moves, maximum_moves]
    

     

    Example 1:

    Input: a = 1, b = 2, c = 5
Output: [1,2]
Explanation: Move the stone from 5 to 3, or move the stone from 5 to 4 to 3.
-----------------

# 49_Group_Anagrams
# 49. Group Anagrams

Given an array of strings, group anagrams together.

    Example:

    Input: ["eat", "tea", "tan", "ate", "nat", "bat"],
Output:
[
  ["ate","eat","tea"],
  ["nat","tan"],
  ["bat"]
]

    Note:

    
        All inputs will be in lowercase.
        The order of your output does not matter.
-----------------

# 1516_Move_Sub-Tree_of_N-Ary_Tree
# 1516. Move Sub-Tree of N-Ary Tree


-----------------

# 734_Sentence_Similarity
# 734. Sentence Similarity

Given two sentences words1, words2 (each represented as an array of strings),
        and a list of similar word pairs pairs, determine if two sentences are similar.
    

    For example, "great acting skills" and "fine drama talent" are similar,
        if the similar word pairs are pairs = [["great", "fine"], ["acting","drama"],
            ["skills","talent"]].

    Note that the similarity relation is not transitive. For example, if "great" and
        "fine" are similar, and "fine" and "good" are similar, "great"
        and "good" are not necessarily similar.

    However, similarity is symmetric. For example, "great" and "fine" being
        similar is the same as "fine" and "great" being similar.

    Also, a word is always similar with itself. For example, the sentences words1 = ["great"],
        words2 = ["great"], pairs = [] are similar, even though there are no
        specified similar word pairs.

    Finally, sentences can only be similar if they have the same number of words. So a sentence
        like words1 = ["great"] can never be similar to words2 = ["doubleplus","good"].
    

    Note:

    
        The length of words1 and words2 will not exceed
            1000.
        
        The length of pairs will not exceed 2000.
        The length of each pairs[i] will be 2.
        The length of each words[i] and pairs[i][j] will be in the
            range [1, 20].
-----------------

# 1849_Splitting_a_String_Into_Descending_Consecutive_Values
# 1849. Splitting a String Into Descending Consecutive Values


-----------------

# 1099_Two_Sum_Less_Than_K
# 1099. Two Sum Less Than K

Given an array A of integers and integer K, return the maximum
        S such that there exists i < j with A[i] + A[j] =
            S and S < K. If no i, j exist satisfying this
        equation, return -1.

     

    Example 1:

    Input: A = [34,23,1,24,75,33,54,8], K = 60
Output: 58
Explanation: 
We can use 34 and 24 to sum 58 which is less than 60.

    Example 2:

    Input: A = [10,20,30], K = 15
Output: -1
Explanation: 
In this case it's not possible to get a pair sum less that 15.

     

    Note:

    
        1 <= A.length <= 100
        1 <= A[i] <= 1000
        1 <= K <= 2000
-----------------

# 883_Projection_Area_of_3D_Shapes
# 883. Projection Area of 3D Shapes

On a N * N grid, we place some 1 * 1 * 1 cubes
        that are axis-aligned with the x, y, and z axes.

    Each value v = grid[i][j] represents a tower of v cubes
        placed on top of grid cell (i, j).

    Now we view the projection of these cubes onto the xy, yz, and zx
        planes.

    A projection is like a shadow, that maps our 3 dimensional figure to a 2 dimensional
        plane. 

    Here, we are viewing the "shadow" when looking at the cubes from the top, the
        front, and the side.

    Return the total area of all three projections.
-----------------

# 1389_Create_Target_Array_in_the_Given_Order
# 1389. Create Target Array in the Given Order


-----------------

# 1049_Last_Stone_Weight_II
# 1049. Last Stone Weight II

We have a collection of rocks, each rock has a positive integer weight.

    Each turn, we choose any two rocks and smash them together. 
        Suppose the stones have weights x and y with x <=
            y.  The result of this smash is:

    
        If x == y, both stones are totally destroyed;
        If x != y, the stone of weight x is totally destroyed, and the
            stone of weight y has new weight y-x.
        
    

    At the end, there is at most 1 stone left.  Return the smallest
        possible weight of this stone (the weight is 0 if there are no stones left.)
    

     

    Example 1:

    Input: [2,7,4,1,8,1]
Output: 1
Explanation: 
We can combine 2 and 4 to get 2 so the array converts to [2,7,1,8,1] then,
we can combine 7 and 8 to get 1 so the array converts to [2,1,1,1] then,
we can combine 2 and 1 to get 1 so the array converts to [1,1,1] then,
we can combine 1 and 1 to get 0 so the array converts to [1] then that's the optimal value.

     

    Note:

    
        1 <= stones.length <= 30
        1 <= stones[i] <= 100
-----------------

# 222_Count_Complete_Tree_Nodes
# 222. Count Complete Tree Nodes

Given a complete binary tree, count the number of nodes.

    Note: 

    Definition of a complete binary tree from Wikipedia:
        In a complete binary tree every level, except possibly the last, is completely filled, and
        all nodes in the last level are as far left as possible. It can have between 1 and
        2h nodes inclusive at the last level h.

    Example:

    Input:
    1
   / \
  2   3
 / \  /
4  5 6

Output: 6
-----------------

# 1841_League_Statistics
# 1841. League Statistics


-----------------

# 1853_Convert_Date_Format
# 1853. Convert Date Format


-----------------

# 902_Numbers_At_Most_N_Given_Digit_Set
# 902. Numbers At Most N Given Digit Set

We have a sorted set of digits D, a non-empty subset of {'1','2','3','4','5','6','7','8','9'}. 
        (Note that '0' is not included.)

    Now, we write numbers using these digits, using each digit as many times as we want. 
        For example, if D = {'1','3','5'}, we may write numbers
        such as '13', '551', '1351315'.

    Return the number of positive integers that can be written (using the digits of
        D) that are less than or equal to N.

     

    Example 1:

    Input: D = ["1","3","5","7"], N = 100
Output: 20
Explanation: 
The 20 numbers that can be written are:
1, 3, 5, 7, 11, 13, 15, 17, 31, 33, 35, 37, 51, 53, 55, 57, 71, 73, 75, 77.
-----------------

# 242_Valid_Anagram
# 242. Valid Anagram

Given two strings s and t , write a function to determine if
        t is an anagram of s.

    Example 1:

    Input: s = "anagram", t = "nagaram"
Output: true

    Example 2:

    Input: s = "rat", t = "car"
Output: false

    Note:
        You may assume the string contains only lowercase alphabets.

    Follow up:
        What if the inputs contain unicode characters? How would you adapt your solution to such
        case?
-----------------

# 553_Optimal_Division
# 553. Optimal Division

Given a list of positive integers, the adjacent integers will perform the float
        division. For example, [2,3,4] -> 2 / 3 / 4.

    However, you can add any number of parenthesis at any position to change the priority of
        operations. You should find out how to add parenthesis to get the maximum result, and
        return the corresponding expression in string format. Your expression should NOT contain
            redundant parenthesis.

    Example:
    Input: [1000,100,10,2]
Output: "1000/(100/10/2)"
Explanation:
1000/(100/10/2) = 1000/((100/10)/2) = 200
However, the bold parenthesis in "1000/((100/10)/2)" are redundant, since they don't influence the operation priority. So you should return "1000/(100/10/2)".

Other cases:
1000/(100/10)/2 = 50
1000/(100/(10/2)) = 50
1000/100/10/2 = 0.5
1000/100/(10/2) = 2

    

    Note:
    
        The length of the input array is [1, 10].
        Elements in the given array will be in range [2, 1000].
        There is only one optimal division for each test case.
-----------------

# 971_Flip_Binary_Tree_To_Match_Preorder_Traversal
# 971. Flip Binary Tree To Match Preorder Traversal

Given a binary tree with N nodes, each node has a different value
        from {1, ..., N}.

    A node in this binary tree can be flipped by swapping the left child and the
        right child of that node.

    Consider the sequence of N values reported by a preorder traversal starting
        from the root.  Call such a sequence of N values the voyage of
        the tree.

    (Recall that a preorder traversal of a node means we report the current node's
        value, then preorder-traverse the left child, then preorder-traverse the right child.)

    Our goal is to flip the least number of nodes in the tree so that the voyage
        of the tree matches the voyage we are given.

    If we can do so, then return a list of the values of all nodes flipped.  You
        may return the answer in any order.

    If we cannot do so, then return the list [-1].
-----------------

# 582_Kill_Process
# 582. Kill Process

Given n processes, each process has a unique PID (process id) and its PPID
        (parent process id).

    Each process only has one parent process, but may have one or more children processes. This
        is just like a tree structure. Only one process has PPID that is 0, which means this process
        has no parent process. All the PIDs will be distinct positive integers.

    We use two list of integers to represent a list of processes, where the first list contains
        PID for each process and the second list contains the corresponding PPID. 

    Now given the two lists, and a PID representing a process you want to kill, return a list of
        PIDs of processes that will be killed in the end. You should assume that when a process is
        killed, all its children processes will be killed. No order is required for the final
        answer.

    Example 1:
    Input:
pid =  [1, 3, 10, 5]
ppid = [3, 0, 5, 3]
kill = 5
Output: [5,10]
Explanation:
           3
         /   \
        1     5
             /
            10
Kill 5 will also kill 10.

    

    Note:
    
        The given kill id is guaranteed to be one of the given PIDs.
        n >= 1.
-----------------

# 1731_The_Number_of_Employees_Which_Report_to_Each_Employee
# 1731. The Number of Employees Which Report to Each Employee


-----------------

# 1687_Delivering_Boxes_from_Storage_to_Ports
# 1687. Delivering Boxes from Storage to Ports


-----------------

# 559_Maximum_Depth_of_N-ary_Tree
# 559. Maximum Depth of N-ary Tree

Given a n-ary tree, find its maximum depth.

    The maximum depth is the number of nodes along the longest path from the root node down to
        the farthest leaf node.

    For example, given a 3-ary tree:
     

    
        

     

    We should return its max depth, which is 3.

     

    Note:

    
        The depth of the tree is at most 1000.
        The total number of nodes is at most 5000.
-----------------

# 1755_Closest_Subsequence_Sum
# 1755. Closest Subsequence Sum


-----------------

# 28_Implement_strStr()
# 28. Implement strStr()

Implement strStr().
    

    Return the index of the first occurrence of needle in haystack, or -1 if
        needle is not part of haystack.

    Example 1:

    Input: haystack = "hello", needle = "ll"
Output: 2

    Example 2:

    Input: haystack = "aaaaa", needle = "bba"
Output: -1

    Clarification:

    What should we return when needle is an empty string? This is a great question
        to ask during an interview.

    For the purpose of this problem, we will return 0 when needle is an empty
        string. This is consistent to C's strstr() and Java's indexOf().
-----------------

# 716_Max_Stack
# 716. Max Stack

Design a max stack that supports push, pop, top, peekMax and popMax.

    
    
        push(x) -- Push element x onto stack.
        pop() -- Remove the element on top of the stack and return it.
        top() -- Get the element on the top.
        peekMax() -- Retrieve the maximum element in the stack.
        popMax() -- Retrieve the maximum element in the stack, and remove it. If you find more
            than one maximum elements, only remove the top-most one.
        
    
    

    Example 1:
    MaxStack stack = new MaxStack();
stack.push(5);
stack.push(1);
stack.push(5);
stack.top(); -> 5
stack.popMax(); -> 5
stack.top(); -> 1
stack.peekMax(); -> 5
stack.pop(); -> 1
stack.top(); -> 5

    

    Note:
    
        -1e7 <= x <= 1e7
        Number of operations won't exceed 10000.
        The last four operations won't be called when stack is empty.
-----------------

# 269_Alien_Dictionary
# 269. Alien Dictionary

There is a new alien language which uses the latin alphabet. However, the order among letters
        are unknown to you. You receive a list of non-empty words from the dictionary, where
        words are sorted lexicographically by the rules of this new language. Derive the
        order of letters in this language.

    Example 1:

    Input:
[
  "wrt",
  "wrf",
  "er",
  "ett",
  "rftt"
]

Output: "wertf"

    Example 2:

    Input:
[
  "z",
  "x"
]

Output: "zx"

    Example 3:

    Input:
[
  "z",
  "x",
  "z"
]

Output: "" 

Explanation: The order is invalid, so return "".

    Note:

    
        You may assume all letters are in lowercase.
        You may assume that if a is a prefix of b, then a must appear before b in the given
            dictionary.
        
        If the order is invalid, return an empty string.
        There may be multiple valid order of letters, return any one of them is fine.
-----------------

# 51_N-Queens
# 51. N-Queens

The n-queens puzzle is the problem of placing n queens on an n×n
        chessboard such that no two queens attack each other.

    

    Given an integer n, return all distinct solutions to the n-queens puzzle.
    

    Each solution contains a distinct board configuration of the n-queens'
        placement, where 'Q' and '.' both indicate a queen
        and an empty space respectively.

    Example:

    Input: 4
Output: [
 [".Q..",  // Solution 1
  "...Q",
  "Q...",
  "..Q."],

 ["..Q.",  // Solution 2
  "Q...",
  "...Q",
  ".Q.."]
]
Explanation: There exist two distinct solutions to the 4-queens puzzle as shown above.
-----------------

# 756_Pyramid_Transition_Matrix
# 756. Pyramid Transition Matrix

We are stacking blocks to form a pyramid. Each block has a color which is a one letter
        string.

    We are allowed to place any color block C on top of two adjacent blocks of
        colors A and B, if and only if ABC is an allowed
        triple.

    We start with a bottom row of bottom, represented as a single string. We also
        start with a list of allowed triples allowed. Each allowed triple is
        represented as a string of length 3.

    Return true if we can build the pyramid all the way to the top, otherwise false.

    Example 1:

    Input: bottom = "BCD", allowed = ["BCG", "CDE", "GEA", "FFF"]
Output: true
Explanation:
We can stack the pyramid like this:
    A
   / \
  G   E
 / \ / \
B   C   D

We are allowed to place G on top of B and C because BCG is an allowed triple.  Similarly, we can place E on top of C and D, then A on top of G and E.

     

    Example 2:

    Input: bottom = "AABA", allowed = ["AAA", "AAB", "ABA", "ABB", "BAC"]
Output: false
Explanation:
We can't stack the pyramid to the top.
Note that there could be allowed triples (A, B, C) and (A, B, D) with C != D.

     

    Note:

    
        bottom will be a string with length in range [2, 8].
        allowed will have length in range [0, 200].
        Letters in all strings will be chosen from the set {'A', 'B',
            'C', 'D', 'E', 'F', 'G'}.
-----------------

# 718_Maximum_Length_of_Repeated_Subarray
# 718. Maximum Length of Repeated Subarray

Given two integer arrays A and B, return the maximum length of an
        subarray that appears in both arrays.

    Example 1:

    Input:
A: [1,2,3,2,1]
B: [3,2,1,4,7]
Output: 3
Explanation:
The repeated subarray with maximum length is [3, 2, 1].

     

    Note:

    
        1 <= len(A), len(B) <= 1000
        0 <= A[i], B[i] < 100
-----------------

# 338_Counting_Bits
# 338. Counting Bits

Given a non negative integer number num. For every numbers i in the range 0
        ≤ i ≤ num calculate the number of 1's in their binary representation and
        return them as an array.

    Example 1:

    Input: 2
Output: [0,1,1]

    Example 2:

    Input: 5
Output: [0,1,1,2,1,2]

    Follow up:

    
        It is very easy to come up with a solution with run time O(n*sizeof(integer)).
            But can you do it in linear time O(n) /possibly in a single pass?
        
        Space complexity should be O(n).
        Can you do it like a boss? Do it without using any builtin function like __builtin_popcount
            in c++ or in any other language.
-----------------

# 737_Sentence_Similarity_II
# 737. Sentence Similarity II

Given two sentences words1, words2 (each represented as an array of strings),
        and a list of similar word pairs pairs, determine if two sentences are similar.
    

    For example, words1 = ["great", "acting",
        "skills"] and words2 = ["fine", "drama", "talent"]
        are similar, if the similar word pairs are pairs = [["great", "good"],
            ["fine", "good"], ["acting","drama"], ["skills","talent"]].
    

    Note that the similarity relation is transitive. For example, if "great" and
        "good" are similar, and "fine" and "good" are similar, then
        "great" and "fine" are similar.

    Similarity is also symmetric. For example, "great" and "fine" being
        similar is the same as "fine" and "great" being similar.

    Also, a word is always similar with itself. For example, the sentences words1 = ["great"],
        words2 = ["great"], pairs = [] are similar, even though there are no
        specified similar word pairs.

    Finally, sentences can only be similar if they have the same number of words. So a sentence
        like words1 = ["great"] can never be similar to words2 = ["doubleplus","good"].
    

    Note:

    
        The length of words1 and words2 will not exceed
            1000.
        
        The length of pairs will not exceed 2000.
        The length of each pairs[i] will be 2.
        The length of each words[i] and pairs[i][j] will be in the
            range [1, 20].
-----------------

# 1058_Minimize_Rounding_Error_to_Meet_Target
# 1058. Minimize Rounding Error to Meet Target

Given an array of prices [p1,p2...,pn] and a
        target, round each price pi to Roundi(pi)
        so that the rounded array
        [Round1(p1),Round2(p2)...,Roundn(pn)]
        sums to the given target. Each operation Roundi(pi)
        could be either Floor(pi) or Ceil(pi).

    Return the string "-1" if the rounded array is impossible to sum to
        target. Otherwise, return the smallest rounding error, which is defined as
        Σ |Roundi(pi) - (pi)| for
        i
        from 1 to
        n
        , as a string with three places after the decimal.
    

     

    Example 1:

    Input: prices = ["0.700","2.800","4.900"], target = 8
Output: "1.000"
Explanation: 
Use Floor, Ceil and Ceil operations to get (0.7 - 0) + (3 - 2.8) + (5 - 4.9) = 0.7 + 0.2 + 0.1 = 1.0 .

    Example 2:

    Input: prices = ["1.500","2.500","3.500"], target = 10
Output: "-1"
Explanation: 
It is impossible to meet the target.

     

    Note:

    
        1 <= prices.length <= 500.
        Each string of prices prices[i] represents a real number which is between 0
            and 1000 and has exactly 3 decimal places.
        
        target is between 0 and 1000000.
-----------------

# 1771_Maximize_Palindrome_Length_From_Subsequences
# 1771. Maximize Palindrome Length From Subsequences


-----------------

# 1014_Best_Sightseeing_Pair
# 1014. Best Sightseeing Pair

Given an array A of positive integers, A[i] represents the value of
        the i-th sightseeing spot, and two sightseeing spots i and
        j have distance j - i between them.

    The score of a pair (i < j) of sightseeing spots is (A[i]
        + A[j] + i - j) : the sum of the values of the sightseeing spots,
        minus the distance between them.

    Return the maximum score of a pair of sightseeing spots.

     

    Example 1:

    Input: [8,1,5,2,6]
Output: 11
Explanation: i = 0, j = 2, A[i] + A[j] + i - j = 8 + 5 + 0 - 2 = 11

     

    Note:

    
        2 <= A.length <= 50000
        1 <= A[i] <= 1000
-----------------

# 1329_Sort_the_Matrix_Diagonally
# 1329. Sort the Matrix Diagonally


-----------------

# 1629_Slowest_Key
# 1629. Slowest Key


-----------------

# 42_Trapping_Rain_Water
# 42. Trapping Rain Water

Given n non-negative integers representing an elevation map where the width of each
        bar is 1, compute how much water it is able to trap after raining.

    
        
        The above elevation map is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this
            case, 6 units of rain water (blue section) are being trapped. Thanks
                Marcos for contributing this image!
        
    

    Example:

    Input: [0,1,0,2,1,0,1,3,2,1,2,1]
Output: 6
-----------------

# 1830_Minimum_Number_of_Operations_to_Make_String_Sorted
# 1830. Minimum Number of Operations to Make String Sorted


-----------------

# 209_Minimum_Size_Subarray_Sum
# 209. Minimum Size Subarray Sum

Given an array of n positive integers and a positive integer
        s, find the minimal length of a contiguous subarray of which the sum
        ≥ s. If there isn't one, return 0 instead.

    Example: 

    Input: s = 7, nums = [2,3,1,2,4,3]
Output: 2
Explanation: the subarray [4,3] has the minimal length under the problem constraint.
-----------------

# 313_Super_Ugly_Number
# 313. Super Ugly Number

Write a program to find the nth super ugly number.

    Super ugly numbers are positive numbers whose all prime factors are in the given prime list
        primes of size k.

    Example:

    Input: n = 12, primes = [2,7,13,19]
Output: 32
Explanation: [1,2,4,7,8,13,14,16,19,26,28,32] is the sequence of the first 12
             super ugly numbers given primes = [2,7,13,19] of size 4.

    Note:

    
        1 is a super ugly number for any given primes.
        The given numbers in primes are in ascending order.
        0 < k ≤ 100, 0 < n ≤ 106, 0 < primes[i]
            < 1000.
        
        The nth super ugly number is guaranteed to fit in a 32-bit signed integer.
-----------------

# 982_Triples_with_Bitwise_AND_Equal_To_Zero
# 982. Triples with Bitwise AND Equal To Zero

Given an array of integers A, find the number of triples of indices (i, j,
        k) such that:

    
        0 <= i < A.length
        0 <= j < A.length
        0 <= k < A.length
        A[i] & A[j] & A[k] == 0, where & represents
            the bitwise-AND operator.
        
    

     

    Example 1:

    Input: [2,1,3]
Output: 12
Explanation: We could choose the following i, j, k triples:
(i=0, j=0, k=1) : 2 & 2 & 1
(i=0, j=1, k=0) : 2 & 1 & 2
(i=0, j=1, k=1) : 2 & 1 & 1
(i=0, j=1, k=2) : 2 & 1 & 3
(i=0, j=2, k=1) : 2 & 3 & 1
(i=1, j=0, k=0) : 1 & 2 & 2
(i=1, j=0, k=1) : 1 & 2 & 1
(i=1, j=0, k=2) : 1 & 2 & 3
(i=1, j=1, k=0) : 1 & 1 & 2
(i=1, j=2, k=0) : 1 & 3 & 2
(i=2, j=0, k=1) : 3 & 2 & 1
(i=2, j=1, k=0) : 3 & 1 & 2

     

    Note:

    
        1 <= A.length <= 1000
        0 <= A[i] < 2^16
-----------------

# 436_Find_Right_Interval
# 436. Find Right Interval

Given a set of intervals, for each of the interval i, check if there exists an interval j
        whose start point is bigger than or equal to the end point of the interval i, which can be
        called that j is on the "right" of i.

    For any interval i, you need to store the minimum interval j's index, which means that
        the interval j has the minimum start point to build the "right" relationship for
        interval i. If the interval j doesn't exist, store -1 for the interval i. Finally, you
        need output the stored value of each interval as an array.

    Note:

    
        You may assume the interval's end point is always bigger than its start point.
        You may assume none of these intervals have the same start point.
    

     

    Example 1:

    Input: [ [1,2] ]

Output: [-1]

Explanation: There is only one interval in the collection, so it outputs -1.

     

    Example 2:

    Input: [ [3,4], [2,3], [1,2] ]

Output: [-1, 0, 1]

Explanation: There is no satisfied "right" interval for [3,4].
For [2,3], the interval [3,4] has minimum-"right" start point;
For [1,2], the interval [2,3] has minimum-"right" start point.

     

    Example 3:

    Input: [ [1,4], [2,3], [3,4] ]

Output: [-1, 2, -1]

Explanation: There is no satisfied "right" interval for [1,4] and [3,4].
For [2,3], the interval [3,4] has minimum-"right" start point.

    NOTE: input types have been changed on April 15, 2019. Please reset to
        default code definition to get new method signature.
-----------------

# 211_Add_and_Search_Word_-_Data_structure_design
# 211. Add and Search Word - Data structure design

Design a data structure that supports the following two operations:

    void addWord(word)
bool search(word)

    search(word) can search a literal word or a regular expression string containing only letters
        a-z or .. A . means it can represent any one letter.
    

    Example:

    addWord("bad")
addWord("dad")
addWord("mad")
search("pad") -> false
search("bad") -> true
search(".ad") -> true
search("b..") -> true

    Note:
        You may assume that all words are consist of lowercase letters a-z.
-----------------

# 1576_Replace_All_'s_to_Avoid_Consecutive_Repeating_Characters
# 1576. Replace All ?'s to Avoid Consecutive Repeating Characters


-----------------

# 119_Pascal's_Triangle_II
# 119. Pascal's Triangle II

Given a non-negative index k where k ≤ 33, return the
        kth index row of the Pascal's triangle.

    Note that the row index starts from 0.

    
        In Pascal's triangle, each number is the sum of the two numbers directly above
            it.
        
    

    Example:

    Input: 3
Output: [1,3,3,1]

    Follow up:

    Could you optimize your algorithm to use only O(k) extra space?
-----------------

# 1548_The_Most_Similar_Path_in_a_Graph
# 1548. The Most Similar Path in a Graph


-----------------

# 214_Shortest_Palindrome
# 214. Shortest Palindrome

Given a string s, you are allowed to convert it to a palindrome by adding
        characters in front of it. Find and return the shortest palindrome you can find by
        performing this transformation.

    Example 1:

    Input: "aacecaaa"
Output: "aaacecaaa"

    Example 2:

    Input: "abcd"
Output: "dcbabcd"
-----------------

# 1756_Design_Most_Recently_Used_Queue
# 1756. Design Most Recently Used Queue


-----------------

# 682_Baseball_Game
# 682. Baseball Game

You're now a baseball game point recorder.
    

    
        Given a list of strings, each string can be one of the 4 following types:
    
        Integer (one round's score): Directly represents the number of points you
            get in this round.
        
        "+" (one round's score): Represents that the points you get in this round
            are the sum of the last two valid round's points.
        
        "D" (one round's score): Represents that the points you get in this round
            are the doubled data of the last valid round's points.
        
        "C" (an operation, which isn't a round's score): Represents the last valid
            round's points you get were invalid and should be removed.
        
    
    

    
        Each round's operation is permanent and could have an impact on the round before and the
        round after.
    

    
        You need to return the sum of the points you could get in all the rounds.
    

    Example 1:
    Input: ["5","2","C","D","+"]
Output: 30
Explanation:
Round 1: You could get 5 points. The sum is: 5.
Round 2: You could get 2 points. The sum is: 7.
Operation 1: The round 2's data was invalid. The sum is: 5.
Round 3: You could get 10 points (the round 2's data has been removed). The sum is: 15.
Round 4: You could get 5 + 10 = 15 points. The sum is: 30.

    

    Example 2:
    Input: ["5","-2","4","C","D","9","+","+"]
Output: 27
Explanation:
Round 1: You could get 5 points. The sum is: 5.
Round 2: You could get -2 points. The sum is: 3.
Round 3: You could get 4 points. The sum is: 7.
Operation 1: The round 3's data is invalid. The sum is: 3.
Round 4: You could get -4 points (the round 3's data has been removed). The sum is: -1.
Round 5: You could get 9 points. The sum is: 8.
Round 6: You could get -4 + 9 = 5 points. The sum is 13.
Round 7: You could get 9 + 5 = 14 points. The sum is 27.

    

    Note:
    The size of the input list will be between 1 and 1000.
    Every integer represented in the list will be between -30000 and 30000.
-----------------

# 813_Largest_Sum_of_Averages
# 813. Largest Sum of Averages

We partition a row of numbers A into at most K adjacent
        (non-empty) groups, then our score is the sum of the average of each group. What is the
        largest score we can achieve?

    Note that our partition must use every number in A, and that scores are not necessarily
        integers.

    Example:
Input:
A = [9,1,2,3,9]
K = 3
Output: 20
Explanation:
The best choice is to partition A into [9], [1, 2, 3], [9]. The answer is 9 + (1 + 2 + 3) / 3 + 9 = 20.
We could have also partitioned A into [9, 1], [2], [3, 9], for example.
That partition would lead to a score of 5 + 2 + 6 = 13, which is worse.

     

    Note: 

    
        1 <= A.length <= 100.
        1 <= A[i] <= 10000.
        1 <= K <= A.length.
        Answers within 10^-6 of the correct answer will be accepted as correct.
-----------------

# 897_Increasing_Order_Search_Tree
# 897. Increasing Order Search Tree

Given a binary search tree, rearrange the tree in in-order so that the
        leftmost node in the tree is now the root of the tree, and every node has no left child and
        only 1 right child.

    Example 1:
Input: [5,3,6,2,4,null,8,1,null,null,null,7,9]

       5
      / \
    3    6
   / \    \
  2   4    8
 /        / \
1        7   9

Output: [1,null,2,null,3,null,4,null,5,null,6,null,7,null,8,null,9]

 1
  \
   2
    \
     3
      \
       4
        \
         5
          \
           6
            \
             7
              \
               8
                \
                 9  

    Note:

    
        The number of nodes in the given tree will be between 1 and 100.
        Each node will have a unique integer value from 0 to 1000.
-----------------

# 572_Subtree_of_Another_Tree
# 572. Subtree of Another Tree

Given two non-empty binary trees s and t, check whether tree t has
        exactly the same structure and node values with a subtree of s. A subtree of s
        is a tree consists of a node in s and all of this node's descendants. The tree
        s could also be considered as a subtree of itself.
    

    Example 1:

        Given tree s:
         3
    / \
   4   5
  / \
 1   2

    Given tree t:
       4
  / \
 1   2

    Return true, because t has the same structure and node values with a subtree of s.
    

    Example 2:

        Given tree s:
         3
    / \
   4   5
  / \
 1   2
    /
   0

    Given tree t:
       4
  / \
 1   2

    Return false.
-----------------

# 1004_Max_Consecutive_Ones_III
# 1004. Max Consecutive Ones III

Given an array A of 0s and 1s, we may change up to K values
        from 0 to 1.

    Return the length of the longest (contiguous) subarray that contains only 1s.
-----------------

# 687_Longest_Univalue_Path
# 687. Longest Univalue Path

Given a binary tree, find the length of the longest path where each node in the path has the
        same value. This path may or may not pass through the root.

    The length of path between two nodes is represented by the number of edges between them.

     

    Example 1:

    Input:

                  5
             / \
            4   5
           / \   \
          1   1   5

    Output: 2

     

    Example 2:

    Input:

                  1
             / \
            4   5
           / \   \
          4   4   5

    Output: 2

     

    Note: The given binary tree has not more than 10000 nodes. The height of the tree is
        not more than 1000.
-----------------

# 1209_Remove_All_Adjacent_Duplicates_in_String_II
# 1209. Remove All Adjacent Duplicates in String II

Given a string s, a k duplicate removal consists
        of choosing k adjacent and equal letters from s and
        removing them causing the left and the right side of the deleted substring to
        concatenate together.

    We repeatedly make k duplicate removals on s until we no longer
        can.

    Return the final string after all such duplicate removals have been made.

    It is guaranteed that the answer is unique.

     
    Example 1:

    Input: s = "abcd", k = 2
Output: "abcd"
Explanation: There's nothing to delete.

    Example 2:

    Input: s = "deeedbbcccbdaa", k = 3
Output: "aa"
Explanation:
First delete "eee" and "ccc", get "ddbbbdaa"
Then delete "bbb", get "dddaa"
Finally delete "ddd", get "aa"

    Example 3:

    Input: s = "pbbcggttciiippooaais", k = 2
Output: "ps"

     
    Constraints:

    
        1 <= s.length <= 10^5
        2 <= k <= 10^4
        s only contains lower case English letters.
-----------------

# 159_Longest_Substring_with_At_Most_Two_Distinct_Characters
# 159. Longest Substring with At Most Two Distinct Characters

Given a string s , find the length of the longest
        substring t  that contains at
            most 2 distinct characters.

    Example 1:

    Input: "eceba"
Output: 3
Explanation: t is "ece" which its length is 3.

    Example 2:

    Input: "ccaabbb"
Output: 5
Explanation: t is "aabbb" which its length is 5.
-----------------

# 1525_Number_of_Good_Ways_to_Split_a_String
# 1525. Number of Good Ways to Split a String


-----------------

# 229_Majority_Element_II
# 229. Majority Element II

Given an integer array of size n, find all elements that appear more than ⌊
        n/3 ⌋ times.

    Note: The algorithm should run in linear time and in O(1) space.

    Example 1:

    Input: [3,2,3]
Output: [3]

    Example 2:

    Input: [1,1,1,3,3,2,2,2]
Output: [1,2]
-----------------

# 726_Number_of_Atoms
# 726. Number of Atoms

Given a chemical formula (given as a string), return the count of each atom.
    
    
        An atomic element always starts with an uppercase character, then zero or more lowercase
        letters, representing the name.
    
    
        1 or more digits representing the count of that element may follow if the count is greater
        than 1. If the count is 1, no digits will follow. For example, H2O and H2O2 are possible,
        but H1O2 is impossible.
    
    
        Two formulas concatenated together produce another formula. For example, H2O2He3Mg4 is also
        a formula.
    
    
        A formula placed in parentheses, and a count (optionally added) is also a formula. For
        example, (H2O2) and (H2O2)3 are formulas.
    
    
        Given a formula, output the count of all elements as a string in the following form: the
        first name (in sorted order), followed by its count (if that count is more than 1), followed
        by the second name (in sorted order), followed by its count (if that count is more than 1),
        and so on.

    Example 1:
    Input:
formula = "H2O"
Output: "H2O"
Explanation:
The count of elements are {'H': 2, 'O': 1}.

    

    Example 2:
    Input:
formula = "Mg(OH)2"
Output: "H2MgO2"
Explanation:
The count of elements are {'H': 2, 'Mg': 1, 'O': 2}.

    

    Example 3:
    Input:
formula = "K4(ON(SO3)2)2"
Output: "K4N2O14S4"
Explanation:
The count of elements are {'K': 4, 'N': 2, 'O': 14, 'S': 4}.

    

    Note:
    All atom names consist of lowercase letters, except for the first character which is
        uppercase.
    
    The length of formula will be in the range [1, 1000].
    formula will only consist of letters, digits, and round parentheses, and is a
        valid formula as defined in the problem.
-----------------

# 1260_Shift_2D_Grid
# 1260. Shift 2D Grid


-----------------

# 101_Symmetric_Tree
# 101. Symmetric Tree

Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its
        center).

    For example, this binary tree [1,2,2,3,4,4,3] is symmetric:

        1
   / \
  2   2
 / \ / \
3  4 4  3

     

    But the following [1,2,2,null,3,null,3] is not:

        1
   / \
  2   2
   \   \
   3    3

     

    Note:
        Bonus points if you could solve it both recursively and iteratively.
-----------------

# 1527_Patients_With_a_Condition
# 1527. Patients With a Condition


-----------------

# 7_Reverse_Integer
# 7. Reverse Integer

Given a 32-bit signed integer, reverse digits of an integer.

    Example 1:

    Input: 123
Output: 321

    Example 2:

    Input: -123
Output: -321

    Example 3:

    Input: 120
Output: 21

    Note:
        Assume we are dealing with an environment which could only store integers within the 32-bit
        signed integer range: [−231,  231 − 1]. For the
        purpose of this problem, assume that your function returns 0 when the reversed integer
        overflows.
-----------------

# 241_Different_Ways_to_Add_Parentheses
# 241. Different Ways to Add Parentheses

Given a string of numbers and operators, return all possible results from computing all the
        different possible ways to group numbers and operators. The valid operators are
        +, - and *.

    Example 1:

    Input: "2-1-1"
Output: [0, 2]
Explanation: 
((2-1)-1) = 0
(2-(1-1)) = 2

    Example 2:

    Input: "2*3-4*5"
Output: [-34, -14, -10, -10, 10]
Explanation:
(2*(3-(4*5))) = -34
((2*3)-(4*5)) = -14
((2*(3-4))*5) = -10
(2*((3-4)*5)) = -10
(((2*3)-4)*5) = 10
-----------------

# 344_Reverse_String
# 344. Reverse String

Write a function that reverses a string. The input string is given as an array of characters
        char[].

    Do not allocate extra space for another array, you must do this by modifying the
        input array in-place
        with O(1) extra memory.

    You may assume all the characters consist of printable
        ascii characters.
-----------------

# 1072_Flip_Columns_For_Maximum_Number_of_Equal_Rows
# 1072. Flip Columns For Maximum Number of Equal Rows

Given a matrix consisting of 0s and 1s, we may choose any number of columns in
        the matrix and flip every cell in that column.  Flipping a cell
        changes the value of that cell from 0 to 1 or from 1 to 0.

    Return the maximum number of rows that have all values equal after some number of flips.
-----------------

# 1461_Check_If_a_String_Contains_All_Binary_Codes_of_Size_K
# 1461. Check If a String Contains All Binary Codes of Size K


-----------------

# 699_Falling_Squares
# 699. Falling Squares

On an infinite number line (x-axis), we drop given squares in the order they are given.

    The i-th square dropped (positions[i] = (left, side_length)) is a
        square with the left-most point being positions[i][0] and sidelength positions[i][1].
    

    The square is dropped with the bottom edge parallel to the number line, and from a higher
        height than all currently landed squares. We wait for each square to stick before dropping
        the next.

    The squares are infinitely sticky on their bottom edge, and will remain fixed to any positive
        length surface they touch (either the number line or another square). Squares dropped
        adjacent to each other will not stick together prematurely.
     

    Return a list ans of heights. Each height ans[i] represents the
        current highest height of any square we have dropped, after dropping squares represented by
        positions[0], positions[1], ..., positions[i].

    Example 1:

    Input: [[1, 2], [2, 3], [6, 1]]
Output: [2, 5, 5]
Explanation:

    After the first drop of positions[0] = [1, 2]: _aa _aa ------- The maximum
        height of any square is 2.

    After the second drop of positions[1] = [2, 3]: __aaa __aaa __aaa _aa__ _aa__
        -------------- The maximum height of any square is 5. The larger square stays on top
        of the smaller square despite where its center of gravity is, because squares are infinitely
        sticky on their bottom edge.

    After the third drop of positions[1] = [6, 1]: __aaa __aaa __aaa _aa _aa___a
        -------------- The maximum height of any square is still 5. Thus, we return an answer
        of [2, 5, 5].

     
     

    Example 2:

    Input: [[100, 100], [200, 100]]
Output: [100, 100]
Explanation: Adjacent squares don't get stuck prematurely - only their bottom edge can stick to surfaces.

     

    Note:

    
        1 <= positions.length <= 1000.
        1 <= positions[i][0] <= 10^8.
        1 <= positions[i][1] <= 10^6.
-----------------

# 1379_Find_a_Corresponding_Node_of_a_Binary_Tree_in_a_Clone_of_That_Tree
# 1379. Find a Corresponding Node of a Binary Tree in a Clone of That Tree


-----------------

# 1409_Queries_on_a_Permutation_With_Key
# 1409. Queries on a Permutation With Key


-----------------

# 502_IPO
# 502. IPO

Suppose LeetCode will start its IPO soon. In order to sell a good price of its shares to
        Venture Capital, LeetCode would like to work on some projects to increase its capital before
        the IPO. Since it has limited resources, it can only finish at most k distinct
        projects before the IPO. Help LeetCode design the best way to maximize its total capital
        after finishing at most k distinct projects.
    

    
        You are given several projects. For each project i, it has a pure profit
        Pi and a minimum capital of Ci is needed to start the
        corresponding project. Initially, you have W capital. When you finish a project, you
        will obtain its pure profit and the profit will be added to your total capital.
    

    
        To sum up, pick a list of at most k distinct projects from given projects to maximize
        your final capital, and output your final maximized capital.
    

    Example 1:
    Input: k=2, W=0, Profits=[1,2,3], Capital=[0,1,1].

Output: 4

Explanation: Since your initial capital is 0, you can only start the project indexed 0.
             After finishing it you will obtain profit 1 and your capital becomes 1.
             With capital 1, you can either start the project indexed 1 or the project indexed 2.
             Since you can choose at most 2 projects, you need to finish the project indexed 2 to get the maximum capital.
             Therefore, output the final maximized capital, which is 0 + 1 + 3 = 4.

    

    Note:
    
        You may assume all numbers in the input are non-negative integers.
        The length of Profits array and Capital array will not exceed 50,000.
        The answer is guaranteed to fit in a 32-bit signed integer.
-----------------

# 353_Design_Snake_Game
# 353. Design Snake Game

Design a Snake
        game that is played on a device with screen size = width x height. Play the game online if you
        are not familiar with the game.

    The snake is initially positioned at the top left corner (0,0) with length = 1 unit.

    You are given a list of food's positions in row-column order. When a snake eats the food,
        its length and the game's score both increase by 1.

    Each food appears one by one on the screen. For example, the second food will not appear
        until the first food was eaten by the snake.

    When a food does appear on the screen, it is guaranteed that it will not appear on a block
        occupied by the snake.

    Example:

    Given width = 3, height = 2, and food = [[1,2],[0,1]].

Snake snake = new Snake(width, height, food);

Initially the snake appears at position (0,0) and the food at (1,2).

|S| | |
| | |F|

snake.move("R"); -> Returns 0

| |S| |
| | |F|

snake.move("D"); -> Returns 0

| | | |
| |S|F|

snake.move("R"); -> Returns 1 (Snake eats the first food and right after that, the second food appears at (0,1) )

| |F| |
| |S|S|

snake.move("U"); -> Returns 1

| |F|S|
| | |S|

snake.move("L"); -> Returns 2 (Snake eats the second food)

| |S|S|
| | |S|

snake.move("U"); -> Returns -1 (Game over because snake collides with border)
-----------------

# 880_Decoded_String_at_Index
# 880. Decoded String at Index

An encoded string S is given.  To find and write the decoded
        string to a tape, the encoded string is read one character at a time and
        the following steps are taken:

    
        If the character read is a letter, that letter is written onto the tape.
        If the character read is a digit (say d), the entire current tape is
            repeatedly written d-1 more times in total.
        
    

    Now for some encoded string S, and an index K, find and return the
        K-th letter (1 indexed) in the decoded string.
-----------------

# 940_Distinct_Subsequences_II
# 940. Distinct Subsequences II

Given a string S, count the number of distinct, non-empty subsequences of S
        .

    Since the result may be large, return the answer modulo 10^9 +
        7.

     

    Example 1:

    Input: "abc"
Output: 7
Explanation: The 7 distinct subsequences are "a", "b", "c", "ab", "ac", "bc", and "abc".
-----------------

# 1705_Maximum_Number_of_Eaten_Apples
# 1705. Maximum Number of Eaten Apples


-----------------

# 233_Number_of_Digit_One
# 233. Number of Digit One

Given an integer n, count the total number of digit 1 appearing in all non-negative integers
        less than or equal to n.

    Example:

    Input: 13
Output: 6
Explanation: Digit 1 occurred in the following numbers: 1, 10, 11, 12, 13.
-----------------

# 592_Fraction_Addition_and_Subtraction
# 592. Fraction Addition and Subtraction

Given a string representing an expression of fraction addition and subtraction, you need to
        return the calculation result in string format. The final result should be irreducible fraction.
        If your final result is an integer, say 2, you need to change it to the format
        of fraction that has denominator 1. So in this case, 2 should be
        converted to 2/1.

    Example 1:
    Input:"-1/2+1/2"
Output: "0/1"

    

    Example 2:
    Input:"-1/2+1/2+1/3"
Output: "1/3"

    

    Example 3:
    Input:"1/3-1/2"
Output: "-1/6"

    

    Example 4:
    Input:"5/3+1/3"
Output: "2/1"

    

    Note:
    
        The input string only contains '0' to '9', '/',
            '+' and '-'. So does the output.
        
        Each fraction (input and output) has format ±numerator/denominator. If the
            first input fraction or the output is positive, then '+' will be omitted.
        
        The input only contains valid irreducible fractions, where the numerator
            and denominator of each fraction will always be in the range [1,10]. If the
            denominator is 1, it means this fraction is actually an integer in a fraction format
            defined above.
        
        The number of given fractions will be in the range [1,10].
        The numerator and denominator of the final result are guaranteed to be valid and
            in the range of 32-bit int.
-----------------

# 1155_Number_of_Dice_Rolls_With_Target_Sum
# 1155. Number of Dice Rolls With Target Sum

You have d dice, and each die has f faces numbered 1, 2, ...,
        f.

    Return the number of possible ways (out of fd total ways)
        modulo 10^9 + 7 to roll the dice so the sum of the face up
        numbers equals target.

     
    Example 1:

    Input: d = 1, f = 6, target = 3
Output: 1
Explanation: 
You throw one die with 6 faces.  There is only one way to get a sum of 3.

    Example 2:

    Input: d = 2, f = 6, target = 7
Output: 6
Explanation: 
You throw two dice, each with 6 faces.  There are 6 ways to get a sum of 7:
1+6, 2+5, 3+4, 4+3, 5+2, 6+1.

    Example 3:

    Input: d = 2, f = 5, target = 10
Output: 1
Explanation: 
You throw two dice, each with 5 faces.  There is only one way to get a sum of 10: 5+5.

    Example 4:

    Input: d = 1, f = 2, target = 3
Output: 0
Explanation: 
You throw one die with 2 faces.  There is no way to get a sum of 3.

    Example 5:

    Input: d = 30, f = 30, target = 500
Output: 222616187
Explanation: 
The answer must be returned modulo 10^9 + 7.

     
    Constraints:

    
        1 <= d, f <= 30
        1 <= target <= 1000
-----------------

# 1181_Before_and_After_Puzzle
# 1181. Before and After Puzzle

Given a list of phrases, generate a list of Before and After puzzles.

    A phrase is a string that consists of lowercase English letters and spaces only. No
        space appears in the start or the end of a phrase. There are no consecutive spaces in
        a phrase.

    Before and After puzzles are phrases that are formed by merging two
        phrases where the last word of the first phrase is the same as
        the first word of the second phrase.

    Return the Before and After puzzles that can be formed by every two
        phrases phrases[i] and phrases[j] where i
            != j. Note that the order of matching two phrases matters, we want to consider
        both orders.

    You should return a list of distinct strings sorted lexicographically.
    

     
    Example 1:

    Input: phrases = ["writing code","code rocks"]
Output: ["writing code rocks"]

    Example 2:

    Input: phrases = ["mission statement",
                  "a quick bite to eat",
                  "a chip off the old block",
                  "chocolate bar",
                  "mission impossible",
                  "a man on a mission",
                  "block party",
                  "eat my words",
                  "bar of soap"]
Output: ["a chip off the old block party",
         "a man on a mission impossible",
         "a man on a mission statement",
         "a quick bite to eat my words",
         "chocolate bar of soap"]

    Example 3:

    Input: phrases = ["a","b","a"]
Output: ["a"]

     
    Constraints:

    
        1 <= phrases.length <= 100
        1 <= phrases[i].length <= 100
-----------------

# 1481_Least_Number_of_Unique_Integers_after_K_Removals
# 1481. Least Number of Unique Integers after K Removals


-----------------

# 420_Strong_Password_Checker
# 420. Strong Password Checker

A password is considered strong if below conditions are all met:

    
         It has at least 6 characters and at most 20 characters.
         It must contain at least one lowercase letter, at least one uppercase letter, and at
            least one digit.
        
         It must NOT contain three repeating characters in a row ("...aaa..." is weak, but
            "...aa...a..." is strong, assuming other conditions are met).
        
    

    Write a function strongPasswordChecker(s), that takes a string s as input, and return the MINIMUM
        change required to make s a strong password. If s is already strong, return 0.

    Insertion, deletion or replace of any one character are all considered as one change.
-----------------

# 1835_Find_XOR_Sum_of_All_Pairs_Bitwise_AND
# 1835. Find XOR Sum of All Pairs Bitwise AND


-----------------

# 1097_Game_Play_Analysis_V
# 1097. Game Play Analysis V

Table: Activity

    +--------------+---------+
| Column Name  | Type    |
+--------------+---------+
| player_id    | int     |
| device_id    | int     |
| event_date   | date    |
| games_played | int     |
+--------------+---------+
(player_id, event_date) is the primary key of this table.
This table shows the activity of players of some game.
Each row is a record of a player who logged in and played a number of games (possibly 0) before logging out on some day using some device.

     

    We define the install date of a player to be the first login day of that player.

    We also define day 1 retention of some date X to be the
        number of players whose install date is X and they logged back
        in on the day right after X, divided by the number of players whose install
        date is X, rounded to 2 decimal places.

    Write an SQL query that reports for each install date, the number of
        players that installed the game on that day and the day 1
        retention.

    The query result format is in the following example:

    Activity table:
+-----------+-----------+------------+--------------+
| player_id | device_id | event_date | games_played |
+-----------+-----------+------------+--------------+
| 1         | 2         | 2016-03-01 | 5            |
| 1         | 2         | 2016-03-02 | 6            |
| 2         | 3         | 2017-06-25 | 1            |
| 3         | 1         | 2016-03-01 | 0            |
| 3         | 4         | 2016-07-03 | 5            |
+-----------+-----------+------------+--------------+

Result table:
+------------+----------+----------------+
| install_dt | installs | Day1_retention |
+------------+----------+----------------+
| 2016-03-01 | 2        | 0.50           |
| 2017-06-25 | 1        | 0.00           |
+------------+----------+----------------+
Player 1 and 3 installed the game on 2016-03-01 but only player 1 logged back in on 2016-03-02 so the day 1 retention of 2016-03-01 is 1 / 2 = 0.50
Player 2 installed the game on 2017-06-25 but didn't log back in on 2017-06-26 so the day 1 retention of 2017-06-25 is 0 / 1 = 0.00
-----------------

# 1857_Largest_Color_Value_in_a_Directed_Graph
# 1857. Largest Color Value in a Directed Graph


-----------------

# 1768_Merge_Strings_Alternately
# 1768. Merge Strings Alternately


-----------------

# 272_Closest_Binary_Search_Tree_Value_II
# 272. Closest Binary Search Tree Value II

Given a non-empty binary search tree and a target value, find k values in the BST that
        are closest to the target.

    Note:

    
        Given target value is a floating point.
        You may assume k is always valid, that is: k ≤ total nodes.
        You are guaranteed to have only one unique set of k values in the BST that are
            closest to the target.
        
    

    Example:

    Input: root = [4,2,5,1,3], target = 3.714286, and k = 2

    4
   / \
  2   5
 / \
1   3

Output: [4,3]

    Follow up:
        Assume that the BST is balanced, could you solve it in less than O(n) runtime
        (where n = total nodes)?
-----------------

# 1266_Minimum_Time_Visiting_All_Points
# 1266. Minimum Time Visiting All Points


-----------------

# 1258_Synonymous_Sentences
# 1258. Synonymous Sentences


-----------------

# 257_Binary_Tree_Paths
# 257. Binary Tree Paths

Given a binary tree, return all root-to-leaf paths.

    Note: A leaf is a node with no children.

    Example:

    Input:

   1
 /   \
2     3
 \
  5

Output: ["1->2->5", "1->3"]

Explanation: All root-to-leaf paths are: 1->2->5, 1->3
-----------------

# 21_Merge_Two_Sorted_Lists
# 21. Merge Two Sorted Lists

Merge two sorted linked lists and return it as a new list. The new list should be made by
        splicing together the nodes of the first two lists.

    Example:
    Input: 1->2->4, 1->3->4
Output: 1->1->2->3->4->4
-----------------

# 523_Continuous_Subarray_Sum
# 523. Continuous Subarray Sum

Given a list of non-negative numbers and a target integer k, write a function
        to check if the array has a continuous subarray of size at least 2 that sums up to a
        multiple of k, that is, sums up to n*k where n is also an integer.

     

    Example 1:

    Input: [23, 2, 4, 6, 7],  k=6
Output: True
Explanation: Because [2, 4] is a continuous subarray of size 2 and sums up to 6.

    Example 2:

    Input: [23, 2, 6, 4, 7],  k=6
Output: True
Explanation: Because [23, 2, 6, 4, 7] is an continuous subarray of size 5 and sums up to 42.

     

    Note:

    
        The length of the array won't exceed 10,000.
        You may assume the sum of all the numbers is in the range of a signed 32-bit integer.
-----------------

# 569_Median_Employee_Salary
# 569. Median Employee Salary

The Employee table holds all employees. The employee table has three columns:
        Employee Id, Company Name, and Salary.

    +-----+------------+--------+
|Id   | Company    | Salary |
+-----+------------+--------+
|1    | A          | 2341   |
|2    | A          | 341    |
|3    | A          | 15     |
|4    | A          | 15314  |
|5    | A          | 451    |
|6    | A          | 513    |
|7    | B          | 15     |
|8    | B          | 13     |
|9    | B          | 1154   |
|10   | B          | 1345   |
|11   | B          | 1221   |
|12   | B          | 234    |
|13   | C          | 2345   |
|14   | C          | 2645   |
|15   | C          | 2645   |
|16   | C          | 2652   |
|17   | C          | 65     |
+-----+------------+--------+

    Write a SQL query to find the median salary of each company. Bonus points if you can solve it
        without using any built-in SQL functions.

    +-----+------------+--------+
|Id   | Company    | Salary |
+-----+------------+--------+
|5    | A          | 451    |
|6    | A          | 513    |
|12   | B          | 234    |
|9    | B          | 1154   |
|14   | C          | 2645   |
+-----+------------+--------+
-----------------

# 1330_Reverse_Subarray_To_Maximize_Array_Value
# 1330. Reverse Subarray To Maximize Array Value


-----------------

# 1848_Minimum_Distance_to_the_Target_Element
# 1848. Minimum Distance to the Target Element


-----------------

# 856_Score_of_Parentheses
# 856. Score of Parentheses

Given a balanced parentheses string S, compute the score of the string based on
        the following rule:

    
        () has score 1
        AB has score A + B, where A and B are balanced parentheses
            strings.
        
        (A) has score 2 * A, where A is a balanced parentheses string.
-----------------

# 1471_The_k_Strongest_Values_in_an_Array
# 1471. The k Strongest Values in an Array


-----------------

# 748_Shortest_Completing_Word
# 748. Shortest Completing Word

Find the minimum length word from a given dictionary words, which has all the
        letters from the string licensePlate. Such a word is said to complete
        the given string licensePlate
    
    
        Here, for letters we ignore case. For example, "P" on the
        licensePlate still matches "p" on the word.
    
    
        It is guaranteed an answer exists. If there are multiple answers, return the one that occurs
        first in the array.
    
    
        The license plate might have the same letter occurring multiple times. For example, given a
        licensePlate of "PP", the word "pair" does not
        complete the licensePlate, but the word "supper" does.
    
    

    Example 1:
    Input: licensePlate = "1s3 PSt", words = ["step", "steps", "stripe", "stepple"]
Output: "steps"
Explanation: The smallest length word that contains the letters "S", "P", "S", and "T".
Note that the answer is not "step", because the letter "s" must occur in the word twice.
Also note that we ignored case for the purposes of comparing whether a letter exists in the word.

    

    Example 2:
    Input: licensePlate = "1s3 456", words = ["looks", "pest", "stew", "show"]
Output: "pest"
Explanation: There are 3 smallest length words that contains the letters "s".
We return the one that occurred first.

    

    Note:
    
        licensePlate will be a string with length in range [1, 7].
        
        licensePlate will contain digits, spaces, or letters (uppercase or
            lowercase).
        
        words will have a length in the range [10, 1000].
        Every words[i] will consist of lowercase letters, and have length in range
            [1, 15].
-----------------

# 1817_Finding_the_Users_Active_Minutes
# 1817. Finding the Users Active Minutes


-----------------

# 801_Minimum_Swaps_To_Make_Sequences_Increasing
# 801. Minimum Swaps To Make Sequences Increasing

We have two integer sequences A and B of the same non-zero length.
    

    We are allowed to swap elements A[i] and B[i].  Note that both
        elements are in the same index position in their respective sequences.

    At the end of some number of swaps, A and B are both strictly
        increasing.  (A sequence is strictly increasing if and only if A[0] <
            A[1] < A[2] < ... < A[A.length - 1].)

    Given A and B, return the minimum number of swaps to make both sequences strictly increasing. 
        It is guaranteed that the given input always makes it possible.

    Example:
Input: A = [1,3,5,4], B = [1,2,3,7]
Output: 1
Explanation: 
Swap A[3] and B[3].  Then the sequences are:
A = [1, 3, 5, 7] and B = [1, 2, 3, 4]
which are both strictly increasing.

    Note:

    
        A, B are arrays with the same length, and that length will be in the range
            [1, 1000].
        
        A[i], B[i] are integer values in the range [0, 2000].
-----------------

# 1438_Longest_Continuous_Subarray_With_Absolute_Diff_Less_Than_or_Equal_to_Limit
# 1438. Longest Continuous Subarray With Absolute Diff Less Than or Equal to Limit


-----------------

# 1285_Find_the_Start_and_End_Number_of_Continuous_Ranges
# 1285. Find the Start and End Number of Continuous Ranges


-----------------

# 850_Rectangle_Area_II
# 850. Rectangle Area II

We are given a list of (axis-aligned) rectangles.  Each rectangle[i]
        = [x1, y1, x2, y2] , where (x1, y1) are the coordinates of the bottom-left
        corner, and (x2, y2) are the coordinates of the top-right corner of the ith
        rectangle.

    Find the total area covered by all rectangles in the plane.  Since the
        answer may be too large, return it modulo 10^9 + 7.

    

    Example 1:

    Input: [[0,0,2,2],[1,0,2,3],[1,0,3,1]]
Output: 6
Explanation: As illustrated in the picture.

    Example 2:

    Input: [[0,0,1000000000,1000000000]]
Output: 49
Explanation: The answer is 10^18 modulo (10^9 + 7), which is (10^9)^2 = (-7)^2 = 49.

    Note:

    
        1 <= rectangles.length <= 200
        rectanges[i].length = 4
        0 <= rectangles[i][j] <= 10^9
        The total area covered by all rectangles will never exceed 2^63 - 1 and
            thus will fit in a 64-bit signed integer.
-----------------

# 57_Insert_Interval
# 57. Insert Interval

Given a set of non-overlapping intervals, insert a new interval into the intervals
        (merge if necessary).

    You may assume that the intervals were initially sorted according to their start times.

    Example 1:

    Input: intervals = [[1,3],[6,9]], newInterval = [2,5]
Output: [[1,5],[6,9]]

    Example 2:

    Input: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]
Output: [[1,2],[3,10],[12,16]]
Explanation: Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10].

    NOTE: input types have been changed on April 15, 2019. Please reset to
        default code definition to get new method signature.
-----------------

# 112_Path_Sum
# 112. Path Sum

Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding
        up all the values along the path equals the given sum.

    Note: A leaf is a node with no children.

    Example:

    Given the below binary tree and sum = 22,

          5
     / \
    4   8
   /   / \
  11  13  4
 /  \      \
7    2      1

    return true, as there exist a root-to-leaf path 5->4->11->2 which sum
        is 22.
-----------------

# 1446_Consecutive_Characters
# 1446. Consecutive Characters


-----------------

# 1060_Missing_Element_in_Sorted_Array
# 1060. Missing Element in Sorted Array

Given a sorted array A of unique numbers, find the
        K-th missing number starting from the leftmost number of the array.
    

     

    Example 1:

    Input: A = [4,7,9,10], K = 1
Output: 5
Explanation: 
The first missing number is 5.

    Example 2:

    Input: A = [4,7,9,10], K = 3
Output: 8
Explanation: 
The missing numbers are [5,6,8,...], hence the third missing number is 8.

    Example 3:

    Input: A = [1,2,4], K = 3
Output: 6
Explanation: 
The missing numbers are [3,5,6,7,...], hence the third missing number is 6.

     

    Note:

    
        1 <= A.length <= 50000
        1 <= A[i] <= 1e7
        1 <= K <= 1e8
-----------------

# 834_Sum_of_Distances_in_Tree
# 834. Sum of Distances in Tree

An undirected, connected tree with N nodes labelled 0...N-1
        and N-1 edges are given.

    The ith edge connects nodes edges[i][0] and edges[i][1] together.
    

    Return a list ans, where ans[i] is the sum of the distances between
        node i and all other nodes.

    Example 1:

    Input: N = 6, edges = [[0,1],[0,2],[2,3],[2,4],[2,5]]
Output: [8,12,6,10,10,10]
Explanation: 
Here is a diagram of the given tree:
  0
 / \
1   2
   /|\
  3 4 5
We can see that dist(0,1) + dist(0,2) + dist(0,3) + dist(0,4) + dist(0,5)
equals 1 + 1 + 2 + 2 + 2 = 8.  Hence, answer[0] = 8, and so on.

    Note: 1 <= N <= 10000
-----------------

# 653_Two_Sum_IV_-_Input_is_a_BST
# 653. Two Sum IV - Input is a BST

Given a Binary Search Tree and a target number, return true if there exist two elements in
        the BST such that their sum is equal to the given target.

    Example 1:

    Input:
    5
   / \
  3   6
 / \   \
2   4   7

Target = 9

Output: True

     

    Example 2:

    Input:
    5
   / \
  3   6
 / \   \
2   4   7

Target = 28

Output: False
-----------------

# 664_Strange_Printer
# 664. Strange Printer

There is a strange printer with the following two special requirements:

    
        The printer can only print a sequence of the same character each time.
        At each turn, the printer can print new characters starting from and ending at any
            places, and will cover the original existing characters.
        
    

    

    
        Given a string consists of lower English letters only, your job is to count the minimum
        number of turns the printer needed in order to print it.
    

    Example 1:
    Input: "aaabbb"
Output: 2
Explanation: Print "aaa" first and then print "bbb".

    

    Example 2:
    Input: "aba"
Output: 2
Explanation: Print "aaa" first and then print "b" from the second place of the string, which will cover the existing character 'a'.

    

    Hint: Length of the given string will not exceed 100.
-----------------

# 1375_Bulb_Switcher_III
# 1375. Bulb Switcher III


-----------------

# 1408_String_Matching_in_an_Array
# 1408. String Matching in an Array


-----------------

# 1166_Design_File_System
# 1166. Design File System

You are asked to design a file system which provides two functions:

    
        createPath(path, value): Creates a new path and associates a value
            to it if possible and returns True. Returns False if
            the path already exists or its parent path doesn't exist.
        
        get(path): Returns the value associated with a path or returns -1 if
            the path doesn't exist.
        
    

    The format of a path is one or more concatenated strings of the
        form: / followed by one or more lowercase English letters. For example,
        /leetcode and /leetcode/problems are valid paths while
        an empty string and / are not.

    Implement the two functions.

    Please refer to the examples for clarifications.

     
    Example 1:

    Input:
["FileSystem","createPath","get"]
[[],["/a",1],["/a"]]
Output:
[null,true,1]
Explanation:
FileSystem fileSystem = new FileSystem();

fileSystem.createPath("/a", 1); // return true
fileSystem.get("/a"); // return 1

    Example 2:

    Input:
["FileSystem","createPath","createPath","get","createPath","get"]
[[],["/leet",1],["/leet/code",2],["/leet/code"],["/c/d",1],["/c"]]
Output:
[null,true,true,2,false,-1]
Explanation:
FileSystem fileSystem = new FileSystem();

fileSystem.createPath("/leet", 1); // return true
fileSystem.createPath("/leet/code", 2); // return true
fileSystem.get("/leet/code"); // return 2
fileSystem.createPath("/c/d", 1); // return false because the parent path "/c" doesn't exist.
fileSystem.get("/c"); // return -1 because this path doesn't exist.

     
    Constraints:

    
        The number of calls to the two functions is less than or equal to
            10^4 in total.
        
        2 <= path.length <= 100
        1 <= value <= 10^9
    

    NOTE: create method has been changed on August 29, 2019 to
        createPath. Please reset to default code definition to get new method signature.
-----------------

# 299_Bulls_and_Cows
# 299. Bulls and Cows

You are playing the following Bulls and Cows game with your friend:
        You write down a number and ask your friend to guess what the number is. Each time your
        friend makes a guess, you provide a hint that indicates how many digits in said guess match
        your secret number exactly in both digit and position (called "bulls") and how
        many digits match the secret number but locate in the wrong position (called "cows").
        Your friend will use successive guesses and hints to eventually derive the secret number.
    

    Write a function to return a hint according to the secret number and friend's guess, use
        A to indicate the bulls and B to indicate the cows. 

    Please note that both secret number and friend's guess may contain duplicate digits.

    Example 1:

    Input: secret = "1807", guess = "7810"

Output: "1A3B"

Explanation: 1 bull and 3 cows. The bull is 8, the cows are 0, 1 and 7.

    Example 2:

    Input: secret = "1123", guess = "0111"

Output: "1A1B"

Explanation: The 1st 1 in friend's guess is a bull, the 2nd or 3rd 1 is a cow.

    Note: You may assume that the secret number and your friend's guess only
        contain digits, and their lengths are always equal.
-----------------

# 586_Customer_Placing_the_Largest_Number_of_Orders
# 586. Customer Placing the Largest Number of Orders

Query the customer_number from the orders table for the customer who has
        placed the largest number of orders.

    It is guaranteed that exactly one customer will have placed more orders than any other
        customer.

    The orders table is defined as follows:

    | Column            | Type      |
|-------------------|-----------|
| order_number (PK) | int       |
| customer_number   | int       |
| order_date        | date      |
| required_date     | date      |
| shipped_date      | date      |
| status            | char(15)  |
| comment           | char(200) |

    Sample Input

    | order_number | customer_number | order_date | required_date | shipped_date | status | comment |
|--------------|-----------------|------------|---------------|--------------|--------|---------|
| 1            | 1               | 2017-04-09 | 2017-04-13    | 2017-04-12   | Closed |         |
| 2            | 2               | 2017-04-15 | 2017-04-20    | 2017-04-18   | Closed |         |
| 3            | 3               | 2017-04-16 | 2017-04-25    | 2017-04-20   | Closed |         |
| 4            | 3               | 2017-04-18 | 2017-04-28    | 2017-04-25   | Closed |         |

    Sample Output

    | customer_number |
|-----------------|
| 3               |

    Explanation

    The customer with number '3' has two orders, which is greater than either customer '1' or '2' because each of them  only has one order.
So the result is customer_number '3'.

    Follow up: What if more than one customer have the largest number of orders, can
        you find all the customer_number in this case?
-----------------

# 1589_Maximum_Sum_Obtained_of_Any_Permutation
# 1589. Maximum Sum Obtained of Any Permutation


-----------------

# 703_Kth_Largest_Element_in_a_Stream
# 703. Kth Largest Element in a Stream

Design a class to find the kth largest element in a stream. Note that
        it is the kth largest element in the sorted order, not the kth distinct element.

    Your KthLargest class will have a constructor which accepts an integer
        k and an integer array nums, which contains initial elements from the
        stream. For each call to the method KthLargest.add, return the element
        representing the kth largest element in the stream.

    Example:

    int k = 3;
int[] arr = [4,5,8,2];
KthLargest kthLargest = new KthLargest(3, arr);
kthLargest.add(3);   // returns 4
kthLargest.add(5);   // returns 5
kthLargest.add(10);  // returns 5
kthLargest.add(9);   // returns 8
kthLargest.add(4);   // returns 8

    Note: 
        You may assume that nums' length ≥ k-1 and
        k ≥ 1.
-----------------

# 1753_Maximum_Score_From_Removing_Stones
# 1753. Maximum Score From Removing Stones


-----------------

# 979_Distribute_Coins_in_Binary_Tree
# 979. Distribute Coins in Binary Tree

Given the root of a binary tree with N nodes, each
        node in the tree has node.val coins, and there are
        N coins total.

    In one move, we may choose two adjacent nodes and move one coin from one node to another. 
        (The move may be from parent to child, or from child to parent.)

    Return the number of moves required to make every node have exactly one coin.
-----------------

# 1454_Active_Users
# 1454. Active Users


-----------------

# 819_Most_Common_Word
# 819. Most Common Word

Given a paragraph and a list of banned words, return the most frequent word that is not
        in the list of banned words.  It is guaranteed there is at least one word that isn't
        banned, and that the answer is unique.

    Words in the list of banned words are given in lowercase, and free of punctuation. 
        Words in the paragraph are not case sensitive.  The answer is in lowercase.

     

    Example:

    Input:
paragraph = "Bob hit a ball, the hit BALL flew far after it was hit."
banned = ["hit"]
Output: "ball"
Explanation:
"hit" occurs 3 times, but it is a banned word.
"ball" occurs twice (and no other word does), so it is the most frequent non-banned word in the paragraph.
Note that words in the paragraph are not case sensitive,
that punctuation is ignored (even if adjacent to words, such as "ball,"),
and that "hit" isn't the answer even though it occurs more because it is banned.

     

    Note: 

    
        1 <= paragraph.length <= 1000.
        0 <= banned.length <= 100.
        1 <= banned[i].length <= 10.
        The answer is unique, and written in lowercase (even if its occurrences in paragraph may
            have uppercase symbols, and even if it is a proper noun.)
        
        paragraph only consists of letters, spaces, or the punctuation symbols
            !?',;.
        There are no hyphens or hyphenated words.
        Words only consist of letters, never apostrophes or other punctuation symbols.
-----------------

# 1276_Number_of_Burgers_with_No_Waste_of_Ingredients
# 1276. Number of Burgers with No Waste of Ingredients


-----------------

# 77_Combinations
# 77. Combinations

Given two integers n and k, return all possible combinations of k
        numbers out of 1 ... n.

    Example:

    Input: n = 4, k = 2
Output:
[
  [2,4],
  [3,4],
  [2,3],
  [1,2],
  [1,3],
  [1,4],
]
-----------------

# 413_Arithmetic_Slices
# 413. Arithmetic Slices

A sequence of number is called arithmetic if it consists of at least three elements and if
        the difference between any two consecutive elements is the same.

    For example, these are arithmetic sequence:
    1, 3, 5, 7, 9
7, 7, 7, 7
3, -1, -5, -9

    The following sequence is not arithmetic.
    1, 1, 2, 5, 7
    

    A zero-indexed array A consisting of N numbers is given. A slice of that array is any pair of
        integers (P, Q) such that 0 <= P < Q < N.

    A slice (P, Q) of array A is called arithmetic if the sequence:
        A[P], A[p + 1], ..., A[Q - 1], A[Q] is arithmetic. In particular, this means that P + 1 < Q.
    

    The function should return the number of arithmetic slices in the array A. 
    

    Example:
    A = [1, 2, 3, 4]

return: 3, for 3 arithmetic slices in A: [1, 2, 3], [2, 3, 4] and [1, 2, 3, 4] itself.
-----------------

# 707_Design_Linked_List
# 707. Design Linked List

Design your implementation of the linked list. You can choose to use the singly linked
        list or the doubly linked list. A node in a singly linked list should have two
        attributes: val and next. val is the value of
        the current node, and next is a pointer/reference to the next
        node. If you want to use the doubly linked list, you will need one more attribute
        prev to indicate the previous node in the linked list. Assume all nodes in the
        linked list are 0-indexed.

    Implement these functions in your linked list class:

    
        get(index) : Get the value of the index-th node in the linked
            list. If the index is invalid, return -1.
        
        addAtHead(val) : Add a node of value val before the first element of
            the linked list. After the insertion, the new node will be the first node of the linked
            list.
        
        addAtTail(val) : Append a node of value val to the last element of the
            linked list.
        
        addAtIndex(index, val) : Add a node of value val before the index-th node
            in the linked list. If index equals to the length of linked
            list, the node will be appended to the end of linked list. If index is greater than the
            length, the node will not be inserted. If index is negative, the node will be inserted
            at the head of the list.
        
        deleteAtIndex(index) : Delete the index-th node in the linked
            list, if the index is valid.
        
    

    Example:

    MyLinkedList linkedList = new MyLinkedList();
linkedList.addAtHead(1);
linkedList.addAtTail(3);
linkedList.addAtIndex(1, 2);  // linked list becomes 1->2->3
linkedList.get(1);            // returns 2
linkedList.deleteAtIndex(1);  // now the linked list is 1->3
linkedList.get(1);            // returns 3

    Note:

    
        All values will be in the range of [1, 1000].
        The number of operations will be in the range of [1, 1000].
        Please do not use the built-in LinkedList library.
-----------------

# 1813_Sentence_Similarity_III
# 1813. Sentence Similarity III


-----------------

# 151_Reverse_Words_in_a_String
# 151. Reverse Words in a String

Given an input string, reverse the string word by word.

     

    Example 1:

    Input: "the sky is blue"
Output: "blue is sky the"

    Example 2:

    Input: "  hello world!  "
Output: "world! hello"
Explanation: Your reversed string should not contain leading or trailing spaces.

    Example 3:

    Input: "a good   example"
Output: "example good a"
Explanation: You need to reduce multiple spaces between two words to a single space in the reversed string.

     

    Note:

    
        A word is defined as a sequence of non-space characters.
        Input string may contain leading or trailing spaces. However, your reversed string
            should not contain leading or trailing spaces.
        
        You need to reduce multiple spaces between two words to a single space in the reversed
            string.
        
    

     

    Follow up:

    For C programmers, try to solve it in-place in O(1) extra space.
-----------------

# 1211_Queries_Quality_and_Percentage
# 1211. Queries Quality and Percentage

Table: Queries

    +-------------+---------+
| Column Name | Type    |
+-------------+---------+
| query_name  | varchar |
| result      | varchar |
| position    | int     |
| rating      | int     |
+-------------+---------+
There is no primary key for this table, it may have duplicate rows.
This table contains information collected from some queries on a database.
The position column has a value from 1 to 500.
The rating column has a value from 1 to 5. Query with rating less than 3 is a poor query.

     

    We define query quality as:

    
        The average of the ratio between query rating and its position.
    

    We also define poor query percentage as:

    
        The percentage of all queries with rating less than 3.
    

    Write an SQL query to find each query_name, the quality and
        poor_query_percentage.

    Both quality and poor_query_percentage should be rounded to
        2 decimal places.

    The query result format is in the following example:

    Queries table:
+------------+-------------------+----------+--------+
| query_name | result            | position | rating |
+------------+-------------------+----------+--------+
| Dog        | Golden Retriever  | 1        | 5      |
| Dog        | German Shepherd   | 2        | 5      |
| Dog        | Mule              | 200      | 1      |
| Cat        | Shirazi           | 5        | 2      |
| Cat        | Siamese           | 3        | 3      |
| Cat        | Sphynx            | 7        | 4      |
+------------+-------------------+----------+--------+

Result table:
+------------+---------+-----------------------+
| query_name | quality | poor_query_percentage |
+------------+---------+-----------------------+
| Dog        | 2.50    | 33.33                 |
| Cat        | 0.66    | 33.33                 |
+------------+---------+-----------------------+

Dog queries quality is ((5 / 1) + (5 / 2) + (1 / 200)) / 3 = 2.50
Dog queries poor_ query_percentage is (1 / 3) * 100 = 33.33

Cat queries quality equals ((2 / 5) + (3 / 3) + (4 / 7)) / 3 = 0.66
Cat queries poor_ query_percentage is (1 / 3) * 100 = 33.33
-----------------

# 555_Split_Concatenated_Strings
# 555. Split Concatenated Strings

Given a list of strings, you could concatenate these strings together into a loop, where for
        each string you could choose to reverse it or not. Among all the possible loops, you need to
        find the lexicographically biggest string after cutting the loop, which will make the looped
        string into a regular one.

    Specifically, to find the lexicographically biggest string, you need to experience two
        phases:
    
        Concatenate all the strings into a loop, where you can reverse some strings or not and
            connect them in the same order as given.
        
        Cut and make one breakpoint in any place of the loop, which will make the looped string
            into a regular one starting from the character at the cutpoint.
        
    
    

    And your job is to find the lexicographically biggest one among all the possible regular
        strings.

    Example:
    Input: "abc", "xyz"
Output: "zyxcba"
Explanation: You can get the looped string "-abcxyz-", "-abczyx-", "-cbaxyz-", "-cbazyx-", where '-' represents the looped status. The answer string came from the fourth looped one, where you could cut from the middle character 'a' and get "zyxcba".

    

    Note:
    
        The input strings will only contain lowercase letters.
        The total length of all the strings will not over 1,000.
-----------------

# 83_Remove_Duplicates_from_Sorted_List
# 83. Remove Duplicates from Sorted List

Given a sorted linked list, delete all duplicates such that each element appear only
        once.

    Example 1:

    Input: 1->1->2
Output: 1->2

    Example 2:

    Input: 1->1->2->3->3
Output: 1->2->3
-----------------

# 849_Maximize_Distance_to_Closest_Person
# 849. Maximize Distance to Closest Person

In a row of seats, 1 represents a person sitting in that seat, and
        0 represents that the seat is empty. 

    There is at least one empty seat, and at least one person sitting.

    Alex wants to sit in the seat such that the distance between him and the closest person to
        him is maximized. 

    Return that maximum distance to closest person.
-----------------

# 1210_Minimum_Moves_to_Reach_Target_with_Rotations
# 1210. Minimum Moves to Reach Target with Rotations

In an n*n grid, there is a snake that spans 2 cells and starts moving
        from the top left corner at (0, 0) and (0, 1). The grid has empty
        cells represented by zeros and blocked cells represented by ones. The snake wants to reach
        the lower right corner at (n-1, n-2) and (n-1, n-1).
    

    In one move the snake can:

    
        Move one cell to the right if there are no blocked cells there. This move keeps the
            horizontal/vertical position of the snake as it is.
        
        Move down one cell if there are no blocked cells there. This move keeps the
            horizontal/vertical position of the snake as it is.
        
        Rotate clockwise if it's in a horizontal position and the two cells under it are
            both empty. In that case the snake moves from (r,
                c) and (r, c+1) to (r, c) and (r+1,
                c).
            
        Rotate counterclockwise if it's in a vertical position and the two cells to its
            right are both empty. In that case the snake moves from (r, c) and (r+1,
                c) to (r, c) and (r, c+1).
            
    

    Return the minimum number of moves to reach the target.

    If there is no way to reach the target, return -1.

     
    Example 1:

    

    Input: grid = [[0,0,0,0,0,1],
               [1,1,0,0,1,0],
               [0,0,0,0,1,1],
               [0,0,1,0,1,0],
               [0,1,1,0,0,0],
               [0,1,1,0,0,0]]
Output: 11
Explanation:
One possible solution is [right, right, rotate clockwise, right, down, down, down, down, rotate counterclockwise, right, down].

    Example 2:

    Input: grid = [[0,0,1,1,1,1],
               [0,0,0,0,1,1],
               [1,1,0,0,0,1],
               [1,1,1,0,0,1],
               [1,1,1,0,0,1],
               [1,1,1,0,0,0]]
Output: 9

     
    Constraints:

    
        2 <= n <= 100
        0 <= grid[i][j] <= 1
        It is guaranteed that the snake starts at empty cells.
-----------------

# 1788_Maximize_the_Beauty_of_the_Garden
# 1788. Maximize the Beauty of the Garden


-----------------

# 1740_Find_Distance_in_a_Binary_Tree
# 1740. Find Distance in a Binary Tree


-----------------

# 995_Minimum_Number_of_K_Consecutive_Bit_Flips
# 995. Minimum Number of K Consecutive Bit Flips

In an array A containing only 0s and 1s, a K-bit flip consists
        of choosing a (contiguous) subarray of length K and simultaneously changing
        every 0 in the subarray to 1, and every 1 in the subarray to 0.

    Return the minimum number of K-bit flips required so that there is no 0 in the
        array.  If it is not possible, return -1.

     

    Example 1:

    Input: A = [0,1,0], K = 1
Output: 2
Explanation: Flip A[0], then flip A[2].
-----------------

# 297_Serialize_and_Deserialize_Binary_Tree
# 297. Serialize and Deserialize Binary Tree

Serialization is the process of converting a data structure or object into a sequence of bits
        so that it can be stored in a file or memory buffer, or transmitted across a network
        connection link to be reconstructed later in the same or another computer environment.

    Design an algorithm to serialize and deserialize a binary tree. There is no restriction on
        how your serialization/deserialization algorithm should work. You just need to ensure that a
        binary tree can be serialized to a string and this string can be deserialized to the
        original tree structure.

    Example: 

    You may serialize the following tree:

    1
   / \
  2   3
     / \
    4   5

as "[1,2,3,null,null,4,5]"

    Clarification: The above format is the same as how LeetCode serializes a binary tree.
        You do not necessarily need to follow this format, so please be creative and come up with
        different approaches yourself.

    Note: Do not use class member/global/static variables to store states.
        Your serialize and deserialize algorithms should be stateless.
-----------------

# 210_Course_Schedule_II
# 210. Course Schedule II

There are a total of n courses you have to take, labeled from 0 to
        n-1.

    Some courses may have prerequisites, for example to take course 0 you have to first take
        course 1, which is expressed as a pair: [0,1]

    Given the total number of courses and a list of prerequisite pairs, return
        the ordering of courses you should take to finish all courses.

    There may be multiple correct orders, you just need to return one of them. If it is
        impossible to finish all courses, return an empty array.

    Example 1:

    Input: 2, [[1,0]]
Output: [0,1]
Explanation: There are a total of 2 courses to take. To take course 1 you should have finished
             course 0. So the correct course order is [0,1] .

    Example 2:

    Input: 4, [[1,0],[2,0],[3,1],[3,2]]
Output: [0,1,2,3] or [0,2,1,3]
Explanation: There are a total of 4 courses to take. To take course 3 you should have finished both
             courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0.
             So one correct course order is [0,1,2,3]. Another correct ordering is [0,2,1,3] .

    Note:

    
        The input prerequisites is a graph represented by a list of edges, not
            adjacency matrices. Read more about how a graph is represented.
        
        You may assume that there are no duplicate edges in the input prerequisites.
-----------------

# 667_Beautiful_Arrangement_II
# 667. Beautiful Arrangement II

Given two integers n and k, you need to construct a list which
        contains n different positive integers ranging from 1 to
        n and obeys the following requirement: 

        Suppose this list is [a1, a2, a3, ... , an],
        then the list [|a1 - a2|, |a2 - a3|,
        |a3 - a4|, ... , |an-1 - an|] has exactly k
        distinct integers.
    

    
        If there are multiple answers, print any of them.
    

    Example 1:
    Input: n = 3, k = 1
Output: [1, 2, 3]
Explanation: The [1, 2, 3] has three different positive integers ranging from 1 to 3, and the [1, 1] has exactly 1 distinct integer: 1.

    

    Example 2:
    Input: n = 3, k = 2
Output: [1, 3, 2]
Explanation: The [1, 3, 2] has three different positive integers ranging from 1 to 3, and the [2, 1] has exactly 2 distinct integers: 1 and 2.

    

    Note:
    
        The n and k are in the range 1 <= k < n <= 104.
-----------------

# 1138_Alphabet_Board_Path
# 1138. Alphabet Board Path

On an alphabet board, we start at position (0, 0), corresponding to character board[0][0].
    

    Here, board = ["abcde", "fghij", "klmno", "pqrst",
        "uvwxy", "z"], as shown in the diagram below.

    

    We may make the following moves:

    
        'U' moves our position up one row, if the position exists on the
            board;
        
        'D' moves our position down one row, if the position exists on the
            board;
        
        'L' moves our position left one column, if the position exists on
            the board;
        
        'R' moves our position right one column, if the position exists on
            the board;
        
        '!' adds the character board[r][c] at our current
            position (r, c) to the answer.
        
    

    (Here, the only positions that exist on the board are positions with letters on them.)

    Return a sequence of moves that makes our answer equal to target in the
        minimum number of moves.  You may return any path that does so.

     
    Example 1:
    Input: target = "leet"
Output: "DDR!UURRR!!DDD!"

    Example 2:
    Input: target = "code"
Output: "RR!DDRR!UUL!R!"

     
    Constraints:

    
        1 <= target.length <= 100
        target consists only of English lowercase letters.
-----------------

# 243_Shortest_Word_Distance
# 243. Shortest Word Distance

Given a list of words and two words word1 and word2, return the shortest
        distance between these two words in the list.

    Example:
        Assume that words = ["practice", "makes", "perfect",
            "coding", "makes"].

    Input: word1 = “coding”, word2 = “practice”
Output: 3

    Input: word1 = "makes", word2 = "coding"
Output: 1

    Note:
        You may assume that word1 does not equal to word2, and
        word1 and word2 are both in the list.
-----------------

# 177_Nth_Highest_Salary
# 177. Nth Highest Salary

Write a SQL query to get the nth highest salary from the
        Employee table.

    +----+--------+
| Id | Salary |
+----+--------+
| 1  | 100    |
| 2  | 200    |
| 3  | 300    |
+----+--------+

    For example, given the above Employee table, the nth highest salary where
        n = 2 is 200. If there is no nth highest salary,
        then the query should return null.

    +------------------------+
| getNthHighestSalary(2) |
+------------------------+
| 200                    |
+------------------------+
-----------------

# 191_Number_of_1_Bits
# 191. Number of 1 Bits

Write a function that takes an unsigned integer and return the number of '1' bits
        it has (also known as the Hamming weight).

     

    Example 1:

    Input: 00000000000000000000000000001011
Output: 3
Explanation: The input binary string 00000000000000000000000000001011 has a total of three '1' bits.

    Example 2:

    Input: 00000000000000000000000010000000
Output: 1
Explanation: The input binary string 00000000000000000000000010000000 has a total of one '1' bit.

    Example 3:

    Input: 11111111111111111111111111111101
Output: 31
Explanation: The input binary string 11111111111111111111111111111101 has a total of thirty one '1' bits.

     

    Note:

    
        Note that in some languages such as Java, there is no unsigned integer type. In this
            case, the input will be given as signed integer type and should not affect your
            implementation, as the internal binary representation of the integer is the same whether
            it is signed or unsigned.
        
        In Java, the compiler represents the signed integers using 2's
            complement notation. Therefore, in Example 3 above the input
            represents the signed integer -3.
        
    

     

    Follow up:

    If this function is called many times, how would you optimize it?
-----------------

# 1412_Find_the_Quiet_Students_in_All_Exams
# 1412. Find the Quiet Students in All Exams


-----------------

# 107_Binary_Tree_Level_Order_Traversal_II
# 107. Binary Tree Level Order Traversal II

Given a binary tree, return the bottom-up level order traversal of its nodes' values.
        (ie, from left to right, level by level from leaf to root).

    
        For example:
        Given binary tree [3,9,20,null,null,15,7],
        3
   / \
  9  20
    /  \
   15   7

    
    
        return its bottom-up level order traversal as:
    [
  [15,7],
  [9,20],
  [3]
]
-----------------

# 683_K_Empty_Slots
# 683. K Empty Slots

You have N bulbs in a row numbered from 1 to N.
        Initially, all the bulbs are turned off. We turn on exactly one bulb everyday until all
        bulbs are on after N days.

    You are given an array bulbs of length N where bulbs[i]
        = x means that on the (i+1)th day, we will turn on the bulb at position
        x where i is 0-indexed and x is 1-indexed.
    

    Given an integer K, find out the minimum day number such that
        there exists two turned on bulbs that have
        exactly K bulbs between them that are all turned
            off.

    If there isn't such day, return -1.

     

    Example 1:

    Input:
bulbs: [1,3,2]
K: 1
Output: 2
Explanation:
On the first day: bulbs[0] = 1, first bulb is turned on: [1,0,0]
On the second day: bulbs[1] = 3, third bulb is turned on: [1,0,1]
On the third day: bulbs[2] = 2, second bulb is turned on: [1,1,1]
We return 2 because on the second day, there were two on bulbs with one off bulb between them.

    Example 2:

    Input:
bulbs: [1,2,3]
K: 1
Output: -1

     

    Note:

    
        1 <= N <= 20000
        1 <= bulbs[i] <= N
        bulbs is a permutation of numbers from 1 to N.
        
        0 <= K <= 20000
-----------------

# 1242_Web_Crawler_Multithreaded
# 1242. Web Crawler Multithreaded

Given a url startUrl and an interface HtmlParser, implement
        a Multi-threaded web crawler to crawl all links that are under the same
            hostname as startUrl. 

    Return all urls obtained by your web crawler in any order.

    Your crawler should:

    
        Start from the page: startUrl
        Call HtmlParser.getUrls(url) to get all urls from a webpage of given url.
        
        Do not crawl the same link twice.
        Explore only the links that are under the same hostname as startUrl.
        
    

    

    As shown in the example url above, the hostname is example.org. For simplicity
        sake, you may assume all urls use http protocol without
        any port specified. For example, the urls http://leetcode.com/problems
        and http://leetcode.com/contest are under the same hostname, while urls
        http://example.org/test and http://example.com/abc are not under
        the same hostname.

    The HtmlParser interface is defined as such: 

    interface HtmlParser {
  // Return a list of all urls from a webpage of given url.
  // This is a blocking call, that means it will do HTTP request and return when this request is finished.
  public List<String> getUrls(String url);
}

    Note that getUrls(String url) simulates performing a HTTP
        request. You can treat it as a blocking function call which waits for a HTTP request to
        finish. It is guaranteed that getUrls(String url) will return the urls
        within 15ms.  Single-threaded solutions will exceed the time limit so,
        can your multi-threaded web crawler do better?

    Below are two examples explaining the functionality of the problem, for custom testing
        purposes you'll have three variables urls, edges and startUrl. Notice that you will only have access to startUrl in your code, while urls and edges are not directly accessible to you in
        code.

     

    Follow up:

    
        Assume we have 10,000 nodes and 1 billion URLs to crawl. We will deploy the same
            software onto each node. The software can know about all the nodes. We have to
            minimize communication between machines and make sure each node does equal amount of
            work. How would your web crawler design change?
        
        What if one node fails or does not work?
        How do you know when the crawler is done?
    

     
    Example 1:

    

    Input:
urls = [
  "http://news.yahoo.com",
  "http://news.yahoo.com/news",
  "http://news.yahoo.com/news/topics/",
  "http://news.google.com",
  "http://news.yahoo.com/us"
]
edges = [[2,0],[2,1],[3,2],[3,1],[0,4]]
startUrl = "http://news.yahoo.com/news/topics/"
Output: [
  "http://news.yahoo.com",
  "http://news.yahoo.com/news",
  "http://news.yahoo.com/news/topics/",
  "http://news.yahoo.com/us"
]

    Example 2:

    

    Input:
urls = [
  "http://news.yahoo.com",
  "http://news.yahoo.com/news",
  "http://news.yahoo.com/news/topics/",
  "http://news.google.com"
]
edges = [[0,2],[2,1],[3,2],[3,1],[3,0]]
startUrl = "http://news.google.com"
Output: ["http://news.google.com"]
Explanation: The startUrl links to all other pages that do not share the same hostname.

     
    Constraints:

    
        1 <= urls.length <= 1000
        1 <= urls[i].length <= 300
        startUrl is one of the urls.
        Hostname label must be from 1 to 63 characters long, including the dots, may contain
            only the ASCII letters from 'a' to 'z', digits from '0' to
            '9' and the hyphen-minus character ('-').
        
        The hostname may not start or end with the hyphen-minus character ('-'). 
        See:  https://en.wikipedia.org/wiki/Hostname#Restrictions_on_valid_hostnames
        
        You may assume there're no duplicates in url library.
-----------------

# 1759_Count_Number_of_Homogenous_Substrings
# 1759. Count Number of Homogenous Substrings


-----------------

# 679_24_Game
# 679. 24 Game

You have 4 cards each containing a number from 1 to 9. You need to judge whether they could
        operated through *, /, +, -,
        (, ) to get the value of 24.
    

    Example 1:
    Input: [4, 1, 8, 7]
Output: True
Explanation: (8-4) * (7-1) = 24

    

    Example 2:
    Input: [1, 2, 1, 2]
Output: False

    

    Note:
    
        The division operator / represents real division, not integer division. For
            example, 4 / (1 - 2/3) = 12.
        
        Every operation done is between two numbers. In particular, we cannot use -
            as a unary operator. For example, with [1, 1, 1, 1] as input, the
            expression -1 - 1 - 1 - 1 is not allowed.
        
        You cannot concatenate numbers together. For example, if the input is [1, 2, 1,
            2], we cannot write this as 12 + 12.
-----------------

# 993_Cousins_in_Binary_Tree
# 993. Cousins in Binary Tree

In a binary tree, the root node is at depth 0, and children of each depth k
        node are at depth k+1.

    Two nodes of a binary tree are cousins if they have the same depth, but have
        different parents.

    We are given the root of a binary tree with unique values, and the values x and
        y of two different nodes in the tree.

    Return true if and only if the nodes corresponding to the values
        x and y are cousins.

     

    Example 1:
        

    Input: root = [1,2,3,4], x = 4, y = 3
Output: false
-----------------

# 432_All_O`one_Data_Structure
# 432. All O`one Data Structure

Implement a data structure supporting the following operations:

    
    
        Inc(Key) - Inserts a new key
             with value 1. Or increments an existing key by 1. Key is guaranteed to be a non-empty
                string.
        
        Dec(Key) - If Key's value is 1, remove it from the data structure. Otherwise decrements
            an existing key by 1. If the key does not exist, this function does nothing. Key is
            guaranteed to be a non-empty string.
        
        GetMaxKey() - Returns one of the keys with maximal value. If no element exists, return
            an empty string "".
        
        GetMinKey() - Returns one of the keys with minimal value. If no element exists, return
            an empty string "".
        
    
    

    
        Challenge: Perform all these in O(1) time complexity.
-----------------

# 126_Word_Ladder_II
# 126. Word Ladder II

Given two words (beginWord and endWord), and a dictionary's word list,
        find all shortest transformation sequence(s) from beginWord to endWord,
        such that:

    
        Only one letter can be changed at a time
        Each transformed word must exist in the word list. Note that beginWord is not
            a transformed word.
        
    

    Note:

    
        Return an empty list if there is no such transformation sequence.
        All words have the same length.
        All words contain only lowercase alphabetic characters.
        You may assume no duplicates in the word list.
        You may assume beginWord and endWord are non-empty and are not the
            same.
        
    

    Example 1:

    Input:
beginWord = "hit",
endWord = "cog",
wordList = ["hot","dot","dog","lot","log","cog"]

Output:
[
  ["hit","hot","dot","dog","cog"],
  ["hit","hot","lot","log","cog"]
]

    Example 2:

    Input:
beginWord = "hit"
endWord = "cog"
wordList = ["hot","dot","dog","lot","log"]

Output: []

Explanation: The endWord "cog" is not in wordList, therefore no possible transformation.
-----------------

# 1560_Most_Visited_Sector_in_a_Circular_Track
# 1560. Most Visited Sector in a Circular Track


-----------------

# 465_Optimal_Account_Balancing
# 465. Optimal Account Balancing

A group of friends went on holiday and sometimes lent each other money. For example, Alice
        paid for Bill's lunch for $10. Then later Chris gave Alice $5 for a taxi ride. We can model
        each transaction as a tuple (x, y, z) which means person x gave person y $z. Assuming Alice,
        Bill, and Chris are person 0, 1, and 2 respectively (0, 1, 2 are the person's ID), the
        transactions can be represented as [[0, 1, 10], [2, 0, 5]].

    Given a list of transactions between a group of people, return the minimum number of
        transactions required to settle the debt.

    Note:
    
        A transaction will be given as a tuple (x, y, z). Note that x ≠ y and
            z > 0.
        
        Person's IDs may not be linear, e.g. we could have the persons 0, 1, 2 or we could also
            have the persons 0, 2, 6.
        
    
    

    Example 1:
    Input:
[[0,1,10], [2,0,5]]

Output:
2

Explanation:
Person #0 gave person #1 $10.
Person #2 gave person #0 $5.

Two transactions are needed. One way to settle the debt is person #1 pays person #0 and #2 $5 each.

    

    Example 2:
    Input:
[[0,1,10], [1,0,1], [1,2,5], [2,0,5]]

Output:
1

Explanation:
Person #0 gave person #1 $10.
Person #1 gave person #0 $1.
Person #1 gave person #2 $5.
Person #2 gave person #0 $5.

Therefore, person #1 only need to give person #0 $4, and all debt is settled.
-----------------

# 16_3Sum_Closest
# 16. 3Sum Closest

Given an array nums of n integers and an integer target,
        find three integers in nums such that the sum is closest to target.
        Return the sum of the three integers. You may assume that each input would have exactly one
        solution.

    Example:

    Given array nums = [-1, 2, 1, -4], and target = 1.

The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).
-----------------

# 153_Find_Minimum_in_Rotated_Sorted_Array
# 153. Find Minimum in Rotated Sorted Array

Suppose an array sorted in ascending order is rotated at some pivot unknown to you
        beforehand.

    (i.e.,  [0,1,2,4,5,6,7] might become
         [4,5,6,7,0,1,2]).

    Find the minimum element.

    You may assume no duplicate exists in the array.

    Example 1:

    Input: [3,4,5,1,2]
Output: 1

    Example 2:

    Input: [4,5,6,7,0,1,2]
Output: 0
-----------------

# 1639_Number_of_Ways_to_Form_a_Target_String_Given_a_Dictionary
# 1639. Number of Ways to Form a Target String Given a Dictionary


-----------------

# 247_Strobogrammatic_Number_II
# 247. Strobogrammatic Number II

A strobogrammatic number is a number that looks the same when rotated 180 degrees (looked at
        upside down).

    Find all strobogrammatic numbers that are of length = n.

    Example:

    Input:  n = 2
Output: ["11","69","88","96"]
-----------------

# 1298_Maximum_Candies_You_Can_Get_from_Boxes
# 1298. Maximum Candies You Can Get from Boxes


-----------------

# 696_Count_Binary_Substrings
# 696. Count Binary Substrings

Give a string s, count the number of non-empty (contiguous) substrings that have
        the same number of 0's and 1's, and all the 0's and all the 1's in these substrings are
        grouped consecutively.
    
    Substrings that occur multiple times are counted the number of times they occur.

    Example 1:
    Input: "00110011"
Output: 6
Explanation: There are 6 substrings that have equal number of consecutive 1's and 0's: "0011", "01", "1100", "10", "0011", and "01".
Notice that some of these substrings repeat and are counted the number of times they occur.
Also, "00110011" is not a valid substring because all the 0's (and 1's) are not grouped together.

    

    Example 2:
    Input: "10101"
Output: 4
Explanation: There are 4 substrings: "10", "01", "10", "01" that have equal number of consecutive 1's and 0's.

    

    Note:
    s.length will be between 1 and 50,000.
    s will only consist of "0" or "1" characters.
-----------------

# 1315_Sum_of_Nodes_with_Even-Valued_Grandparent
# 1315. Sum of Nodes with Even-Valued Grandparent


-----------------

# 1297_Maximum_Number_of_Occurrences_of_a_Substring
# 1297. Maximum Number of Occurrences of a Substring


-----------------

# 657_Robot_Return_to_Origin
# 657. Robot Return to Origin

There is a robot starting at position (0, 0), the origin, on a 2D plane. Given a sequence of
        its moves, judge if this robot ends up at (0, 0) after it completes its
        moves.

    The move sequence is represented by a string, and the character moves[i] represents its ith
        move. Valid moves are R (right), L (left), U (up), and D (down). If the robot returns to the
        origin after it finishes all of its moves, return true. Otherwise, return false.

    Note: The way that the robot is "facing" is irrelevant. "R"
        will always make the robot move to the right once, "L" will always make it move
        left, etc. Also, assume that the magnitude of the robot's movement is the same for each
        move.

    Example 1:

    Input: "UD"
Output: true
Explanation: The robot moves up once, and then down once. All moves have the same magnitude, so it ended up at the origin where it started. Therefore, we return true.

     

    Example 2:

    Input: "LL"
Output: false
Explanation: The robot moves left twice. It ends up two "moves" to the left of the origin. We return false because it is not at the origin at the end of its moves.
-----------------

# 1648_Sell_Diminishing-Valued_Colored_Balls
# 1648. Sell Diminishing-Valued Colored Balls


-----------------

# 1410_HTML_Entity_Parser
# 1410. HTML Entity Parser


-----------------

# 507_Perfect_Number
# 507. Perfect Number

We define the Perfect Number is a positive integer that is equal to the sum of all its
        positive divisors except itself.
    
    Now, given an integer n, write a function that returns true when it is a perfect number
    and false when it is not.
    

    Example:
    Input: 28
Output: True
Explanation: 28 = 1 + 2 + 4 + 7 + 14

    

    Note:
        The input number n will not exceed 100,000,000. (1e8)
-----------------

# 158_Read_N_Characters_Given_Read4_II_-_Call_multiple_times
# 158. Read N Characters Given Read4 II - Call multiple times

Given a file and assume that you can only read the file using a given
        method read4, implement a method read to read n
        characters. Your method read may be called multiple times.

     

    Method read4: 

    The API read4 reads 4 consecutive characters from the file, then writes
        those characters into the buffer array buf.

    The return value is the number of actual characters read.

    Note that read4() has its own file pointer, much like FILE *fp
        in C.

    Definition of read4:

        Parameter:  char[] buf
    Returns:    int

Note: buf[] is destination not source, the results from read4 will be copied to buf[]

    Below is a high level example of how read4 works:

    File file("abcdefghijk"); // File is "abcdefghijk", initially file pointer (fp) points to 'a'
char[] buf = new char[4]; // Create buffer with enough space to store characters
read4(buf); // read4 returns 4. Now buf = "abcd", fp points to 'e'
read4(buf); // read4 returns 4. Now buf = "efgh", fp points to 'i'
read4(buf); // read4 returns 3. Now buf = "ijk", fp points to end of file

     

    Method read:

    By using the read4 method, implement the method read that
        reads n characters from the file and store it in the buffer
        array buf. Consider that you cannot manipulate the file
        directly.

    The return value is the number of actual characters read.

    Definition of read: 

        Parameters:	char[] buf, int n
    Returns:	int

Note: buf[] is destination not source, you will need to write the results to buf[]

     

    Example 1:

    File file("abc");
Solution sol;
// Assume buf is allocated and guaranteed to have enough space for storing all characters from the file.
sol.read(buf, 1); // After calling your read method, buf should contain "a". We read a total of 1 character from the file, so return 1.
sol.read(buf, 2); // Now buf should contain "bc". We read a total of 2 characters from the file, so return 2.
sol.read(buf, 1); // We have reached the end of file, no more characters can be read. So return 0.

    Example 2:

    File file("abc");
Solution sol;
sol.read(buf, 4); // After calling your read method, buf should contain "abc". We read a total of 3 characters from the file, so return 3.
sol.read(buf, 1); // We have reached the end of file, no more characters can be read. So return 0.

     

    Note:

    
        Consider that you cannot manipulate the file directly, the file is only
            accesible for read4 but not for read.
        
        The read function may be called multiple times.
        Please remember to RESET your class variables declared in Solution, as
            static/class variables are persisted across multiple test cases. Please see here for more details.
        
        You may assume the destination buffer array, buf, is guaranteed
            to have enough space for storing n characters.
        
        It is guaranteed that in a given test case the same buffer buf is called by
            read.
-----------------

# 736_Parse_Lisp_Expression
# 736. Parse Lisp Expression

You are given a string expression representing a Lisp-like expression to return
        the integer value of.
    
    
        The syntax for these expressions is given as follows.
    
    
    An expression is either an integer, a let-expression, an add-expression, a mult-expression,
        or an assigned variable. Expressions always evaluate to a single integer.
    
    
    (An integer could be positive or negative.)
    
    A let-expression takes the form (let v1 e1 v2 e2 ... vn en expr), where let
        is always the string "let", then there are 1 or more pairs of alternating
        variables and expressions, meaning that the first variable v1 is assigned the
        value of the expression e1, the second variable v2 is assigned the
        value of the expression e2, and so on sequentially; and then the value
        of this let-expression is the value of the expression expr.
    
    
    An add-expression takes the form (add e1 e2) where add is always
        the string "add", there are always two expressions e1, e2, and
        this expression evaluates to the addition of the evaluation of e1 and the
        evaluation of e2.
    
    
    A mult-expression takes the form (mult e1 e2) where mult is always
        the string "mult", there are always two expressions e1, e2, and
        this expression evaluates to the multiplication of the evaluation of e1 and the
        evaluation of e2.
    
    
    For the purposes of this question, we will use a smaller subset of variable names. A
        variable starts with a lowercase letter, then zero or more lowercase letters or digits.
        Additionally for your convenience, the names "add", "let", or "mult" are protected and will
        never be used as variable names.
    
    
    Finally, there is the concept of scope. When an expression of a variable name is evaluated,
        within the context of that evaluation, the innermost scope (in terms of parentheses)
        is checked first for the value of that variable, and then outer scopes are checked
        sequentially. It is guaranteed that every expression is legal. Please see the examples for
        more details on scope.
    
    

    Evaluation Examples:
    Input: (add 1 2)
Output: 3

Input: (mult 3 (add 2 3))
Output: 15

Input: (let x 2 (mult x 5))
Output: 10

Input: (let x 2 (mult x (let x 3 y 4 (add x y))))
Output: 14
Explanation: In the expression (add x y), when checking for the value of the variable x,
we check from the innermost scope to the outermost in the context of the variable we are trying to evaluate.
Since x = 3 is found first, the value of x is 3.

Input: (let x 3 x 2 x)
Output: 2
Explanation: Assignment in let statements is processed sequentially.

Input: (let x 1 y 2 x (add x y) (add x y))
Output: 5
Explanation: The first (add x y) evaluates as 3, and is assigned to x.
The second (add x y) evaluates as 3+2 = 5.

Input: (let x 2 (add (let x 3 (let x 4 x)) x))
Output: 6
Explanation: Even though (let x 4 x) has a deeper scope, it is outside the context
of the final x in the add-expression.  That final x will equal 2.

Input: (let a1 3 b2 (add a1 1) b2)
Output 4
Explanation: Variable names can contain digits after the first character.

    Note:
    The given string expression is well formatted: There are no leading or trailing
        spaces, there is only a single space separating different components of the string, and no
        space between adjacent parentheses. The expression is guaranteed to be legal and evaluate to
        an integer.
    
    The length of expression is at most 2000. (It is also non-empty, as that would
        not be a legal expression.)
    
    The answer and all intermediate calculations of that answer are guaranteed to fit in a
        32-bit integer.
-----------------

# 878_Nth_Magical_Number
# 878. Nth Magical Number

A positive integer is magical if it is divisible by either A or B.

    Return the N-th magical number.  Since the answer may be
        very large, return it modulo 10^9 + 7.
-----------------

# 545_Boundary_of_Binary_Tree
# 545. Boundary of Binary Tree

Given a binary tree, return the values of its boundary in anti-clockwise direction
        starting from root. Boundary includes left boundary, leaves, and right boundary in order
        without duplicate nodes.  (The values of the nodes may still be
        duplicates.)

    Left boundary is defined as the path from root to the left-most node. Right
        boundary is defined as the path from root to the right-most node. If the root
        doesn't have left subtree or right subtree, then the root itself is left boundary or
        right boundary. Note this definition only applies to the input binary tree, and not applies
        to any subtrees.

    The left-most node is defined as a leaf node you could reach when you always
        firstly travel to the left subtree if exists. If not, travel to the right subtree. Repeat
        until you reach a leaf node.

    The right-most node is also defined by the same way with left and right exchanged.

    Example 1

    Input:
  1
   \
    2
   / \
  3   4

Ouput:
[1, 3, 4, 2]

Explanation:
The root doesn't have left subtree, so the root itself is left boundary.
The leaves are node 3 and 4.
The right boundary are node 1,2,4. Note the anti-clockwise direction means you should output reversed right boundary.
So order them in anti-clockwise without duplicates and we have [1,3,4,2].

     

    Example 2

    Input:
    ____1_____
   /          \
  2            3
 / \          /
4   5        6
   / \      / \
  7   8    9  10

Ouput:
[1,2,4,7,8,9,10,6,3]

Explanation:
The left boundary are node 1,2,4. (4 is the left-most node according to definition)
The leaves are node 4,7,8,9,10.
The right boundary are node 1,3,6,10. (10 is the right-most node).
So order them in anti-clockwise without duplicate nodes we have [1,2,4,7,8,9,10,6,3].
-----------------

# 1433_Check_If_a_String_Can_Break_Another_String
# 1433. Check If a String Can Break Another String


-----------------

# 879_Profitable_Schemes
# 879. Profitable Schemes

There are G people in a gang, and a list of various crimes they could commit.

    The i-th crime generates a profit[i] and requires
        group[i] gang members to participate.

    If a gang member participates in one crime, that member can't participate in another
        crime.

    Let's call a profitable scheme any subset of these crimes that
        generates at least P profit, and the total number of gang members participating
        in that subset of crimes is at most G.

    How many schemes can be chosen?  Since the answer may be very large, return
        it modulo 10^9 + 7.

     

    Example 1:

    Input: G = 5, P = 3, group = [2,2], profit = [2,3]
Output: 2
Explanation: 
To make a profit of at least 3, the gang could either commit crimes 0 and 1, or just crime 1.
In total, there are 2 schemes.
-----------------

# 640_Solve_the_Equation
# 640. Solve the Equation

Solve a given equation and return the value of x in the form of string
        "x=#value". The equation contains only '+', '-' operation, the variable x and
        its coefficient.
    

    
        If there is no solution for the equation, return "No solution".
    
    
        If there are infinite solutions for the equation, return "Infinite solutions".
    
    
        If there is exactly one solution for the equation, we ensure that the value of
        x is an integer.
    

    Example 1:
    Input: "x+5-3+x=6+x-2"
Output: "x=2"

    

    Example 2:
    Input: "x=x"
Output: "Infinite solutions"

    

    Example 3:
    Input: "2x=x"
Output: "x=0"

    

    Example 4:
    Input: "2x+3x-6x=x+2"
Output: "x=-1"

    

    Example 5:
    Input: "x=x+2"
Output: "No solution"
-----------------

# 308_Range_Sum_Query_2D_-_Mutable
# 308. Range Sum Query 2D - Mutable

Given a 2D matrix matrix, find the sum of the elements inside the rectangle defined by
        its upper left corner (row1, col1) and lower right corner (row2,
        col2).

    
        
        The above rectangle (with the red border) is defined by (row1, col1) = (2, 1)
            and (row2, col2) = (4, 3), which contains sum = 8.
        
    

    Example:
    Given matrix = [
  [3, 0, 1, 4, 2],
  [5, 6, 3, 2, 1],
  [1, 2, 0, 1, 5],
  [4, 1, 0, 1, 7],
  [1, 0, 3, 0, 5]
]

sumRegion(2, 1, 4, 3) -> 8
update(3, 2, 2)
sumRegion(2, 1, 4, 3) -> 10

    

    Note:
    
        The matrix is only modifiable by the update function.
        You may assume the number of calls to update and sumRegion function is
            distributed evenly.
        
        You may assume that row1 ≤ row2 and col1 ≤ col2.
-----------------

# 47_Permutations_II
# 47. Permutations II

Given a collection of numbers that might contain duplicates, return all possible unique
        permutations.

    Example:

    Input: [1,1,2]
Output:
[
  [1,1,2],
  [1,2,1],
  [2,1,1]
]
-----------------

# 951_Flip_Equivalent_Binary_Trees
# 951. Flip Equivalent Binary Trees

For a binary tree T, we can define a flip operation as follows: choose any node, and swap the
        left and right child subtrees.

    A binary tree X is flip equivalent to a binary tree Y if and only if we can
        make X equal to Y after some number of flip operations.

    Write a function that determines whether two binary trees are flip equivalent. 
        The trees are given by root nodes root1 and root2.

     

    Example 1:

    Input: root1 = [1,2,3,4,5,6,null,null,null,7,8], root2 = [1,3,2,null,6,4,5,null,null,null,null,8,7]
Output: true
Explanation: We flipped at nodes with values 1, 3, and 5.

     

    Note:

    
        Each tree will have at most 100 nodes.
        Each value in each tree will be a unique integer in the range [0, 99].
-----------------

# 1539_Kth_Missing_Positive_Number
# 1539. Kth Missing Positive Number


-----------------

# 1467_Probability_of_a_Two_Boxes_Having_The_Same_Number_of_Distinct_Balls
# 1467. Probability of a Two Boxes Having The Same Number of Distinct Balls


-----------------

# 170_Two_Sum_III_-_Data_structure_design
# 170. Two Sum III - Data structure design

Design and implement a TwoSum class. It should support the following operations:
        add and find.

    add - Add the number to an internal data structure.
        find - Find if there exists any pair of numbers which sum is equal to the
        value.

    Example 1:

    add(1); add(3); add(5);
find(4) -> true
find(7) -> false

    Example 2:

    add(3); add(1); add(2);
find(3) -> true
find(6) -> false
-----------------

# 403_Frog_Jump
# 403. Frog Jump

A frog is crossing a river. The river is divided into x units and at each unit there may or
        may not exist a stone. The frog can jump on a stone, but it must not jump into the
        water.

    Given a list of stones' positions (in units) in sorted ascending order, determine if the frog
        is able to cross the river by landing on the last stone. Initially, the frog is on the first
        stone and assume the first jump must be 1 unit.
    

    If the frog's last jump was k units, then its next jump must be either k - 1,
        k, or k + 1 units. Note that the frog can only jump in the forward direction.
    

    Note:
    
        The number of stones is ≥ 2 and is < 1,100.
        Each stone's position will be a non-negative integer < 231.
        The first stone's position is always 0.
    
    

    Example 1:
    [0,1,3,5,6,8,12,17]

There are a total of 8 stones.
The first stone at the 0th unit, second stone at the 1st unit,
third stone at the 3rd unit, and so on...
The last stone at the 17th unit.

Return true. The frog can jump to the last stone by jumping
1 unit to the 2nd stone, then 2 units to the 3rd stone, then
2 units to the 4th stone, then 3 units to the 6th stone,
4 units to the 7th stone, and 5 units to the 8th stone.

    

    Example 2:
    [0,1,2,3,4,8,9,11]

Return false. There is no way to jump to the last stone as
the gap between the 5th and 6th stone is too large.
-----------------

# 1327_List_the_Products_Ordered_in_a_Period
# 1327. List the Products Ordered in a Period


-----------------

# 1426_Counting_Elements
# 1426. Counting Elements


-----------------

# 425_Word_Squares
# 425. Word Squares

Given a set of words (without duplicates), find all word squares you
        can build from them.

    A sequence of words forms a valid word square if the kth row and column
        read the exact same string, where 0 ≤ k < max(numRows, numColumns).

    For example, the word sequence ["ball","area","lead","lady"] forms a word square
        because each word reads the same both horizontally and vertically.

    b a l l
a r e a
l e a d
l a d y

    Note:
    
        There are at least 1 and at most 1000 words.
        All words will have the exact same length.
        Word length is at least 1 and at most 5.
        Each word contains only lowercase English alphabet a-z.
    
    

    Example 1:
    Input:
["area","lead","wall","lady","ball"]

Output:
[
  [ "wall",
    "area",
    "lead",
    "lady"
  ],
  [ "ball",
    "area",
    "lead",
    "lady"
  ]
]

Explanation:
The output consists of two word squares. The order of output does not matter (just the order of words in each word square matters).

    

    Example 2:
    Input:
["abat","baba","atan","atal"]

Output:
[
  [ "baba",
    "abat",
    "baba",
    "atan"
  ],
  [ "baba",
    "abat",
    "baba",
    "atal"
  ]
]

Explanation:
The output consists of two word squares. The order of output does not matter (just the order of words in each word square matters).
-----------------

# 1224_Maximum_Equal_Frequency
# 1224. Maximum Equal Frequency

Given an array nums of positive integers, return the longest possible
        length of an array prefix of nums, such that it is possible to remove exactly
            one element from this prefix so that every number that has appeared in it will
        have the same number of occurrences.

    If after removing one element there are no remaining elements, it's still considered that
        every appeared number has the same number of ocurrences (0).

     
    Example 1:

    Input: nums = [2,2,1,1,5,3,3,5]
Output: 7
Explanation: For the subarray [2,2,1,1,5,3,3] of length 7, if we remove nums[4]=5, we will get [2,2,1,1,3,3], so that each number will appear exactly twice.

    Example 2:

    Input: nums = [1,1,1,2,2,2,3,3,3,4,4,4,5]
Output: 13

    Example 3:

    Input: nums = [1,1,1,2,2,2]
Output: 5

    Example 4:

    Input: nums = [10,2,8,9,3,8,1,5,2,3,7,6]
Output: 8

     
    Constraints:

    
        2 <= nums.length <= 10^5
        1 <= nums[i] <= 10^5
-----------------

# 1545_Find_Kth_Bit_in_Nth_Binary_String
# 1545. Find Kth Bit in Nth Binary String


-----------------

# 1203_Sort_Items_by_Groups_Respecting_Dependencies
# 1203. Sort Items by Groups Respecting Dependencies

There are n items each belonging to zero or one
        of m groups where group[i] is the group that the
        i-th item belongs to and it's equal to -1 if the
        i-th item belongs to no group. The items and the groups are zero indexed. A
        group can have no item belonging to it.

    Return a sorted list of the items such that:

    
        The items that belong to the same group are next to each other in the sorted list.
        There are some relations between these items
            where beforeItems[i] is a list containing all the items that
            should come before the i-th item in the sorted array (to the left of
            the i-th item).
        
    

    Return any solution if there is more than one solution and return an empty
        list if there is no solution.

     
    Example 1:

    

    Input: n = 8, m = 2, group = [-1,-1,1,0,0,1,0,-1], beforeItems = [[],[6],[5],[6],[3,6],[],[],[]]
Output: [6,3,4,1,5,2,0,7]

    Example 2:

    Input: n = 8, m = 2, group = [-1,-1,1,0,0,1,0,-1], beforeItems = [[],[6],[5],[6],[3],[],[4],[]]
Output: []
Explanation: This is the same as example 1 except that 4 needs to be before 6 in the sorted list.

     
    Constraints:

    
        1 <= m <= n <= 3*10^4
        group.length == beforeItems.length == n
        -1 <= group[i] <= m-1
        0 <= beforeItems[i].length <= n-1
        0 <= beforeItems[i][j] <= n-1
        i != beforeItems[i][j]
        beforeItems[i] does not contain duplicates elements.
-----------------

# 984_String_Without_AAA_or_BBB
# 984. String Without AAA or BBB

Given two integers A and B, return any string
        S such that:

    
        S has length A + B and contains exactly A 'a'
            letters, and exactly B 'b' letters;
        
        The substring 'aaa' does not occur in S;
        
        The substring 'bbb' does not occur in S.
    

     

    Example 1:

    Input: A = 1, B = 2
Output: "abb"
Explanation: "abb", "bab" and "bba" are all correct answers.
-----------------

# 1320_Minimum_Distance_to_Type_a_Word_Using_Two_Fingers
# 1320. Minimum Distance to Type a Word Using Two Fingers


-----------------

# 631_Design_Excel_Sum_Formula
# 631. Design Excel Sum Formula

Your task is to design the basic function of Excel and implement the function of sum formula.
        Specifically, you need to implement the following functions:

    Excel(int H, char W): This is the constructor. The inputs represents the height
        and width of the Excel form. H is a positive integer, range from 1 to 26. It
        represents the height. W is a character range from 'A' to 'Z'. It represents that the
        width is the number of characters from 'A' to W. The Excel form content is
        represented by a height * width 2D integer array C, it should be initialized to
        zero. You should assume that the first row of C starts from 1, and the first
        column of C starts from 'A'.

    

    void Set(int row, char column, int val): Change the value at C(row,
        column) to be val.
    
    int Get(int row, char column): Return the value at C(row, column).
    
    
    int Sum(int row, char column, List of Strings : numbers): This function
        calculate and set the value at C(row, column), where the value should be the
        sum of cells represented by numbers. This function return the sum result at
        C(row, column). This sum formula should exist until this cell is overlapped by
        another value or another sum formula.

    numbers is a list of strings that each string represent a cell or a range of
        cells. If the string represent a single cell, then it has the following format : ColRow.
        For example, "F7" represents the cell at (7, F). 

    If the string represent a range of cells, then it has the following format : ColRow1:ColRow2.
        The range will always be a rectangle, and ColRow1 represent the position of the top-left
        cell, and ColRow2 represents the position of the bottom-right cell. 
    
    Example 1:
    Excel(3,"C");
// construct a 3*3 2D array with all zero.
//   A B C
// 1 0 0 0
// 2 0 0 0
// 3 0 0 0

Set(1, "A", 2);
// set C(1,"A") to be 2.
//   A B C
// 1 2 0 0
// 2 0 0 0
// 3 0 0 0

Sum(3, "C", ["A1", "A1:B2"]);
// set C(3,"C") to be the sum of value at C(1,"A") and the values sum of the rectangle range whose top-left cell is C(1,"A") and bottom-right cell is C(2,"B"). Return 4.
//   A B C
// 1 2 0 0
// 2 0 0 0
// 3 0 0 4

Set(2, "B", 2);
// set C(2,"B") to be 2. Note C(3, "C") should also be changed.
//   A B C
// 1 2 0 0
// 2 0 2 0
// 3 0 0 6

    

    Note:
    
        You could assume that there won't be any circular sum reference. For example, A1 =
            sum(B1) and B1 = sum(A1).
        
         The test cases are using double-quotes to represent a character.
        Please remember to RESET your class variables declared in class Excel, as
            static/class variables are persisted across multiple test cases. Please see here for more details.
-----------------

# 1127_User_Purchase_Platform
# 1127. User Purchase Platform

Table: Spending

    +-------------+---------+
| Column Name | Type    |
+-------------+---------+
| user_id     | int     |
| spend_date  | date    |
| platform    | enum    |
| amount      | int     |
+-------------+---------+
The table logs the spendings history of users that make purchases from an online shopping website which has a desktop and a mobile application.
(user_id, spend_date, platform) is the primary key of this table.
The platform column is an ENUM type of ('desktop', 'mobile').

    Write an SQL query to find the total number of users and the total amount spent using
        mobile only, desktop only and both mobile
        and desktop together for each date.

    The query result format is in the following example:

    Spending table:
+---------+------------+----------+--------+
| user_id | spend_date | platform | amount |
+---------+------------+----------+--------+
| 1       | 2019-07-01 | mobile   | 100    |
| 1       | 2019-07-01 | desktop  | 100    |
| 2       | 2019-07-01 | mobile   | 100    |
| 2       | 2019-07-02 | mobile   | 100    |
| 3       | 2019-07-01 | desktop  | 100    |
| 3       | 2019-07-02 | desktop  | 100    |
+---------+------------+----------+--------+

Result table:
+------------+----------+--------------+-------------+
| spend_date | platform | total_amount | total_users |
+------------+----------+--------------+-------------+
| 2019-07-01 | desktop  | 100          | 1           |
| 2019-07-01 | mobile   | 100          | 1           |
| 2019-07-01 | both     | 200          | 1           |
| 2019-07-02 | desktop  | 100          | 1           |
| 2019-07-02 | mobile   | 100          | 1           |
| 2019-07-02 | both     | 0            | 0           |
+------------+----------+--------------+-------------+
On 2019-07-01, user 1 purchased using both desktop and mobile, user 2 purchased using mobile only and user 3 purchased using desktop only.
On 2019-07-02, user 2 purchased using mobile only, user 3 purchased using desktop only and no one purchased using both platforms.
-----------------

# 1460_Make_Two_Arrays_Equal_by_Reversing_Sub-arrays
# 1460. Make Two Arrays Equal by Reversing Sub-arrays


-----------------

# 1845_Seat_Reservation_Manager
# 1845. Seat Reservation Manager


-----------------

# 645_Set_Mismatch
# 645. Set Mismatch

The set S originally contains numbers from 1 to n. But
        unfortunately, due to the data error, one of the numbers in the set got duplicated to another
        number in the set, which results in repetition of one number and loss of another number.
    

    
        Given an array nums representing the data status of this set after the error.
        Your task is to firstly find the number occurs twice and then find the number that is
        missing. Return them in the form of an array.
    

    Example 1:
    Input: nums = [1,2,2,4]
Output: [2,3]

    

    Note:
    
        The given array size will in the range [2, 10000].
        The given array's numbers won't have any order.
-----------------

# 226_Invert_Binary_Tree
# 226. Invert Binary Tree

Invert a binary tree.

    Example:

    Input:

         4
   /   \
  2     7
 / \   / \
1   3 6   9

    Output:

         4
   /   \
  7     2
 / \   / \
9   6 3   1

    Trivia:
        This problem was inspired by this original tweet by Max Howell:

    Google: 90% of our engineers use the software you wrote (Homebrew), but you can’t
        invert a binary tree on a whiteboard so f*** off.
-----------------

# 1191_K-Concatenation_Maximum_Sum
# 1191. K-Concatenation Maximum Sum

Given an integer array arr and an integer k, modify the array
        by repeating it k times.

    For example, if arr = [1, 2] and k = 3 then the modified array
        will be [1, 2, 1, 2, 1, 2].

    Return the maximum sub-array sum in the modified array. Note that the length of the sub-array
        can be 0 and its sum in that case is 0.

    As the answer can be very large, return the answer modulo 10^9
        + 7.

     
    Example 1:

    Input: arr = [1,2], k = 3
Output: 9

    Example 2:

    Input: arr = [1,-2,1], k = 5
Output: 2

    Example 3:

    Input: arr = [-1,-2], k = 7
Output: 0

     
    Constraints:

    
        1 <= arr.length <= 10^5
        1 <= k <= 10^5
        -10^4 <= arr[i] <= 10^4
-----------------

# 1513_Number_of_Substrings_With_Only_1s
# 1513. Number of Substrings With Only 1s


-----------------

# 838_Push_Dominoes
# 838. Push Dominoes

There are N dominoes in a line, and we place
        each domino vertically upright.

    In the beginning, we simultaneously push some of the dominoes either to the left or to
        the right.

    

    After each second, each domino that is falling to the left pushes the adjacent domino on the
        left.

    Similarly, the dominoes falling to the right push their adjacent dominoes standing on the
        right.

    When a vertical domino has dominoes falling on it from both sides, it stays still due to the
        balance of the forces.

    For the purposes of this question, we will consider that a falling domino expends no
        additional force to a falling or already fallen domino.

    Given a string "S" representing the initial state. S[i] =
        'L', if the i-th domino has been pushed to the left; S[i] =
        'R', if the i-th domino has been pushed to the right; S[i] = '.', if
        the i-th domino has not been pushed.

    Return a string representing the final state. 

    Example 1:

    Input: ".L.R...LR..L.."
Output: "LL.RR.LLRRLL.."

    Example 2:

    Input: "RR.L"
Output: "RR.L"
Explanation: The first domino expends no additional force on the second domino.

    Note:

    
        0 <= N <= 10^5
        String dominoes contains only 'L', 'R'
            and '.'
-----------------

# 584_Find_Customer_Referee
# 584. Find Customer Referee

Given a table customer holding customers information and the referee.

    +------+------+-----------+
| id   | name | referee_id|
+------+------+-----------+
|    1 | Will |      NULL |
|    2 | Jane |      NULL |
|    3 | Alex |         2 |
|    4 | Bill |      NULL |
|    5 | Zack |         1 |
|    6 | Mark |         2 |
+------+------+-----------+

    Write a query to return the list of customers NOT referred by the person with id '2'.
    

    For the sample data above, the result is:

    +------+
| name |
+------+
| Will |
| Jane |
| Bill |
| Zack |
+------+
-----------------

# 1128_Number_of_Equivalent_Domino_Pairs
# 1128. Number of Equivalent Domino Pairs

Given a list of dominoes, dominoes[i] = [a, b] is equivalent
        to dominoes[j] = [c, d] if and only if either (a==c and
        b==d), or (a==d and b==c) - that is, one domino can
        be rotated to be equal to another domino.

    Return the number of pairs (i, j) for which 0 <= i < j <
        dominoes.length, and dominoes[i] is equivalent to
        dominoes[j].

     
    Example 1:
    Input: dominoes = [[1,2],[2,1],[3,4],[5,6]]
Output: 1

     
    Constraints:

    
        1 <= dominoes.length <= 40000
        1 <= dominoes[i][j] <= 9
-----------------

# 1683_Invalid_Tweets
# 1683. Invalid Tweets


-----------------

# 1562_Find_Latest_Group_of_Size_M
# 1562. Find Latest Group of Size M


-----------------

# 1456_Maximum_Number_of_Vowels_in_a_Substring_of_Given_Length
# 1456. Maximum Number of Vowels in a Substring of Given Length


-----------------

# 328_Odd_Even_Linked_List
# 328. Odd Even Linked List

Given a singly linked list, group all odd nodes together followed by the even nodes. Please
        note here we are talking about the node number and not the value in the nodes.

    You should try to do it in place. The program should run in O(1) space complexity and
        O(nodes) time complexity.

    Example 1:

    Input: 1->2->3->4->5->NULL
Output: 1->3->5->2->4->NULL

    Example 2:

    Input: 2->1->3->5->6->4->7->NULL
Output: 2->3->6->7->1->5->4->NULL

    Note:

    
        The relative order inside both the even and odd groups should remain as it was in the
            input.
        
        The first node is considered odd, the second node even and so on ...
-----------------

# 818_Race_Car
# 818. Race Car

Your car starts at position 0 and speed +1 on an infinite number line.  (Your car can go
        into negative positions.)

    Your car drives automatically according to a sequence of instructions A (accelerate) and R
        (reverse).

    When you get an instruction "A", your car does the following: position
        += speed, speed *= 2.

    When you get an instruction "R", your car does the following: if your speed is
        positive then speed = -1 , otherwise speed = 1. 
        (Your position stays the same.)

    For example, after commands "AAR", your car goes to positions 0->1->3->3,
        and your speed goes to 1->2->4->-1.

    Now for some target position, say the length of the shortest sequence of
        instructions to get there.

    Example 1:
Input:
target = 3
Output: 2
Explanation:
The shortest instruction sequence is "AA".
Your position goes from 0->1->3.

    Example 2:
Input:
target = 6
Output: 5
Explanation:
The shortest instruction sequence is "AAARA".
Your position goes from 0->1->3->7->7->6.

     

    Note: 

    
        1 <= target <= 10000.
-----------------

# 450_Delete_Node_in_a_BST
# 450. Delete Node in a BST

Given a root node reference of a BST and a key, delete the node with the given key in the
        BST. Return the root node reference (possibly updated) of the BST.

    Basically, the deletion can be divided into two stages:
    
        Search for a node to remove.
        If the node is found, delete the node.
    
    

    Note: Time complexity should be O(height of tree).

    Example:
    root = [5,3,6,2,4,null,7]
key = 3

    5
   / \
  3   6
 / \   \
2   4   7

Given key to delete is 3. So we find the node with value 3 and delete it.

One valid answer is [5,4,6,2,null,null,7], shown in the following BST.

    5
   / \
  4   6
 /     \
2       7

Another valid answer is [5,2,6,null,4,null,7].

    5
   / \
  2   6
   \   \
    4   7
-----------------

# 438_Find_All_Anagrams_in_a_String
# 438. Find All Anagrams in a String

Given a string s and a non-empty string p, find all the start indices of
        p's anagrams in s.

    Strings consists of lowercase English letters only and the length of both strings s
        and p will not be larger than 20,100.

    The order of output does not matter.

    Example 1:
    Input:
s: "cbaebabacd" p: "abc"

Output:
[0, 6]

Explanation:
The substring with start index = 0 is "cba", which is an anagram of "abc".
The substring with start index = 6 is "bac", which is an anagram of "abc".

    

    Example 2:
    Input:
s: "abab" p: "ab"

Output:
[0, 1, 2]

Explanation:
The substring with start index = 0 is "ab", which is an anagram of "ab".
The substring with start index = 1 is "ba", which is an anagram of "ab".
The substring with start index = 2 is "ab", which is an anagram of "ab".
-----------------

# 1583_Count_Unhappy_Friends
# 1583. Count Unhappy Friends


-----------------

# 1505_Minimum_Possible_Integer_After_at_Most_K_Adjacent_Swaps_On_Digits
# 1505. Minimum Possible Integer After at Most K Adjacent Swaps On Digits


-----------------

# 266_Palindrome_Permutation
# 266. Palindrome Permutation

Given a string, determine if a permutation of the string could form a palindrome.

    Example 1:

    Input: "code"
Output: false

    Example 2:

    Input: "aab"
Output: true

    Example 3:

    Input: "carerac"
Output: true
-----------------

# 1295_Find_Numbers_with_Even_Number_of_Digits
# 1295. Find Numbers with Even Number of Digits


-----------------

# 1302_Deepest_Leaves_Sum
# 1302. Deepest Leaves Sum


-----------------

# 286_Walls_and_Gates
# 286. Walls and Gates

You are given a m x n 2D grid initialized with these three possible values.

    
        -1 - A wall or an obstacle.
        0 - A gate.
        INF - Infinity means an empty room. We use the value 231 -
            1 = 2147483647 to represent INF as you may assume that the distance
            to a gate is less than 2147483647.
        
    

    Fill each empty room with the distance to its nearest gate. If it is impossible to
        reach a gate, it should be filled with INF.

    Example: 

    Given the 2D grid:

    INF  -1  0  INF
INF INF INF  -1
INF  -1 INF  -1
  0  -1 INF INF

    After running your function, the 2D grid should be:

      3  -1   0   1
  2   2   1  -1
  1  -1   2  -1
  0  -1   3   4
-----------------

# 1374_Generate_a_String_With_Characters_That_Have_Odd_Counts
# 1374. Generate a String With Characters That Have Odd Counts


-----------------

# 1508_Range_Sum_of_Sorted_Subarray_Sums
# 1508. Range Sum of Sorted Subarray Sums


-----------------

# 710_Random_Pick_with_Blacklist
# 710. Random Pick with Blacklist

Given a blacklist B containing unique integers from [0,
        N), write a function to return a uniform random integer from [0, N)
        which is NOT in B.

    Optimize it such that it minimizes the call to system’s Math.random().

    Note:

    
        1 <= N <= 1000000000
        0 <= B.length < min(100000, N)
        [0, N) does NOT include N. See interval
            notation.
        
    

    Example 1:

    Input:
["Solution","pick","pick","pick"]
[[1,[]],[],[],[]]
Output: [null,0,0,0]

    Example 2:

    Input:
["Solution","pick","pick","pick"]
[[2,[]],[],[],[]]
Output: [null,1,1,1]

    Example 3:

    Input:
["Solution","pick","pick","pick"]
[[3,[1]],[],[],[]]
Output: [null,0,0,2]

    Example 4:

    Input:
["Solution","pick","pick","pick"]
[[4,[2]],[],[],[]]
Output: [null,1,3,1]

    Explanation of Input Syntax:

    The input is two lists: the subroutines called and
        their arguments. Solution's constructor has two arguments, N
        and the blacklist B. pick has no arguments. Arguments are always
        wrapped with a list, even if there aren't any.
-----------------

# 745_Prefix_and_Suffix_Search
# 745. Prefix and Suffix Search

Given many words, words[i] has weight i.

    Design a class WordFilter that supports one function, WordFilter.f(String
        prefix, String suffix). It will return the word with given prefix and
        suffix with maximum weight. If no word exists, return -1.

    Examples:

    Input:
WordFilter(["apple"])
WordFilter.f("a", "e") // returns 0
WordFilter.f("b", "") // returns -1

     

    Note:

    
        words has length in range [1, 15000].
        For each test case, up to words.length queries WordFilter.f
            may be made.
        
        words[i] has length in range [1, 10].
        prefix, suffix have lengths in range [0, 10].
        words[i] and prefix, suffix queries consist of lowercase
            letters only.
-----------------

# 1431_Kids_With_the_Greatest_Number_of_Candies
# 1431. Kids With the Greatest Number of Candies


-----------------

# 1396_Design_Underground_System
# 1396. Design Underground System


-----------------

# 1008_Construct_Binary_Search_Tree_from_Preorder_Traversal
# 1008. Construct Binary Search Tree from Preorder Traversal

Return the root node of a binary search tree that matches the given preorder
        traversal.

    (Recall that a binary search tree is a binary tree where for every node, any descendant of node.left has a value
        < node.val, and any descendant of node.right
        has a value > node.val.  Also recall that a preorder
        traversal displays the value of the node first, then traverses node.left,
        then traverses node.right.)

     

    Example 1:

    Input: [8,5,1,7,10,12]
Output: [8,5,10,1,7,null,12]

     

    Note: 

    
        1 <= preorder.length <= 100
        The values of preorder are distinct.
-----------------

# 29_Divide_Two_Integers
# 29. Divide Two Integers

Given two integers dividend and divisor, divide two integers
        without using multiplication, division and mod operator.

    Return the quotient after dividing dividend by divisor.

    The integer division should truncate toward zero.

    Example 1:

    Input: dividend = 10, divisor = 3
Output: 3

    Example 2:

    Input: dividend = 7, divisor = -3
Output: -2

    Note:

    
        Both dividend and divisor will be 32-bit signed integers.
        The divisor will never be 0.
        Assume we are dealing with an environment which could only store integers within the
            32-bit signed integer range: [−231,  231 − 1].
            For the purpose of this problem, assume that your function returns 231
            − 1 when the division result overflows.
-----------------

# 576_Out_of_Boundary_Paths
# 576. Out of Boundary Paths

There is an m by n grid with a ball. Given the start coordinate (i,j) of
        the ball, you can move the ball to adjacent cell or cross the grid boundary in four
        directions (up, down, left, right). However, you can at most move N times.
        Find out the number of paths to move the ball out of grid boundary. The answer may be very
        large, return it after mod 109 + 7.

     

    Example 1:

    Input: m = 2, n = 2, N = 2, i = 0, j = 0
Output: 6
Explanation:

    Example 2:

    Input: m = 1, n = 3, N = 3, i = 0, j = 1
Output: 12
Explanation:

     

    Note:

    
        Once you move the ball out of boundary, you cannot move it back.
        The length and height of the grid is in range [1,50].
        N is in range [0,50].
-----------------

# 1593_Split_a_String_Into_the_Max_Number_of_Unique_Substrings
# 1593. Split a String Into the Max Number of Unique Substrings


-----------------

# 1328_Break_a_Palindrome
# 1328. Break a Palindrome


-----------------

# 194_Transpose_File
# 194. Transpose File

Given a text file file.txt, transpose its content.

    You may assume that each row has the same number of columns and each field is separated by
        the ' ' character.

    Example:

    If file.txt has the following content:

    name age
alice 21
ryan 30

    Output the following:

    name alice ryan
age 21 30
-----------------

# 1856_Maximum_Subarray_Min-Product
# 1856. Maximum Subarray Min-Product


-----------------

# 1820_Maximum_Number_of_Accepted_Invitations
# 1820. Maximum Number of Accepted Invitations


-----------------

# 496_Next_Greater_Element_I
# 496. Next Greater Element I

You are given two arrays (without duplicates) nums1 and
        nums2 where nums1’s elements are subset of nums2.
        Find all the next greater numbers for nums1's elements in the corresponding
        places of nums2.
    

    
        The Next Greater Number of a number x in nums1 is the first greater
        number to its right in nums2. If it does not exist, output -1 for this number.
    

    Example 1:
    Input: nums1 = [4,1,2], nums2 = [1,3,4,2].
Output: [-1,3,-1]
Explanation:
    For number 4 in the first array, you cannot find the next greater number for it in the second array, so output -1.
    For number 1 in the first array, the next greater number for it in the second array is 3.
    For number 2 in the first array, there is no next greater number for it in the second array, so output -1.

    

    Example 2:
    Input: nums1 = [2,4], nums2 = [1,2,3,4].
Output: [3,-1]
Explanation:
    For number 2 in the first array, the next greater number for it in the second array is 3.
    For number 4 in the first array, there is no next greater number for it in the second array, so output -1.

    

    Note:
    
        All elements in nums1 and nums2 are unique.
        The length of both nums1 and nums2 would not exceed 1000.
-----------------

# 108_Convert_Sorted_Array_to_Binary_Search_Tree
# 108. Convert Sorted Array to Binary Search Tree

Given an array where elements are sorted in ascending order, convert it to a height balanced
        BST.

    For this problem, a height-balanced binary tree is defined as a binary tree in which the
        depth of the two subtrees of every node never differ by more than 1.

    Example:

    Given the sorted array: [-10,-3,0,5,9],

One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST:

      0
     / \
   -3   9
   /   /
 -10  5
-----------------

# 1405_Longest_Happy_String
# 1405. Longest Happy String


-----------------

# 71_Simplify_Path
# 71. Simplify Path

Given an absolute path for a file (Unix-style), simplify it. Or in other
        words, convert it to the canonical path.

    In a UNIX-style file system, a period . refers to the current directory.
        Furthermore, a double period .. moves the directory up a level. For more
        information, see: Absolute path vs relative path in Linux/Unix
    

    Note that the returned canonical path must always begin with a slash /, and
        there must be only a single slash / between two directory names. The
        last directory name (if it exists) must not end with a trailing /.
        Also, the canonical path must be the shortest string representing the
        absolute path.

     

    Example 1:

    Input: "/home/"
Output: "/home"
Explanation: Note that there is no trailing slash after the last directory name.

    Example 2:

    Input: "/../"
Output: "/"
Explanation: Going one level up from the root directory is a no-op, as the root level is the highest level you can go.

    Example 3:

    Input: "/home//foo/"
Output: "/home/foo"
Explanation: In the canonical path, multiple consecutive slashes are replaced by a single one.

    Example 4:

    Input: "/a/./b/../../c/"
Output: "/c"

    Example 5:

    Input: "/a/../../b/../c//.//"
Output: "/c"

    Example 6:

    Input: "/a//b////c/d//././/.."
Output: "/a/b/c"
-----------------

# 380_Insert_Delete_GetRandom_O(1)
# 380. Insert Delete GetRandom O(1)

Design a data structure that supports all following operations in average O(1)
        time.

    
    
        insert(val): Inserts an item val to the set if not already present.
        remove(val): Removes an item val from the set if present.
        getRandom: Returns a random element from current set of elements. Each
            element must have the same probability of being returned.
        
    
    

    Example:
    // Init an empty set.
RandomizedSet randomSet = new RandomizedSet();

// Inserts 1 to the set. Returns true as 1 was inserted successfully.
randomSet.insert(1);

// Returns false as 2 does not exist in the set.
randomSet.remove(2);

// Inserts 2 to the set, returns true. Set now contains [1,2].
randomSet.insert(2);

// getRandom should return either 1 or 2 randomly.
randomSet.getRandom();

// Removes 1 from the set, returns true. Set now contains [2].
randomSet.remove(1);

// 2 was already in the set, so return false.
randomSet.insert(2);

// Since 2 is the only number in the set, getRandom always return 2.
randomSet.getRandom();
-----------------

# 743_Network_Delay_Time
# 743. Network Delay Time

There are N network nodes, labelled 1 to N.

    Given times, a list of travel times as directed edges times[i] =
        (u, v, w), where u is the source node, v is the target
        node, and w is the time it takes for a signal to travel from source to target.
    

    Now, we send a signal from a certain node K. How long will it take for all nodes
        to receive the signal? If it is impossible, return -1.

     

    Example 1:

    

    Input: times = [[2,1,1],[2,3,1],[3,4,1]], N = 4, K = 2
Output: 2

     

    Note:

    
        N will be in the range [1, 100].
        K will be in the range [1, N].
        The length of times will be in the range [1, 6000].
        All edges times[i] = (u, v, w) will have 1 <= u, v <= N
            and 0 <= w <= 100.
-----------------

# 167_Two_Sum_II_-_Input_array_is_sorted
# 167. Two Sum II - Input array is sorted

Given an array of integers that is already sorted in ascending
        order, find two numbers such that they add up to a specific target number.

    The function twoSum should return indices of the two numbers such that they add up to the
        target, where index1 must be less than index2.

    Note:

    
        Your returned answers (both index1 and index2) are not zero-based.
        You may assume that each input would have exactly one solution and you may not
            use the same element twice.
        
    

    Example:

    Input: numbers = [2,7,11,15], target = 9
Output: [1,2]
Explanation: The sum of 2 and 7 is 9. Therefore index1 = 1, index2 = 2.
-----------------

# 1496_Path_Crossing
# 1496. Path Crossing


-----------------

# 1056_Confusing_Number
# 1056. Confusing Number

Given a number N, return true if and only if it is a confusing
        number, which satisfies the following condition:

    We can rotate digits by 180 degrees to form new digits. When 0, 1, 6, 8, 9 are rotated 180
        degrees, they become 0, 1, 9, 8, 6 respectively. When 2, 3, 4, 5 and 7 are rotated 180
        degrees, they become invalid. A confusing number is a number that when rotated 180
        degrees becomes a different number with each digit valid.

     

    Example 1:

    

    Input: 6
Output: true
Explanation: 
We get 9 after rotating 6, 9 is a valid number and 9!=6.

    Example 2:

    

    Input: 89
Output: true
Explanation: 
We get 68 after rotating 89, 86 is a valid number and 86!=89.

    Example 3:

    

    Input: 11
Output: false
Explanation: 
We get 11 after rotating 11, 11 is a valid number but the value remains the same, thus 11 is not a confusing number.

    Example 4:

    

    Input: 25
Output: false
Explanation: 
We get an invalid number after rotating 25.

     

    Note:

    
        0 <= N <= 10^9
        After the rotation we can ignore leading zeros, for example if after rotation we have
            0008 then this number is considered as just 8.
-----------------

# 688_Knight_Probability_in_Chessboard
# 688. Knight Probability in Chessboard

On an NxN chessboard, a knight starts at the r-th row
        and c-th column and attempts to make exactly K moves. The rows and
        columns are 0 indexed, so the top-left square is (0, 0), and the bottom-right
        square is (N-1, N-1).

    A chess knight has 8 possible moves it can make, as illustrated below. Each move is two
        squares in a cardinal direction, then one square in an orthogonal direction.

     

    
        

     

    Each time the knight is to move, it chooses one of eight possible moves uniformly at random
        (even if the piece would go off the chessboard) and moves there.

    The knight continues moving until it has made exactly K moves or has moved off
        the chessboard. Return the probability that the knight remains on the board after it has
        stopped moving.

     

    Example:

    Input: 3, 2, 0, 0
Output: 0.0625
Explanation: There are two moves (to (1,2), (2,1)) that will keep the knight on the board.
From each of those positions, there are also two moves that will keep the knight on the board.
The total probability the knight stays on the board is 0.0625.

     

    Note:

    
        N will be between 1 and 25.
        K will be between 0 and 100.
        The knight always initially starts on the board.
-----------------

# 258_Add_Digits
# 258. Add Digits

Given a non-negative integer num, repeatedly add all its digits until the result
        has only one digit.

    Example:

    Input: 38
Output: 2
Explanation: The process is like: 3 + 8 = 11, 1 + 1 = 2.
             Since 2 has only one digit, return it.

    Follow up:
        Could you do it without any loop/recursion in O(1) runtime?
-----------------

# 1301_Number_of_Paths_with_Max_Score
# 1301. Number of Paths with Max Score


-----------------

# 1089_Duplicate_Zeros
# 1089. Duplicate Zeros

Given a fixed length array arr of integers, duplicate each occurrence of
        zero, shifting the remaining elements to the right.

    Note that elements beyond the length of the original array are not written.

    Do the above modifications to the input array in place, do not return
        anything from your function.

     

    Example 1:

    Input: [1,0,2,3,0,4,5,0]
Output: null
Explanation: After calling your function, the input array is modified to: [1,0,0,2,3,0,0,4]

    Example 2:

    Input: [1,2,3]
Output: null
Explanation: After calling your function, the input array is modified to: [1,2,3]

     

    Note:

    
        1 <= arr.length <= 10000
        0 <= arr[i] <= 9
-----------------

# 463_Island_Perimeter
# 463. Island Perimeter

You are given a map in form of a two-dimensional integer grid where 1 represents land and 0
        represents water.

    Grid cells are connected horizontally/vertically (not diagonally). The grid is completely
        surrounded by water, and there is exactly one island (i.e., one or more connected land
        cells).

    The island doesn't have "lakes" (water inside that isn't connected to the
        water around the island). One cell is a square with side length 1. The grid is rectangular,
        width and height don't exceed 100. Determine the perimeter of the island.

     

    Example:

    Input:
[[0,1,0,0],
 [1,1,1,0],
 [0,1,0,0],
 [1,1,0,0]]

Output: 16

Explanation: The perimeter is the 16 yellow stripes in the image below:
-----------------

# 1470_Shuffle_the_Array
# 1470. Shuffle the Array


-----------------

# 989_Add_to_Array-Form_of_Integer
# 989. Add to Array-Form of Integer

For a non-negative integer X, the array-form of X is
        an array of its digits in left to right order.  For example, if X = 1231,
        then the array form is [1,2,3,1].

    Given the array-form A of a non-negative integer X, return the
        array-form of the integer X+K.
-----------------

# 661_Image_Smoother
# 661. Image Smoother

Given a 2D integer matrix M representing the gray scale of an image, you need to design a
        smoother to make the gray scale of each cell becomes the average gray scale (rounding down)
        of all the 8 surrounding cells and itself. If a cell has less than 8 surrounding cells, then
        use as many as you can.

    Example 1:
    Input:
[[1,1,1],
 [1,0,1],
 [1,1,1]]
Output:
[[0, 0, 0],
 [0, 0, 0],
 [0, 0, 0]]
Explanation:
For the point (0,0), (0,2), (2,0), (2,2): floor(3/4) = floor(0.75) = 0
For the point (0,1), (1,0), (1,2), (2,1): floor(5/6) = floor(0.83333333) = 0
For the point (1,1): floor(8/9) = floor(0.88888889) = 0

    

    Note:
    
        The value in the given matrix is in the range of [0, 255].
        The length and width of the given matrix are in the range of [1, 150].
-----------------

# 1177_Can_Make_Palindrome_from_Substring
# 1177. Can Make Palindrome from Substring

Given a string s, we make queries on substrings of s.

    For each query queries[i] = [left, right, k], we may rearrange the
        substring s[left], ..., s[right], and then choose up to k
        of them to replace with any lowercase English letter. 

    If the substring is possible to be a palindrome string after the operations above,
        the result of the query is true. Otherwise, the result is
        false.

    Return an array answer[], where answer[i] is the result of the
        i-th query queries[i].

    Note that: Each letter is counted individually for replacement so if
        for example s[left..right] = "aaa", and k = 2, we
        can only replace two of the letters.  (Also, note that the initial string
        s is never modified by any query.)

     
    Example :

    Input: s = "abcda", queries = [[3,3,0],[1,2,0],[0,3,1],[0,3,2],[0,4,1]]
Output: [true,false,false,true,true]
Explanation:
queries[0] : substring = "d", is palidrome.
queries[1] : substring = "bc", is not palidrome.
queries[2] : substring = "abcd", is not palidrome after replacing only 1 character.
queries[3] : substring = "abcd", could be changed to "abba" which is palidrome. Also this can be changed to "baab" first rearrange it "bacd" then replace "cd" with "ab".
queries[4] : substring = "abcda", could be changed to "abcba" which is palidrome.

     
    Constraints:

    
        1 <= s.length, queries.length <= 10^5
        0 <= queries[i][0] <= queries[i][1] < s.length
        0 <= queries[i][2] <= s.length
        s only contains lowercase English letters.
-----------------

# 416_Partition_Equal_Subset_Sum
# 416. Partition Equal Subset Sum

Given a non-empty array containing only positive integers, find if the array
        can be partitioned into two subsets such that the sum of elements in both subsets is equal.
    

    Note:

    
        Each of the array element will not exceed 100.
        The array size will not exceed 200.
    

     

    Example 1:

    Input: [1, 5, 11, 5]

Output: true

Explanation: The array can be partitioned as [1, 5, 5] and [11].

     

    Example 2:

    Input: [1, 2, 3, 5]

Output: false

Explanation: The array cannot be partitioned into equal sum subsets.
-----------------

# 839_Similar_String_Groups
# 839. Similar String Groups

Two strings X and Y are similar if we can swap two
        letters (in different positions) of X, so that it equals Y.
    

    For example, "tars" and "rats" are
        similar (swapping at positions 0 and 2), and "rats"
        and "arts" are similar, but "star" is not
        similar to "tars", "rats", or "arts".
    

    Together, these form two connected groups by similarity: {"tars", "rats",
        "arts"} and {"star"}.  Notice that "tars"
        and "arts" are in the same group even though they are not similar. 
        Formally, each group is such that a word is in the group if and only if it is similar to at
        least one other word in the group.

    We are given a list A of strings.  Every string in A is an
        anagram of every other string in A.  How many groups are there?

    Example 1:

    Input: ["tars","rats","arts","star"]
Output: 2

    Note:

    
        A.length <= 2000
        A[i].length <= 1000
        A.length * A[i].length <= 20000
        All words in A consist of lowercase letters only.
        All words in A have the same length and are anagrams of each other.
        The judging time limit has been increased for this question.
-----------------

# 1229_Meeting_Scheduler
# 1229. Meeting Scheduler

Given the availability time slots arrays slots1 and slots2 of
        two people and a meeting duration duration, return the earliest time
            slot that works for both of them and is of duration duration.

    If there is no common time slot that satisfies the requirements, return an empty
        array.

    The format of a time slot is an array of two elements [start, end] representing
        an inclusive time range from start to end.  

    It is guaranteed that no two availability slots of the same person intersect with each other.
        That is, for any two time slots [start1, end1] and [start2,
            end2] of the same person, either start1 > end2 or start2
            > end1.

     
    Example 1:

    Input: slots1 = [[10,50],[60,120],[140,210]], slots2 = [[0,15],[60,70]], duration = 8
Output: [60,68]

    Example 2:

    Input: slots1 = [[10,50],[60,120],[140,210]], slots2 = [[0,15],[60,70]], duration = 12
Output: []

     
    Constraints:

    
        1 <= slots1.length, slots2.length <= 10^4
        slots1[i].length, slots2[i].length == 2
        slots1[i][0] < slots1[i][1]
        slots2[i][0] < slots2[i][1]
        0 <= slots1[i][j], slots2[i][j] <= 10^9
        1 <= duration <= 10^6
-----------------

# 388_Longest_Absolute_File_Path
# 388. Longest Absolute File Path

Suppose we abstract our file system by a string in the following manner:

    The string "dir\n\tsubdir1\n\tsubdir2\n\t\tfile.ext" represents:

    dir
    subdir1
    subdir2
        file.ext

    The directory dir contains an empty sub-directory subdir1 and a
        sub-directory subdir2 containing a file file.ext.

    The string "dir\n\tsubdir1\n\t\tfile1.ext\n\t\tsubsubdir1\n\tsubdir2\n\t\tsubsubdir2\n\t\t\tfile2.ext"
        represents:

    dir
    subdir1
        file1.ext
        subsubdir1
    subdir2
        subsubdir2
            file2.ext

    The directory dir contains two sub-directories subdir1 and subdir2.
        subdir1 contains a file file1.ext and an empty second-level
        sub-directory subsubdir1. subdir2 contains a second-level
        sub-directory subsubdir2 containing a file file2.ext.

    We are interested in finding the longest (number of characters) absolute path to a file
        within our file system. For example, in the second example above, the longest absolute path
        is "dir/subdir2/subsubdir2/file2.ext", and its length is 32 (not
        including the double quotes).

    Given a string representing the file system in the above format, return the length of the
        longest absolute path to file in the abstracted file system. If there is no file in the
        system, return 0.

    Note:
    
        The name of a file contains at least a . and an extension.
        The name of a directory or sub-directory will not contain a ..
    
    

    Time complexity required: O(n) where n is the size of the input
        string.

    Notice that a/aa/aaa/file1.txt is not the longest file path, if there is another
        path aaaaaaaaaaaaaaaaaaaaa/sth.png.
-----------------

# 1186_Maximum_Subarray_Sum_with_One_Deletion
# 1186. Maximum Subarray Sum with One Deletion

Given an array of integers, return the maximum sum for a non-empty subarray
        (contiguous elements) with at most one element deletion. In other words, you want to
        choose a subarray and optionally delete one element from it so that there is still at least
        one element left and the sum of the remaining elements is maximum possible.

    Note that the subarray needs to be non-empty after deleting one element.

     
    Example 1:

    Input: arr = [1,-2,0,3]
Output: 4
Explanation: Because we can choose [1, -2, 0, 3] and drop -2, thus the subarray [1, 0, 3] becomes the maximum value.

    Example 2:

    Input: arr = [1,-2,-2,3]
Output: 3
Explanation: We just choose [3] and it's the maximum sum.

    Example 3:

    Input: arr = [-1,-1,-1,-1]
Output: -1
Explanation: The final subarray needs to be non-empty. You can't choose [-1] and delete -1 from it, then get an empty subarray to make the sum equals to 0.

     
    Constraints:

    
        1 <= arr.length <= 10^5
        -10^4 <= arr[i] <= 10^4
-----------------

# 981_Time_Based_Key-Value_Store
# 981. Time Based Key-Value Store

Create a timebased key-value store class TimeMap, that supports two
        operations.

    1. set(string key, string value, int timestamp)

    
        Stores the key and value, along with the given
            timestamp.
        
    

    2. get(string key, int timestamp)

    
        Returns a value such that set(key, value, timestamp_prev) was called
            previously, with timestamp_prev <= timestamp.
        
        If there are multiple such values, it returns the one with the largest timestamp_prev.
        
        If there are no values, it returns the empty string ("").
-----------------

# 717_1-bit_and_2-bit_Characters
# 717. 1-bit and 2-bit Characters

We have two special characters. The first character can be represented by one bit
        0. The second character can be represented by two bits (10 or
        11). 

    Now given a string represented by several bits. Return whether the last character must be a
        one-bit character or not. The given string will always end with a zero.

    Example 1:
    Input:
bits = [1, 0, 0]
Output: True
Explanation:
The only way to decode it is two-bit character and one-bit character. So the last character is one-bit character.

    

    Example 2:
    Input:
bits = [1, 1, 1, 0]
Output: False
Explanation:
The only way to decode it is two-bit character and two-bit character. So the last character is NOT one-bit character.

    

    Note:
    1 <= len(bits) <= 1000.
    bits[i] is always 0 or 1.
-----------------

# 1178_Number_of_Valid_Words_for_Each_Puzzle
# 1178. Number of Valid Words for Each Puzzle

With respect to a given puzzle string, a word is valid if
    both the following conditions are satisfied:
    
        word contains the first letter of puzzle.
        For each letter in word, that letter is in puzzle.
            For example, if the puzzle is "abcdefg", then valid words are "faced",
            "cabbage", and "baggage"; while invalid words are "beefed"
            (doesn't include "a") and "based" (includes "s" which
            isn't in the puzzle).
        
    
    Return an array answer, where answer[i] is the number of words in the
    given word list words that are valid with respect to the puzzle puzzles[i].
     
    Example :

    Input:
words = ["aaaa","asas","able","ability","actt","actor","access"],
puzzles = ["aboveyz","abrodyz","abslute","absoryz","actresz","gaswxyz"]
Output: [1,1,3,2,4,0]
Explanation:
1 valid word for "aboveyz" : "aaaa"
1 valid word for "abrodyz" : "aaaa"
3 valid words for "abslute" : "aaaa", "asas", "able"
2 valid words for "absoryz" : "aaaa", "asas"
4 valid words for "actresz" : "aaaa", "asas", "actt", "access"
There're no valid words for "gaswxyz" cause none of the words in the list contains letter 'g'.

     
    Constraints:

    
        1 <= words.length <= 10^5
        4 <= words[i].length <= 50
        1 <= puzzles.length <= 10^4
        puzzles[i].length == 7
        words[i][j], puzzles[i][j] are English lowercase letters.
        Each puzzles[i] doesn't contain repeated characters.
-----------------

# 1541_Minimum_Insertions_to_Balance_a_Parentheses_String
# 1541. Minimum Insertions to Balance a Parentheses String


-----------------

# 55_Jump_Game
# 55. Jump Game

Given an array of non-negative integers, you are initially positioned at the first index of
        the array.

    Each element in the array represents your maximum jump length at that position.

    Determine if you are able to reach the last index.

    Example 1:

    Input: [2,3,1,1,4]
Output: true
Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.

    Example 2:

    Input: [3,2,1,0,4]
Output: false
Explanation: You will always arrive at index 3 no matter what. Its maximum
             jump length is 0, which makes it impossible to reach the last index.
-----------------

# 175_Combine_Two_Tables
# 175. Combine Two Tables

Table: Person

    +-------------+---------+
| Column Name | Type    |
+-------------+---------+
| PersonId    | int     |
| FirstName   | varchar |
| LastName    | varchar |
+-------------+---------+
PersonId is the primary key column for this table.

    Table: Address

    +-------------+---------+
| Column Name | Type    |
+-------------+---------+
| AddressId   | int     |
| PersonId    | int     |
| City        | varchar |
| State       | varchar |
+-------------+---------+
AddressId is the primary key column for this table.

     

    Write a SQL query for a report that provides the following information for each person in the
        Person table, regardless if there is an address for each of those people:

    FirstName, LastName, City, State
-----------------

# 1626_Best_Team_With_No_Conflicts
# 1626. Best Team With No Conflicts


-----------------

# 1464_Maximum_Product_of_Two_Elements_in_an_Array
# 1464. Maximum Product of Two Elements in an Array


-----------------

# 637_Average_of_Levels_in_Binary_Tree
# 637. Average of Levels in Binary Tree

Given a non-empty binary tree, return the average value of the nodes on each level in the form
    of an array.

    Example 1:
    Input:
    3
   / \
  9  20
    /  \
   15   7
Output: [3, 14.5, 11]
Explanation:
The average value of nodes on level 0 is 3,  on level 1 is 14.5, and on level 2 is 11. Hence return [3, 14.5, 11].

    

    Note:
    
        The range of node's value is in the range of 32-bit signed integer.
-----------------

# 1204_Last_Person_to_Fit_in_the_Elevator
# 1204. Last Person to Fit in the Elevator

Table: Queue

    +-------------+---------+
| Column Name | Type    |
+-------------+---------+
| person_id   | int     |
| person_name | varchar |
| weight      | int     |
| turn        | int     |
+-------------+---------+
person_id is the primary key column for this table.
This table has the information about all people waiting for an elevator.
The person_id and turn columns will contain all numbers from 1 to n, where n is the number of rows in the table.

     

    The maximum weight the elevator can hold is 1000.

    Write an SQL query to find the person_name of the last person who will fit
        in the elevator without exceeding the weight limit. It is guaranteed that the person who is first
        in the queue can fit in the elevator.

    The query result format is in the following example:

    Queue table
+-----------+-------------------+--------+------+
| person_id | person_name       | weight | turn |
+-----------+-------------------+--------+------+
| 5         | George Washington | 250    | 1    |
| 3         | John Adams        | 350    | 2    |
| 6         | Thomas Jefferson  | 400    | 3    |
| 2         | Will Johnliams    | 200    | 4    |
| 4         | Thomas Jefferson  | 175    | 5    |
| 1         | James Elephant    | 500    | 6    |
+-----------+-------------------+--------+------+

Result table
+-------------------+
| person_name       |
+-------------------+
| Thomas Jefferson  |
+-------------------+

Queue table is ordered by turn in the example for simplicity.
In the example George Washington(id 5), John Adams(id 3) and Thomas Jefferson(id 6) will enter the elevator as their weight sum is 250 + 350 + 400 = 1000.
Thomas Jefferson(id 6) is the last person to fit in the elevator because he has the last turn in these three people.
-----------------

# 997_Find_the_Town_Judge
# 997. Find the Town Judge

In a town, there are N people labelled from 1 to
        N.  There is a rumor that one of these people is secretly the town judge.
    

    If the town judge exists, then:

    
        The town judge trusts nobody.
        Everybody (except for the town judge) trusts the town judge.
        There is exactly one person that satisfies properties 1 and 2.
    

    You are given trust, an array of pairs trust[i] = [a, b]
        representing that the person labelled a trusts the person labelled
        b.

    If the town judge exists and can be identified, return the label of the town judge. 
        Otherwise, return -1.

     

    Example 1:

    Input: N = 2, trust = [[1,2]]
Output: 2
-----------------

# 1681_Minimum_Incompatibility
# 1681. Minimum Incompatibility


-----------------

# 397_Integer_Replacement
# 397. Integer Replacement

Given a positive integer n and you can do operations as follow:
    

    
    
        If n is even, replace n with n/2.
        If n is odd, you can replace n with either n + 1 or
            n - 1.
        
    
    

    
        What is the minimum number of replacements needed for n to become 1?
    

    

    Example 1:
    Input:
8

Output:
3

Explanation:
8 -> 4 -> 2 -> 1

    

    Example 2:
    Input:
7

Output:
4

Explanation:
7 -> 8 -> 4 -> 2 -> 1
or
7 -> 6 -> 3 -> 2 -> 1
-----------------

# 52_N-Queens_II
# 52. N-Queens II

The n-queens puzzle is the problem of placing n queens on an n×n
        chessboard such that no two queens attack each other.

    
        

    Given an integer n, return the number of distinct solutions to
        the n-queens puzzle.

    Example:

    Input: 4
Output: 2
Explanation: There are two distinct solutions to the 4-queens puzzle as shown below.
[
 [".Q..",  // Solution 1
  "...Q",
  "Q...",
  "..Q."],

 ["..Q.",  // Solution 2
  "Q...",
  "...Q",
  ".Q.."]
]
-----------------

# 669_Trim_a_Binary_Search_Tree
# 669. Trim a Binary Search Tree

Given a binary search tree and the lowest and highest boundaries as L and
        R, trim the tree so that all its elements lies in [L, R] (R >= L).
        You might need to change the root of the tree, so the result should return the new root of
        the trimmed binary search tree.
    

    Example 1:
    Input:
    1
   / \
  0   2

  L = 1
  R = 2

Output:
    1
      \
       2

    

    Example 2:
    Input:
    3
   / \
  0   4
   \
    2
   /
  1

  L = 1
  R = 3

Output:
      3
     /
   2
  /
 1
-----------------

# 1169_Invalid_Transactions
# 1169. Invalid Transactions

A transaction is possibly invalid if:

    
        the amount exceeds $1000, or;
        if it occurs within (and including) 60 minutes of another transaction with the same name
            in a different city.
        
    

    Each transaction string transactions[i] consists of comma separated
        values representing the name, time (in minutes), amount, and city of the transaction.
    

    Given a list of transactions, return a list of transactions that are
        possibly invalid.  You may return the answer in any order.

     
    Example 1:

    Input: transactions = ["alice,20,800,mtv","alice,50,100,beijing"]
Output: ["alice,20,800,mtv","alice,50,100,beijing"]
Explanation: The first transaction is invalid because the second transaction occurs within a difference of 60 minutes, have the same name and is in a different city. Similarly the second one is invalid too.

    Example 2:

    Input: transactions = ["alice,20,800,mtv","alice,50,1200,mtv"]
Output: ["alice,50,1200,mtv"]

    Example 3:

    Input: transactions = ["alice,20,800,mtv","bob,50,1200,mtv"]
Output: ["bob,50,1200,mtv"]

     
    Constraints:

    
        transactions.length <= 1000
        Each transactions[i] takes the form "{name},{time},{amount},{city}"
        
        Each {name} and {city} consist of lowercase English
            letters, and have lengths between 1 and 10.
        
        Each {time} consist of digits, and represent an integer between 0
            and 1000.
        
        Each {amount} consist of digits, and represent an integer between
            0 and 2000.
-----------------

# 14_Longest_Common_Prefix
# 14. Longest Common Prefix

Write a function to find the longest common prefix string amongst an array of strings.

    If there is no common prefix, return an empty string "".

    Example 1:

    Input: ["flower","flow","flight"]
Output: "fl"

    Example 2:

    Input: ["dog","racecar","car"]
Output: ""
Explanation: There is no common prefix among the input strings.

    Note:

    All given inputs are in lowercase letters a-z.
-----------------

# 1627_Graph_Connectivity_With_Threshold
# 1627. Graph Connectivity With Threshold


-----------------

# 193_Valid_Phone_Numbers
# 193. Valid Phone Numbers

Given a text file file.txt that contains list of phone numbers (one per line),
        write a one liner bash script to print all valid phone numbers.

    You may assume that a valid phone number must appear in one of the following two formats:
        (xxx) xxx-xxxx or xxx-xxx-xxxx. (x means a digit)

    You may also assume each line in the text file must not contain leading or trailing white
        spaces.

    Example:

    Assume that file.txt has the following content:

    987-123-4567
123 456 7890
(123) 456-7890

    Your script should output the following valid phone numbers:

    987-123-4567
(123) 456-7890
-----------------

# 1092_Shortest_Common_Supersequence
# 1092. Shortest Common Supersequence

Given two strings str1 and str2, return the shortest string
        that has both str1 and str2 as subsequences.  If
        multiple answers exist, you may return any of them.

    (A string S is a subsequence of string T if deleting some number of characters from T
        (possibly 0, and the characters are chosen anywhere from T) results in the string S.)
    

     

    Example 1:

    Input: str1 = "abac", str2 = "cab"
Output: "cabac"
Explanation: 
str1 = "abac" is a subsequence of "cabac" because we can delete the first "c".
str2 = "cab" is a subsequence of "cabac" because we can delete the last "ac".
The answer provided is the shortest such string that satisfies these properties.

     

    Note:

    
        1 <= str1.length, str2.length <= 1000
        str1 and str2 consist of lowercase English letters.
-----------------

# 89_Gray_Code
# 89. Gray Code

The gray code is a binary numeral system where two successive values differ in only one
        bit.

    Given a non-negative integer n representing the total number of bits in the code,
        print the sequence of gray code. A gray code sequence must begin with 0.

    Example 1:

    Input: 2
Output: [0,1,3,2]
Explanation:
00 - 0
01 - 1
11 - 3
10 - 2

For a given n, a gray code sequence may not be uniquely defined.
For example, [0,2,3,1] is also a valid gray code sequence.

00 - 0
10 - 2
11 - 3
01 - 1

    Example 2:

    Input: 0
Output: [0]
Explanation: We define the gray code sequence to begin with 0.
             A gray code sequence of n has size = 2n, which for n = 0 the size is 20 = 1.
             Therefore, for n = 0 the gray code sequence is [0].
-----------------

# 426_Convert_Binary_Search_Tree_to_Sorted_Doubly_Linked_List
# 426. Convert Binary Search Tree to Sorted Doubly Linked List

Convert a BST to a sorted circular doubly-linked list in-place. Think of the left and right
        pointers as synonymous to the previous and next pointers in a doubly-linked list.

    Let's take the following BST as an example, it may help you understand the problem
        better:
     

    
        
     

    We want to transform this BST into a circular doubly linked list. Each node in a doubly
        linked list has a predecessor and successor. For a circular doubly linked list, the
        predecessor of the first element is the last element, and the successor of the last element
        is the first element.

    The figure below shows the circular doubly linked list for the BST above. The "head"
        symbol means the node it points to is the smallest element of the linked list.
     

    
        
     

    Specifically, we want to do the transformation in place. After the transformation, the left
        pointer of the tree node should point to its predecessor, and the right pointer should point
        to its successor. We should return the pointer to the first element of the linked list.

    The figure below shows the transformed BST. The solid line indicates the successor
        relationship, while the dashed line means the predecessor relationship.
-----------------

# 705_Design_HashSet
# 705. Design HashSet

Design a HashSet without using any built-in hash table libraries.

    To be specific, your design should include these functions:

    
        add(value): Insert a value into the HashSet. 
        contains(value) : Return whether the value exists in the HashSet or not.
        
        remove(value): Remove a value in the HashSet. If the value does not
            exist in the HashSet, do nothing.
        
    

    
        Example:

    MyHashSet hashSet = new MyHashSet();
hashSet.add(1);        
hashSet.add(2);        
hashSet.contains(1);    // returns true
hashSet.contains(3);    // returns false (not found)
hashSet.add(2);          
hashSet.contains(2);    // returns true
hashSet.remove(2);          
hashSet.contains(2);    // returns false (already removed)

    
        Note:

    
        All values will be in the range of [0, 1000000].
        The number of operations will be in the range of [1, 10000].
        Please do not use the built-in HashSet library.
-----------------

# 228_Summary_Ranges
# 228. Summary Ranges

Given a sorted integer array without duplicates, return the summary of its ranges.

    Example 1:

    Input:  [0,1,2,4,5,7]
Output: ["0->2","4->5","7"]
Explanation: 0,1,2 form a continuous range; 4,5 form a continuous range.

    Example 2:

    Input:  [0,2,3,4,6,8,9]
Output: ["0","2->4","6","8->9"]
Explanation: 2,3,4 form a continuous range; 8,9 form a continuous range.
-----------------

# 106_Construct_Binary_Tree_from_Inorder_and_Postorder_Traversal
# 106. Construct Binary Tree from Inorder and Postorder Traversal

Given inorder and postorder traversal of a tree, construct the binary tree.

    Note:
        You may assume that duplicates do not exist in the tree.

    For example, given

    inorder = [9,3,15,20,7]
postorder = [9,15,7,20,3]

    Return the following binary tree:

        3
   / \
  9  20
    /  \
   15   7
-----------------

# 1250_Check_If_It_Is_a_Good_Array
# 1250. Check If It Is a Good Array

Given an array nums of positive integers. Your task is to select some
        subset of nums, multiply each element by an integer and add all these numbers. The
        array is said to be good if you can obtain a sum
        of 1 from the array by any possible subset and multiplicand.

    Return True if the array is good otherwise return False.
    

     
    Example 1:

    Input: nums = [12,5,7,23]
Output: true
Explanation: Pick numbers 5 and 7.
5*3 + 7*(-2) = 1

    Example 2:

    Input: nums = [29,6,10]
Output: true
Explanation: Pick numbers 29, 6 and 10.
29*1 + 6*(-3) + 10*(-1) = 1

    Example 3:

    Input: nums = [3,6]
Output: false

     
    Constraints:

    
        1 <= nums.length <= 10^5
        1 <= nums[i] <= 10^9
-----------------

# 62_Unique_Paths
# 62. Unique Paths

A robot is located at the top-left corner of a m x n grid (marked 'Start'
        in the diagram below).

    The robot can only move either down or right at any point in time. The robot is trying to
        reach the bottom-right corner of the grid (marked 'Finish' in the diagram
        below).

    How many possible unique paths are there?

    
        
        Above is a 7 x 3 grid. How many possible unique paths are there?
    

    Note: m and n will be at most 100.

    Example 1:

    Input: m = 3, n = 2
Output: 3
Explanation:
From the top-left corner, there are a total of 3 ways to reach the bottom-right corner:
1. Right -> Right -> Down
2. Right -> Down -> Right
3. Down -> Right -> Right

    Example 2:

    Input: m = 7, n = 3
Output: 28
-----------------

# 26_Remove_Duplicates_from_Sorted_Array
# 26. Remove Duplicates from Sorted Array

Given a sorted array nums, remove the duplicates in-place such that each element appear only once
        and return the new length.

    Do not allocate extra space for another array, you must do this by modifying the
        input array in-place
        with O(1) extra memory.

    Example 1:

    Given nums = [1,1,2],

Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively.

It doesn't matter what you leave beyond the returned length.

    Example 2:

    Given nums = [0,0,1,1,1,2,2,3,3,4],

Your function should return length = 5, with the first five elements of nums being modified to 0, 1, 2, 3, and 4 respectively.

It doesn't matter what values are set beyond the returned length.

    Clarification:

    Confused why the returned value is an integer but your answer is an array?

    Note that the input array is passed in by reference, which means
        modification to the input array will be known to the caller as well.

    Internally you can think of this:

    // nums is passed in by reference. (i.e., without making a copy)
int len = removeDuplicates(nums);

// any modification to nums in your function would be known by the caller.
// using the length returned by your function, it prints the first len elements.
for (int i = 0; i < len; i++) {
    print(nums[i]);
}
-----------------

# 82_Remove_Duplicates_from_Sorted_List_II
# 82. Remove Duplicates from Sorted List II

Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct
        numbers from the original list.

    Example 1:

    Input: 1->2->3->3->4->4->5
Output: 1->2->5

    Example 2:

    Input: 1->1->1->2->3
Output: 2->3
-----------------

# 627_Swap_Salary
# 627. Swap Salary

Given a table salary, such as the one below, that has m=male and f=female
        values. Swap all f and m values (i.e., change all f values to m and vice versa) with a
        single update statement and no intermediate temp table.

    Note that you must write a single update statement, DO NOT write any select
        statement for this problem.

     

    Example:

    | id | name | sex | salary |
|----|------|-----|--------|
| 1  | A    | m   | 2500   |
| 2  | B    | f   | 1500   |
| 3  | C    | m   | 5500   |
| 4  | D    | f   | 500    |

    After running your update statement, the above salary table should have the
    following rows:

    | id | name | sex | salary |
|----|------|-----|--------|
| 1  | A    | f   | 2500   |
| 2  | B    | m   | 1500   |
| 3  | C    | f   | 5500   |
| 4  | D    | m   | 500    |
-----------------

# 354_Russian_Doll_Envelopes
# 354. Russian Doll Envelopes

You have a number of envelopes with widths and heights given as a pair of integers (w,
        h). One envelope can fit into another if and only if both the width and height of one
        envelope is greater than the width and height of the other envelope.

    What is the maximum number of envelopes can you Russian doll? (put one inside other)

    Note:
        Rotation is not allowed.

    Example:
-----------------

# 852_Peak_Index_in_a_Mountain_Array
# 852. Peak Index in a Mountain Array

Let's call an array A a mountain if the following properties
        hold:

    
        A.length >= 3
        There exists some 0 < i < A.length - 1 such that A[0] <
            A[1] < ... A[i-1] < A[i] > A[i+1] > ... > A[A.length - 1]
    

    Given an array that is definitely a mountain, return any i such that A[0]
        < A[1] < ... A[i-1] < A[i] > A[i+1] > ... > A[A.length - 1].

    Example 1:

    Input: [0,1,0]
Output: 1
-----------------

# 1415_The_k-th_Lexicographical_String_of_All_Happy_Strings_of_Length_n
# 1415. The k-th Lexicographical String of All Happy Strings of Length n


-----------------

# 870_Advantage_Shuffle
# 870. Advantage Shuffle

Given two arrays A and B of equal size, the advantage of A
        with respect to B is the number of indices i for which
        A[i] > B[i].

    Return any permutation of A that maximizes its advantage with
        respect to B.
-----------------

# 643_Maximum_Average_Subarray_I
# 643. Maximum Average Subarray I

Given an array consisting of n integers, find the contiguous subarray of given
        length k that has the maximum average value. And you need to output the maximum
        average value.

    Example 1:

    Input: [1,12,-5,-6,50,3], k = 4
Output: 12.75
Explanation: Maximum average is (12-5-6+50)/4 = 51/4 = 12.75

     

    Note:

    
        1 <= k <= n <= 30,000.
        Elements of the given array will be in the range [-10,000, 10,000].
-----------------

# 1153_String_Transforms_Into_Another_String
# 1153. String Transforms Into Another String

Given two strings str1 and str2 of the same length, determine
        whether you can transform str1 into str2 by doing zero
            or more conversions.

    In one conversion you can convert all occurrences of one character in
        str1 to any other lowercase English character.

    Return true if and only if you can transform str1 into str2.
    

     

    Example 1:

    Input: str1 = "aabcc", str2 = "ccdee"
Output: true
Explanation: Convert 'c' to 'e' then 'b' to 'd' then 'a' to 'c'. Note that the order of conversions matter.

    Example 2:

    Input: str1 = "leetcode", str2 = "codeleet"
Output: false
Explanation: There is no way to transform str1 to str2.

     

    Note:

    
        1 <= str1.length == str2.length <= 10^4
        Both str1 and str2 contain only lowercase English letters.
-----------------

# 204_Count_Primes
# 204. Count Primes

Count the number of prime numbers less than a non-negative number, n.

    Example:

    Input: 10
Output: 4
Explanation: There are 4 prime numbers less than 10, they are 2, 3, 5, 7.
-----------------

# 396_Rotate_Function
# 396. Rotate Function

Given an array of integers A and let n to be its length.
    

    
        Assume Bk to be an array obtained by rotating the array
        A k positions clock-wise, we define a "rotation function" F
        on A as follow:
    

    
        F(k) = 0 * Bk[0] + 1 * Bk[1] + ... + (n-1) * Bk[n-1].
    

    Calculate the maximum value of F(0), F(1), ..., F(n-1).
    

    Note:
        n is guaranteed to be less than 105.
    

    Example:
    A = [4, 3, 2, 6]

F(0) = (0 * 4) + (1 * 3) + (2 * 2) + (3 * 6) = 0 + 3 + 4 + 18 = 25
F(1) = (0 * 6) + (1 * 4) + (2 * 3) + (3 * 2) = 0 + 4 + 6 + 6 = 16
F(2) = (0 * 2) + (1 * 6) + (2 * 4) + (3 * 3) = 0 + 6 + 8 + 9 = 23
F(3) = (0 * 3) + (1 * 2) + (2 * 6) + (3 * 4) = 0 + 2 + 12 + 12 = 26

So the maximum value of F(0), F(1), F(2), F(3) is F(3) = 26.
-----------------

# 907_Sum_of_Subarray_Minimums
# 907. Sum of Subarray Minimums

Given an array of integers A, find the sum of min(B), where
        B ranges over every (contiguous) subarray of A.

    Since the answer may be large, return the answer modulo 10^9 +
        7.

     

    Example 1:

    Input: [3,1,2,4]
Output: 17
Explanation: Subarrays are [3], [1], [2], [4], [3,1], [1,2], [2,4], [3,1,2], [1,2,4], [3,1,2,4].
Minimums are 3, 1, 2, 4, 1, 1, 2, 1, 1, 1.  Sum is 17.

     

    Note:

    
        1 <= A.length <= 30000
        1 <= A[i] <= 30000
-----------------

# 1185_Day_of_the_Week
# 1185. Day of the Week

Given a date, return the corresponding day of the week for that date.

    The input is given as three integers representing the day, month
        and year respectively.

    Return the answer as one of the following values {"Sunday", "Monday",
        "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"}.
    

     
    Example 1:

    Input: day = 31, month = 8, year = 2019
Output: "Saturday"

    Example 2:

    Input: day = 18, month = 7, year = 1999
Output: "Sunday"

    Example 3:

    Input: day = 15, month = 8, year = 1993
Output: "Sunday"

     
    Constraints:

    
        The given dates are valid dates between the years 1971 and
            2100.
-----------------

# 168_Excel_Sheet_Column_Title
# 168. Excel Sheet Column Title

Given a positive integer, return its corresponding column title as appear in an Excel
        sheet.

    For example:

        1 -> A
    2 -> B
    3 -> C
    ...
    26 -> Z
    27 -> AA
    28 -> AB
    ...

    Example 1:

    Input: 1
Output: "A"

    Example 2:

    Input: 28
Output: "AB"

    Example 3:

    Input: 701
Output: "ZY"
-----------------

# 754_Reach_a_Number
# 754. Reach a Number

You are standing at position 0 on an infinite number line. There is a goal at
        position target.
    
    
        On each move, you can either go left or right. During the n-th move (starting from
        1), you take n steps.
    
    
        Return the minimum number of steps required to reach the destination.
    

    Example 1:
    Input: target = 3
Output: 2
Explanation:
On the first move we step from 0 to 1.
On the second step we step from 1 to 3.

    

    Example 2:
    Input: target = 2
Output: 3
Explanation:
On the first move we step from 0 to 1.
On the second move we step  from 1 to -1.
On the third move we step from -1 to 2.

    

    Note:
    target will be a non-zero integer in the range [-10^9, 10^9].
-----------------

# 1602_Find_Nearest_Right_Node_in_Binary_Tree
# 1602. Find Nearest Right Node in Binary Tree


-----------------

# 350_Intersection_of_Two_Arrays_II
# 350. Intersection of Two Arrays II

Given two arrays, write a function to compute their intersection.

    Example 1:

    Input: nums1 = [1,2,2,1], nums2 = [2,2]
Output: [2,2]
-----------------

# 706_Design_HashMap
# 706. Design HashMap

Design a HashMap without using any built-in hash table libraries.

    To be specific, your design should include these functions:

    
        put(key, value) : Insert a (key, value) pair into the HashMap. If the
            value already exists in the HashMap, update the value.
        
        get(key): Returns the value to which the specified key is mapped, or -1 if
            this map contains no mapping for the key.
        
        remove(key) : Remove the mapping for the value key if this map
            contains the mapping for the key.
        
    

    
        Example:

    MyHashMap hashMap = new MyHashMap();
hashMap.put(1, 1);          
hashMap.put(2, 2);        
hashMap.get(1);            // returns 1
hashMap.get(3);            // returns -1 (not found)
hashMap.put(2, 1);          // update the existing value
hashMap.get(2);            // returns 1
hashMap.remove(2);          // remove the mapping for 2
hashMap.get(2);            // returns -1 (not found)

    
        Note:

    
        All keys and values will be in the range of [0, 1000000].
        The number of operations will be in the range of [1, 10000].
        Please do not use the built-in HashMap library.
-----------------

# 283_Move_Zeroes
# 283. Move Zeroes

Given an array nums, write a function to move all 0's to the
        end of it while maintaining the relative order of the non-zero elements.

    Example:

    Input: [0,1,0,3,12]
Output: [1,3,12,0,0]

    Note:

    
        You must do this in-place without making a copy of the array.
        Minimize the total number of operations.
-----------------

# 1305_All_Elements_in_Two_Binary_Search_Trees
# 1305. All Elements in Two Binary Search Trees


-----------------

# 115_Distinct_Subsequences
# 115. Distinct Subsequences

Given a string S and a string T, count the number of
        distinct subsequences of S which equals T.

    A subsequence of a string is a new string which is formed from the original string by
        deleting some (can be none) of the characters without disturbing the relative positions of
        the remaining characters. (ie, "ACE" is a subsequence of "ABCDE"
        while "AEC" is not).

    Example 1:

    Input: S = "rabbbit", T = "rabbit"
Output: 3
Explanation:

As shown below, there are 3 ways you can generate "rabbit" from S.
(The caret symbol ^ means the chosen letters)

rabbbit
^^^^ ^^
rabbbit
^^ ^^^^
rabbbit
^^^ ^^^

    Example 2:

    Input: S = "babgbag", T = "bag"
Output: 5
Explanation:

As shown below, there are 5 ways you can generate "bag" from S.
(The caret symbol ^ means the chosen letters)

babgbag
^^ ^
babgbag
^^    ^
babgbag
^    ^^
babgbag
  ^  ^^
babgbag
    ^^^
-----------------

# 1144_Decrease_Elements_To_Make_Array_Zigzag
# 1144. Decrease Elements To Make Array Zigzag

Given an array nums of integers, a move consists of choosing any
        element and decreasing it by 1.

    An array A is a zigzag array if either:

    
        Every even-indexed element is greater than adjacent elements, ie. A[0] >
            A[1] < A[2] > A[3] < A[4] > ...
        OR, every odd-indexed element is greater than adjacent elements, ie. A[0]
            < A[1] > A[2] < A[3] > A[4] < ...
    

    Return the minimum number of moves to transform the given array nums into a
        zigzag array.

     
    Example 1:

    Input: nums = [1,2,3]
Output: 2
Explanation: We can decrease 2 to 0 or 3 to 1.

    Example 2:

    Input: nums = [9,6,1,6,2]
Output: 4

     
    Constraints:

    
        1 <= nums.length <= 1000
        1 <= nums[i] <= 1000
-----------------

# 1777_Product's_Price_for_Each_Store
# 1777. Product's Price for Each Store


-----------------

# 445_Add_Two_Numbers_II
# 445. Add Two Numbers II

You are given two non-empty linked lists representing two non-negative integers. The
        most significant digit comes first and each of their nodes contain a single digit. Add the
        two numbers and return it as a linked list.

    You may assume the two numbers do not contain any leading zero, except the number 0
        itself.

    Follow up:
        What if you cannot modify the input lists? In other words, reversing the lists is not
        allowed.
    

    
        Example:
    Input: (7 -> 2 -> 4 -> 3) + (5 -> 6 -> 4)
Output: 7 -> 8 -> 0 -> 7
-----------------

# 399_Evaluate_Division
# 399. Evaluate Division

Equations are given in the format A / B = k, where A and
        B are variables represented as strings, and k is a real number
        (floating point number). Given some queries, return the answers. If the answer does not
        exist, return -1.0.

    Example:
        Given  a / b = 2.0, b / c = 3.0.
        queries are:  a / c = ?, b / a = ?, a / e = ?, a / a = ?, x / x = ? .
        return  [6.0, 0.5, -1.0, 1.0, -1.0 ].

    The input is:  vector<pair<string, string>> equations, vector<double>&
        values, vector<pair<string, string>> queries , where equations.size()
        == values.size(), and the values are positive. This represents the equations. Return
         vector<double>.

    According to the example above:

    equations = [ ["a", "b"], ["b", "c"] ],
values = [2.0, 3.0],
queries = [ ["a", "c"], ["b", "a"], ["a", "e"], ["a", "a"], ["x", "x"] ]. 

     

    The input is always valid. You may assume that evaluating the queries will result in no
        division by zero and there is no contradiction.
-----------------

# 1487_Making_File_Names_Unique
# 1487. Making File Names Unique


-----------------

# 564_Find_the_Closest_Palindrome
# 564. Find the Closest Palindrome

Given an integer n, find the closest integer (not including itself), which is a
        palindrome. 

    The 'closest' is defined as absolute difference minimized between two integers.

    Example 1:
    Input: "123"
Output: "121"

    

    Note:
    
        The input n is a positive integer represented by string, whose length will not
            exceed 18.
        
        If there is a tie, return the smaller one as answer.
-----------------

# 1430_Check_If_a_String_Is_a_Valid_Sequence_from_Root_to_Leaves_Path_in_a_Binary_Tree
# 1430. Check If a String Is a Valid Sequence from Root to Leaves Path in a Binary Tree


-----------------

# 1286_Iterator_for_Combination
# 1286. Iterator for Combination


-----------------

# 1292_Maximum_Side_Length_of_a_Square_with_Sum_Less_than_or_Equal_to_Threshold
# 1292. Maximum Side Length of a Square with Sum Less than or Equal to Threshold


-----------------

# 615_Average_Salary_Departments_VS_Company
# 615. Average Salary: Departments VS Company

Given two tables as below, write a query to display the comparison result (higher/lower/same) of
    the average salary of employees in a department to the company's average salary.
     
    Table: salary

    | id | employee_id | amount | pay_date   |
|----|-------------|--------|------------|
| 1  | 1           | 9000   | 2017-03-31 |
| 2  | 2           | 6000   | 2017-03-31 |
| 3  | 3           | 10000  | 2017-03-31 |
| 4  | 1           | 7000   | 2017-02-28 |
| 5  | 2           | 6000   | 2017-02-28 |
| 6  | 3           | 8000   | 2017-02-28 |

     
    The employee_id column refers to the employee_id in the following table employee.

     

    | employee_id | department_id |
|-------------|---------------|
| 1           | 1             |
| 2           | 2             |
| 3           | 2             |

     
    So for the sample data above, the result is:

     

    | pay_month | department_id | comparison  |
|-----------|---------------|-------------|
| 2017-03   | 1             | higher      |
| 2017-03   | 2             | lower       |
| 2017-02   | 1             | same        |
| 2017-02   | 2             | same        |

     
    Explanation

     
    In March, the company's average salary is (9000+6000+10000)/3 = 8333.33...

     
    The average salary for department '1' is 9000, which is the salary of employee_id
    '1' since there is only one employee in this department. So the comparison result is
    'higher' since 9000 > 8333.33 obviously.

     
    The average salary of department '2' is (6000 + 10000)/2 = 8000, which is the average of
    employee_id '2' and '3'. So the comparison result is 'lower'
    since 8000 < 8333.33.

     
    With he same formula for the average salary comparison in February, the result is 'same'
    since both the department '1' and '2' have the same average salary with the
    company, which is 7000.
-----------------

# 92_Reverse_Linked_List_II
# 92. Reverse Linked List II

Reverse a linked list from position m to n. Do it in one-pass.

    Note: 1 ≤ m ≤ n ≤ length of list.

    Example:

    Input: 1->2->3->4->5->NULL, m = 2, n = 4
Output: 1->4->3->2->5->NULL
-----------------

# 1322_1322._Ads_Performance
# 1322. 1322. Ads Performance


-----------------

# 1179_Reformat_Department_Table
# 1179. Reformat Department Table

Table: Department

    +---------------+---------+
| Column Name   | Type    |
+---------------+---------+
| id            | int     |
| revenue       | int     |
| month         | varchar |
+---------------+---------+
(id, month) is the primary key of this table.
The table has information about the revenue of each department per month.
The month has values in ["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"].

     

    Write an SQL query to reformat the table such that there is a department id column and a
        revenue column for each month.

    The query result format is in the following example:

    Department table:
+------+---------+-------+
| id   | revenue | month |
+------+---------+-------+
| 1    | 8000    | Jan   |
| 2    | 9000    | Jan   |
| 3    | 10000   | Feb   |
| 1    | 7000    | Feb   |
| 1    | 6000    | Mar   |
+------+---------+-------+

Result table:
+------+-------------+-------------+-------------+-----+-------------+
| id   | Jan_Revenue | Feb_Revenue | Mar_Revenue | ... | Dec_Revenue |
+------+-------------+-------------+-------------+-----+-------------+
| 1    | 8000        | 7000        | 6000        | ... | null        |
| 2    | 9000        | null        | null        | ... | null        |
| 3    | null        | 10000       | null        | ... | null        |
+------+-------------+-------------+-------------+-----+-------------+

Note that the result table has 13 columns (1 for the department id + 12 for the months).
-----------------

# 1141_User_Activity_for_the_Past_30_Days_I
# 1141. User Activity for the Past 30 Days I

Table: Activity

    +---------------+---------+
| Column Name   | Type    |
+---------------+---------+
| user_id       | int     |
| session_id    | int     |
| activity_date | date    |
| activity_type | enum    |
+---------------+---------+
There is no primary key for this table, it may have duplicate rows.
The activity_type column is an ENUM of type ('open_session', 'end_session', 'scroll_down', 'send_message').
The table shows the user activities for a social media website.
Note that each session belongs to exactly one user.

     

    Write an SQL query to find the daily active user count for a period of 30 days ending
        2019-07-27 inclusively. A user was active on some day if he/she made
        at least one activity on that day.

    The query result format is in the following example:

    Activity table:
+---------+------------+---------------+---------------+
| user_id | session_id | activity_date | activity_type |
+---------+------------+---------------+---------------+
| 1       | 1          | 2019-07-20    | open_session  |
| 1       | 1          | 2019-07-20    | scroll_down   |
| 1       | 1          | 2019-07-20    | end_session   |
| 2       | 4          | 2019-07-20    | open_session  |
| 2       | 4          | 2019-07-21    | send_message  |
| 2       | 4          | 2019-07-21    | end_session   |
| 3       | 2          | 2019-07-21    | open_session  |
| 3       | 2          | 2019-07-21    | send_message  |
| 3       | 2          | 2019-07-21    | end_session   |
| 4       | 3          | 2019-06-25    | open_session  |
| 4       | 3          | 2019-06-25    | end_session   |
+---------+------------+---------------+---------------+

Result table:
+------------+--------------+
| day        | active_users |
+------------+--------------+
| 2019-07-20 | 2            |
| 2019-07-21 | 2            |
+------------+--------------+
Note that we do not care about days with zero active users.
-----------------

# 1226_The_Dining_Philosophers
# 1226. The Dining Philosophers

Five silent philosophers sit at a round table with bowls of spaghetti. Forks are placed
        between each pair of adjacent philosophers.

    Each philosopher must alternately think and eat. However, a philosopher can only eat
        spaghetti when they have both left and right forks. Each fork can be held by only one
        philosopher and so a philosopher can use the fork only if it is not being used by another
        philosopher. After an individual philosopher finishes eating, they need to put down both
        forks so that the forks become available to others. A philosopher can take the fork on their
        right or the one on their left as they become available, but cannot start eating before
        getting both forks.

    Eating is not limited by the remaining amounts of spaghetti or stomach space; an infinite
        supply and an infinite demand are assumed.

    Design a discipline of behavior (a concurrent algorithm) such that no philosopher will
        starve; i.e., each can forever continue to alternate between eating and
        thinking, assuming that no philosopher can know when others may want to eat or think.

    

    The problem statement and the image above are taken from wikipedia.org
    

     

    The philosophers' ids are numbered from 0 to 4 in a
        clockwise order. Implement the function void
            wantsToEat(philosopher, pickLeftFork, pickRightFork, eat, putLeftFork,
            putRightFork) where:

    
        philosopher is the id of the philosopher who wants to eat.
        pickLeftFork and pickRightFork are functions
            you can call to pick the corresponding forks of that philosopher.
        
        eat is a function you can call to let the philosopher eat once he has
            picked both forks.
        
        putLeftFork and pickRightFork are functions you
            can call to put down the corresponding forks of that philosopher.
        
        The philosophers are assumed to be thinking as long as they are not asking to eat (the
            function is not being called with their number).
        
    

    Five threads, each representing a philosopher, will simultaneously use one object of
        your class to simulate the process. It is possible that the function will be called for the
        same philosopher more than once, even before the last call ends.

     
    Example 1:

    Input: n = 1
Output: [[4,2,1],[4,1,1],[0,1,1],[2,2,1],[2,1,1],[2,0,3],[2,1,2],[2,2,2],[4,0,3],[4,1,2],[0,2,1],[4,2,2],[3,2,1],[3,1,1],[0,0,3],[0,1,2],[0,2,2],[1,2,1],[1,1,1],[3,0,3],[3,1,2],[3,2,2],[1,0,3],[1,1,2],[1,2,2]]
Explanation:
n is the number of times each philosopher will call the function.
The output array describes the calls you made to the functions controlling the forks and the eat function, its format is:
output[i] = [a, b, c] (three integers)
- a is the id of a philosopher.
- b specifies the fork: {1 : left, 2 : right}.
- c specifies the operation: {1 : pick, 2 : put, 3 : eat}.

     
    Constraints:

    
        1 <= n <= 60
-----------------

# 1199_Minimum_Time_to_Build_Blocks
# 1199. Minimum Time to Build Blocks

You are given a list of blocks, where blocks[i] = t means that
        the i-th block needs t units of time to be built. A
        block can only be built by exactly one worker.

    A worker can either split into two workers (number of workers increases by one) or build a
        block then go home. Both decisions cost some time.

    The time cost of spliting one worker into two workers is given as an integer
        split. Note that if two workers split at the same time, they split in parallel
        so the cost would be split.

    Output the minimum time needed to build all blocks.

    Initially, there is only one worker.

     
    Example 1:

    Input: blocks = [1], split = 1
Output: 1
Explanation: We use 1 worker to build 1 block in 1 time unit.

    Example 2:

    Input: blocks = [1,2], split = 5
Output: 7
Explanation: We split the worker into 2 workers in 5 time units then assign each of them to a block so the cost is 5 + max(1, 2) = 7.

    Example 3:

    Input: blocks = [1,2,3], split = 1
Output: 4
Explanation: Split 1 worker into 2, then assign the first worker to the last block and split the second worker into 2.
Then, use the two unassigned workers to build the first two blocks.
The cost is 1 + max(3, 1 + max(1, 2)) = 4.

     
    Constraints:

    
        1 <= blocks.length <= 1000
        1 <= blocks[i] <= 10^5
        1 <= split <= 100
-----------------

# 1710_Maximum_Units_on_a_Truck
# 1710. Maximum Units on a Truck


-----------------

# 1130_Minimum_Cost_Tree_From_Leaf_Values
# 1130. Minimum Cost Tree From Leaf Values

Given an array arr of positive integers, consider all binary trees such that:
    

    
        Each node has either 0 or 2 children;
        The values of arr correspond to the values of
            each leaf in an in-order traversal of the tree.  (Recall
                that a node is a leaf if and only if it has 0 children.)
        The value of each non-leaf node is equal to the product of the largest leaf value
            in its left and right subtree respectively.
        
    

    Among all possible binary trees considered, return the smallest possible sum of the
        values of each non-leaf node.  It is guaranteed this sum fits into a 32-bit
        integer.

     
    Example 1:

    Input: arr = [6,2,4]
Output: 32
Explanation:
There are two possible trees.  The first has non-leaf node sum 36, and the second has non-leaf node sum 32.

    24            24
   /  \          /  \
  12   4        6    8
 /  \               / \
6    2             2   4

     
    Constraints:

    
        2 <= arr.length <= 40
        1 <= arr[i] <= 15
        It is guaranteed that the answer fits into a 32-bit signed integer (ie. it is less
            than 2^31).
-----------------

# 1023_Camelcase_Matching
# 1023. Camelcase Matching

A query word matches a given pattern if we can insert lowercase
        letters to the pattern word so that it equals the query. (We may insert each
        character at any position, and may insert 0 characters.)

    Given a list of queries, and a pattern, return an
        answer list of booleans, where answer[i] is true if and only if
        queries[i] matches the pattern.

     

    Example 1:

    Input: queries = ["FooBar","FooBarTest","FootBall","FrameBuffer","ForceFeedBack"], pattern = "FB"
Output: [true,false,true,true,false]
Explanation: 
"FooBar" can be generated like this "F" + "oo" + "B" + "ar".
"FootBall" can be generated like this "F" + "oot" + "B" + "all".
"FrameBuffer" can be generated like this "F" + "rame" + "B" + "uffer".

    Example 2:

    Input: queries = ["FooBar","FooBarTest","FootBall","FrameBuffer","ForceFeedBack"], pattern = "FoBa"
Output: [true,false,true,false,false]
Explanation: 
"FooBar" can be generated like this "Fo" + "o" + "Ba" + "r".
"FootBall" can be generated like this "Fo" + "ot" + "Ba" + "ll".

    Example 3:

    Input: queries = ["FooBar","FooBarTest","FootBall","FrameBuffer","ForceFeedBack"], pattern = "FoBaT"
Output: [false,true,false,false,false]
Explanation: 
"FooBarTest" can be generated like this "Fo" + "o" + "Ba" + "r" + "T" + "est".

     

    Note:

    
        1 <= queries.length <= 100
        1 <= queries[i].length <= 100
        1 <= pattern.length <= 100
        All strings consists only of lower and upper case English letters.
-----------------

# 11_Container_With_Most_Water
# 11. Container With Most Water

Given n non-negative integers a1, a2, ...,
        an , where each represents a point at coordinate (i, ai).
        n vertical lines are drawn such that the two endpoints of line i is at
        (i, ai) and (i, 0). Find two lines, which together with
        x-axis forms a container, such that the container contains the most water.

    Note: You may not slant the container and n is at least 2.

     

    

    
        The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case,
            the max area of water (blue section) the container can contain is 49.
        
    

     

    Example:

    Input: [1,8,6,2,5,4,8,3,7]
Output: 49
-----------------

# 296_Best_Meeting_Point
# 296. Best Meeting Point

A group of two or more people wants to meet and minimize the total travel distance. You are
        given a 2D grid of values 0 or 1, where each 1 marks the home of someone in the group. The
        distance is calculated using Manhattan Distance, where distance(p1,
        p2) = |p2.x - p1.x| + |p2.y - p1.y|.

    Example:

    Input:

1 - 0 - 0 - 0 - 1
|   |   |   |   |
0 - 0 - 0 - 0 - 0
|   |   |   |   |
0 - 0 - 1 - 0 - 0

Output: 6

Explanation: Given three people living at (0,0), (0,4), and (2,2):
             The point (0,2) is an ideal meeting point, as the total travel distance
             of 2+2+2=6 is minimal. So return 6.
-----------------

# 768_Max_Chunks_To_Make_Sorted_II
# 768. Max Chunks To Make Sorted II

This question is the same as "Max Chunks to Make Sorted" except the integers of
        the given array are not necessarily distinct, the input array could be up to length 2000,
        and the elements could be up to 10**8.

    

    Given an array arr of integers (not necessarily distinct), we
        split the array into some number of "chunks" (partitions), and individually sort
        each chunk.  After concatenating them, the result equals the sorted array.

    What is the most number of chunks we could have made?

    Example 1:

    Input: arr = [5,4,3,2,1]
Output: 1
Explanation:
Splitting into two or more chunks will not return the required result.
For example, splitting into [5, 4], [3, 2, 1] will result in [4, 5, 1, 2, 3], which isn't sorted.

    Example 2:

    Input: arr = [2,1,3,4,4]
Output: 4
Explanation:
We can split into two chunks, such as [2, 1], [3, 4, 4].
However, splitting into [2, 1], [3], [4], [4] is the highest number of chunks possible.

    Note:

    
        arr will have length in range [1, 2000].
        arr[i] will be an integer in range [0, 10**8].
-----------------

# 110_Balanced_Binary_Tree
# 110. Balanced Binary Tree

Given a binary tree, determine if it is height-balanced.

    For this problem, a height-balanced binary tree is defined as:

    
        a binary tree in which the depth of the two subtrees of every node never differ
            by more than 1.
    

    Example 1:

    Given the following tree [3,9,20,null,null,15,7]:

        3
   / \
  9  20
    /  \
   15   7

    Return true.
        
        Example 2:

    Given the following tree [1,2,2,3,3,null,null,4,4]:

           1
      / \
     2   2
    / \
   3   3
  / \
 4   4

    Return false.
-----------------

# 1538_Guess_the_Majority_in_a_Hidden_Array
# 1538. Guess the Majority in a Hidden Array


-----------------

# 1715_Count_Apples_and_Oranges
# 1715. Count Apples and Oranges


-----------------

# 393_UTF-8_Validation
# 393. UTF-8 Validation

A character in UTF8 can be from 1 to 4 bytes long, subjected to the following rules:
    
    
        For 1-byte character, the first bit is a 0, followed by its unicode code.
        For n-bytes character, the first n-bits are all one's, the n+1 bit is 0, followed by n-1
            bytes with most significant 2 bits being 10.
        
    
    This is how the UTF-8 encoding would work:

       Char. number range  |        UTF-8 octet sequence
      (hexadecimal)    |              (binary)
   --------------------+---------------------------------------------
   0000 0000-0000 007F | 0xxxxxxx
   0000 0080-0000 07FF | 110xxxxx 10xxxxxx
   0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx
   0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx

    
        Given an array of integers representing the data, return whether it is a valid utf-8
        encoding.
    
    
        Note:
        The input is an array of integers. Only the least significant 8 bits of each integer
        is used to store the data. This means each integer represents only 1 byte of data.
    

    
        Example 1:
    data = [197, 130, 1], which represents the octet sequence: 11000101 10000010 00000001.

Return true.
It is a valid utf-8 encoding for a 2-bytes character followed by a 1-byte character.

    

    
        Example 2:
    data = [235, 140, 4], which represented the octet sequence: 11101011 10001100 00000100.

Return false.
The first 3 bits are all one's and the 4th bit is 0 means it is a 3-bytes character.
The next byte is a continuation byte which starts with 10 and that's correct.
But the second continuation byte does not start with 10, so it is invalid.
-----------------

# 1814_Count_Nice_Pairs_in_an_Array
# 1814. Count Nice Pairs in an Array


-----------------

# 1517_Find_Users_With_Valid_E-Mails
# 1517. Find Users With Valid E-Mails


-----------------

# 933_Number_of_Recent_Calls
# 933. Number of Recent Calls

Write a class RecentCounter to count recent requests.

    It has only one method: ping(int t), where t represents some time in
        milliseconds.

    Return the number of pings that have been made from 3000 milliseconds ago until
        now.

    Any ping with time in [t - 3000, t] will count, including the current ping.

    It is guaranteed that every call to ping uses a strictly larger value
        of t than before.

     

    Example 1:

    Input: inputs = ["RecentCounter","ping","ping","ping","ping"], inputs = [[],[1],[100],[3001],[3002]]
Output: [null,1,2,3,3]

     

    Note:

    
        Each test case will have at most 10000 calls to ping.
        Each test case will call ping with strictly increasing values of
            t.
        
        Each call to ping will have 1 <= t <= 10^9.
-----------------

# 1085_Sum_of_Digits_in_the_Minimum_Number
# 1085. Sum of Digits in the Minimum Number

Given an array A of positive integers, let S be the sum of the
        digits of the minimal element of A.

    Return 0 if S is odd, otherwise return 1.

     

    Example 1:

    Input: [34,23,1,24,75,33,54,8]
Output: 0
Explanation: 
The minimal element is 1, and the sum of those digits is S = 1 which is odd, so the answer is 0.

    Example 2:

    Input: [99,77,33,66,55]
Output: 1
Explanation: 
The minimal element is 33, and the sum of those digits is S = 3 + 3 = 6 which is even, so the answer is 1.

     

    Note:

    
        1 <= A.length <= 100
        1 <= A[i].length <= 100
-----------------

# 511_Game_Play_Analysis_I
# 511. Game Play Analysis I

Table: Activity

    +--------------+---------+
| Column Name  | Type    |
+--------------+---------+
| player_id    | int     |
| device_id    | int     |
| event_date   | date    |
| games_played | int     |
+--------------+---------+
(player_id, event_date) is the primary key of this table.
This table shows the activity of players of some game.
Each row is a record of a player who logged in and played a number of games (possibly 0) before logging out on some day using some device.

     

    Write an SQL query that reports the first login date for each player.
    

    The query result format is in the following example:

    Activity table:
+-----------+-----------+------------+--------------+
| player_id | device_id | event_date | games_played |
+-----------+-----------+------------+--------------+
| 1         | 2         | 2016-03-01 | 5            |
| 1         | 2         | 2016-05-02 | 6            |
| 2         | 3         | 2017-06-25 | 1            |
| 3         | 1         | 2016-03-02 | 0            |
| 3         | 4         | 2018-07-03 | 5            |
+-----------+-----------+------------+--------------+

Result table:
+-----------+-------------+
| player_id | first_login |
+-----------+-------------+
| 1         | 2016-03-01  |
| 2         | 2017-06-25  |
| 3         | 2016-03-02  |
+-----------+-------------+
-----------------

# 325_Maximum_Size_Subarray_Sum_Equals_k
# 325. Maximum Size Subarray Sum Equals k

Given an array nums and a target value k, find the maximum length of a subarray
        that sums to k. If there isn't one, return 0 instead.

    Note:
        The sum of the entire nums array is guaranteed to fit within the 32-bit signed
        integer range.

    Example 1:

    Input: nums = [1, -1, 5, -2, 3], k = 3
Output: 4
Explanation: The subarray [1, -1, 5, -2] sums to 3 and is the longest.

    Example 2:

    Input: nums = [-2, -1, 2, 1], k = 1
Output: 2 
Explanation: The subarray [-1, 2] sums to 1 and is the longest.

    Follow Up:
        Can you do it in O(n) time?
-----------------

# 622_Design_Circular_Queue
# 622. Design Circular Queue

Design your implementation of the circular queue. The circular queue is a linear data
        structure in which the operations are performed based on FIFO (First In First Out) principle
        and the last position is connected back to the first position to make a circle. It is also
        called "Ring Buffer".

    One of the benefits of the circular queue is that we can make use of the spaces in front of
        the queue. In a normal queue, once the queue becomes full, we cannot insert the next element
        even if there is a space in front of the queue. But using the circular queue, we can use the
        space to store new values.

    Your implementation should support following operations:

    
        MyCircularQueue(k): Constructor, set the size of the queue to be k.
        Front: Get the front item from the queue. If the queue is empty, return -1.
        
        Rear: Get the last item from the queue. If the queue is empty, return -1.
        
        enQueue(value): Insert an element into the circular queue. Return true if
            the operation is successful.
        
        deQueue(): Delete an element from the circular queue. Return true if the
            operation is successful.
        
        isEmpty(): Checks whether the circular queue is empty or not.
        isFull(): Checks whether the circular queue is full or not.
    

     

    Example:

    MyCircularQueue circularQueue = new MyCircularQueue(3); // set the size to be 3
circularQueue.enQueue(1);  // return true
circularQueue.enQueue(2);  // return true
circularQueue.enQueue(3);  // return true
circularQueue.enQueue(4);  // return false, the queue is full
circularQueue.Rear();  // return 3
circularQueue.isFull();  // return true
circularQueue.deQueue();  // return true
circularQueue.enQueue(4);  // return true
circularQueue.Rear();  // return 4

     

    Note:

    
        All values will be in the range of [0, 1000].
        The number of operations will be in the range of [1, 1000].
        Please do not use the built-in Queue library.
-----------------

# 1010_Pairs_of_Songs_With_Total_Durations_Divisible_by_60
# 1010. Pairs of Songs With Total Durations Divisible by 60

In a list of songs, the i-th song has a duration
        of time[i] seconds. 

    Return the number of pairs of songs for which their total duration in seconds is
        divisible by 60.  Formally, we want the number of indices i
            < j with (time[i] + time[j]) % 60 == 0.

     

    Example 1:

    Input: [30,20,150,100,40]
Output: 3
Explanation: Three pairs have a total duration divisible by 60:
(time[0] = 30, time[2] = 150): total duration 180
(time[1] = 20, time[3] = 100): total duration 120
(time[1] = 20, time[4] = 40): total duration 60
-----------------

# 1590_Make_Sum_Divisible_by_P
# 1590. Make Sum Divisible by P


-----------------

# 779_K-th_Symbol_in_Grammar
# 779. K-th Symbol in Grammar

On the first row, we write a 0. Now in every subsequent row, we look at the
        previous row and replace each occurrence of 0 with 01, and each
        occurrence of 1 with 10.

    Given row N and index K, return the K-th indexed
        symbol in row N. (The values of K are 1-indexed.) (1 indexed).

    Examples:
Input: N = 1, K = 1
Output: 0

Input: N = 2, K = 1
Output: 0

Input: N = 2, K = 2
Output: 1

Input: N = 4, K = 5
Output: 1

Explanation:
row 1: 0
row 2: 01
row 3: 0110
row 4: 01101001

    Note:

    
        N will be an integer in the range [1, 30].
        K will be an integer in the range [1, 2^(N-1)].
-----------------

# 1519_Number_of_Nodes_in_the_Sub-Tree_With_the_Same_Label
# 1519. Number of Nodes in the Sub-Tree With the Same Label


-----------------

# 1440_Evaluate_Boolean_Expression
# 1440. Evaluate Boolean Expression


-----------------

# 346_Moving_Average_from_Data_Stream
# 346. Moving Average from Data Stream

Given a stream of integers and a window size, calculate the moving average of all integers in
        the sliding window.

    Example:

    MovingAverage m = new MovingAverage(3);
m.next(1) = 1
m.next(10) = (1 + 10) / 2
m.next(3) = (1 + 10 + 3) / 3
m.next(5) = (10 + 3 + 5) / 3
-----------------

# 514_Freedom_Trail
# 514. Freedom Trail

In the video game Fallout 4, the quest "Road to Freedom" requires players to reach
        a metal dial called the "Freedom Trail Ring", and use the dial to spell a specific
        keyword in order to open the door.

    Given a string ring, which represents the code engraved on the outer ring and another
        string key, which represents the keyword needs to be spelled. You need to find the
        minimum number of steps in order to spell all the characters in the keyword.

    Initially, the first character of the ring is aligned at 12:00 direction. You need to
        spell all the characters in the string key one by one by rotating the ring clockwise
        or anticlockwise to make each character of the string key aligned at 12:00 direction
        and then by pressing the center button.

    At the stage of rotating the ring to spell the key character key[i]:

    
        You can rotate the ring clockwise or anticlockwise one place, which counts
            as 1 step. The final purpose of the rotation is to align one of the string
            ring's characters at the 12:00 direction, where this character must equal to
            the character key[i].
        
        If the character key[i] has been aligned at the 12:00 direction, you need to
            press the center button to spell, which also counts as 1 step. After the pressing, you
            could begin to spell the next character in the key (next stage), otherwise, you've
            finished all the spelling.
        
    

    Example:

    
     

    Input: ring = "godding", key = "gd"
Output: 4
Explanation:
For the first key character 'g', since it is already in place, we just need 1 step to spell this character.
For the second key character 'd', we need to rotate the ring "godding" anticlockwise by two steps to make it become "ddinggo".
Also, we need 1 more step for spelling.
So the final output is 4.

    Note:

    
        Length of both ring and key will be in range 1 to 100.
        There are only lowercase letters in both strings and might be some duplcate characters
            in both strings.
        
        It's guaranteed that string key could always be spelled by rotating the
            string ring.
-----------------

# 1087_Brace_Expansion
# 1087. Brace Expansion

A string S represents a list of words.

    Each letter in the word has 1 or more options.  If there is one option, the letter is
        represented as is.  If there is more than one option, then curly braces delimit the
        options.  For example, "{a,b,c}" represents options ["a",
            "b", "c"].

    For example, "{a,b,c}d{e,f}" represents the list ["ade",
        "adf", "bde", "bdf", "cde", "cdf"].
    

    Return all words that can be formed in this manner, in lexicographical order.

     

    Example 1:

    Input: "{a,b}c{d,e}f"
Output: ["acdf","acef","bcdf","bcef"]

    Example 2:

    Input: "abcd"
Output: ["abcd"]

     

    Note:

    
        1 <= S.length <= 50
        There are no nested curly brackets.
        All characters inside a pair of consecutive opening and ending curly brackets are
            different.
-----------------

# 1501_Countries_You_Can_Safely_Invest_In
# 1501. Countries You Can Safely Invest In


-----------------

# 230_Kth_Smallest_Element_in_a_BST
# 230. Kth Smallest Element in a BST

Given a binary search tree, write a function kthSmallest to find the kth
        smallest element in it.

    Note: 
        You may assume k is always valid, 1 ≤ k ≤ BST's total elements.

    Example 1:

    Input: root = [3,1,4,null,2], k = 1
   3
  / \
 1   4
  \
   2
Output: 1

    Example 2:

    Input: root = [5,3,6,2,4,null,null,1], k = 3
       5
      / \
     3   6
    / \
   2   4
  /
 1
Output: 3

    Follow up:
        What if the BST is modified (insert/delete operations) often and you need to find the kth
        smallest frequently? How would you optimize the kthSmallest routine?
-----------------

# 67_Add_Binary
# 67. Add Binary

Given two binary strings, return their sum (also a binary string).

    The input strings are both non-empty and contains only characters
        1 or 0.

    Example 1:

    Input: a = "11", b = "1"
Output: "100"

    Example 2:

    Input: a = "1010", b = "1011"
Output: "10101"
-----------------

# 1603_Design_Parking_System
# 1603. Design Parking System


-----------------

# 1569_Number_of_Ways_to_Reorder_Array_to_Get_Same_BST
# 1569. Number of Ways to Reorder Array to Get Same BST


-----------------

# 1802_Maximum_Value_at_a_Given_Index_in_a_Bounded_Array
# 1802. Maximum Value at a Given Index in a Bounded Array


-----------------

# 1452_People_Whose_List_of_Favorite_Companies_Is_Not_a_Subset_of_Another_List
# 1452. People Whose List of Favorite Companies Is Not a Subset of Another List


-----------------

# 936_Stamping_The_Sequence
# 936. Stamping The Sequence

You want to form a target string of lowercase letters.

    At the beginning, your sequence is target.length '?'
        marks.  You also have a stamp of lowercase letters.

    On each turn, you may place the stamp over the sequence, and replace every letter in the
        sequence with the corresponding letter from the stamp.  You can make up to 10 *
            target.length turns.

    For example, if the initial sequence is "?????", and
        your stamp is "abc",  then you may make "abc??",
            "?abc?", "??abc" in the first turn.  (Note that the
        stamp must be fully contained in the boundaries of the sequence in order to stamp.)

    If the sequence is possible to stamp, then return an array of the index of the left-most
        letter being stamped at each turn.  If the sequence is not possible to stamp, return an
        empty array.

    For example, if the sequence is "ababc", and the
        stamp is "abc", then we could return the answer [0, 2],
        corresponding to the moves "?????" -> "abc??"
            -> "ababc".

    Also, if the sequence is possible to stamp, it is guaranteed it is possible to stamp within
        10 * target.length moves.  Any answers specifying more than this
        number of moves will not be accepted.

     

    Example 1:

    Input: stamp = "abc", target = "ababc"
Output: [0,2]
([1,0,2] would also be accepted as an answer, as well as some other answers.)
-----------------

# 1536_Minimum_Swaps_to_Arrange_a_Binary_Grid
# 1536. Minimum Swaps to Arrange a Binary Grid


-----------------

# 1116_Print_Zero_Even_Odd
# 1116. Print Zero Even Odd

Suppose you are given the following code:

    class ZeroEvenOdd {
  public ZeroEvenOdd(int n) { ... }      // constructor
  public void zero(printNumber) { ... }  // only output 0's
  public void even(printNumber) { ... }  // only output even numbers
  public void odd(printNumber) { ... }   // only output odd numbers
}

    The same instance of ZeroEvenOdd will be passed to three different threads:

    
        Thread A will call zero() which should only output 0's.
        Thread B will call even() which should only ouput even numbers.
        
        Thread C will call odd() which should only output odd numbers.
    

    Each of the threads is given a printNumber method to output an
        integer. Modify the given program to output the series 010203040506...
        where the length of the series must be 2n.

     

    Example 1:

    Input: n = 2
Output: "0102"
Explanation: There are three threads being fired asynchronously. One of them calls zero(), the other calls even(), and the last one calls odd(). "0102" is the correct output.

    Example 2:

    Input: n = 5
Output: "0102030405"
-----------------

# 626_Exchange_Seats
# 626. Exchange Seats

Mary is a teacher in a middle school and she has a table seat storing students'
        names and their corresponding seat ids.
    The column id is continuous increment.

     
    Mary wants to change seats for the adjacent students.

     
    Can you write a SQL query to output the result for Mary?

     

    +---------+---------+
|    id   | student |
+---------+---------+
|    1    | Abbot   |
|    2    | Doris   |
|    3    | Emerson |
|    4    | Green   |
|    5    | Jeames  |
+---------+---------+

    For the sample input, the output is:

     

    +---------+---------+
|    id   | student |
+---------+---------+
|    1    | Doris   |
|    2    | Abbot   |
|    3    | Green   |
|    4    | Emerson |
|    5    | Jeames  |
+---------+---------+

    Note:
        If the number of students is odd, there is no need to change the last one's seat.
-----------------

# 976_Largest_Perimeter_Triangle
# 976. Largest Perimeter Triangle

Given an array A of positive lengths, return the largest perimeter of a triangle
        with non-zero area, formed from 3 of these lengths.

    If it is impossible to form any triangle of non-zero area, return 0.
-----------------

# 359_Logger_Rate_Limiter
# 359. Logger Rate Limiter

Design a logger system that receive stream of messages along with its timestamps, each
        message should be printed if and only if it is not printed in the last 10 seconds.
    

    Given a message and a timestamp (in seconds granularity), return true if the message should
        be printed in the given timestamp, otherwise returns false.

    It is possible that several messages arrive roughly at the same time.

    Example:

    Logger logger = new Logger();

// logging string "foo" at timestamp 1
logger.shouldPrintMessage(1, "foo"); returns true;

// logging string "bar" at timestamp 2
logger.shouldPrintMessage(2,"bar"); returns true;

// logging string "foo" at timestamp 3
logger.shouldPrintMessage(3,"foo"); returns false;

// logging string "bar" at timestamp 8
logger.shouldPrintMessage(8,"bar"); returns false;

// logging string "foo" at timestamp 10
logger.shouldPrintMessage(10,"foo"); returns false;

// logging string "foo" at timestamp 11
logger.shouldPrintMessage(11,"foo"); returns true;
-----------------

# 1423_Maximum_Points_You_Can_Obtain_from_Cards
# 1423. Maximum Points You Can Obtain from Cards


-----------------

# 1478_Allocate_Mailboxes
# 1478. Allocate Mailboxes


-----------------

# 1158_Market_Analysis_I
# 1158. Market Analysis I

Table: Users

    +----------------+---------+
| Column Name    | Type    |
+----------------+---------+
| user_id        | int     |
| join_date      | date    |
| favorite_brand | varchar |
+----------------+---------+
user_id is the primary key of this table.
This table has the info of the users of an online shopping website where users can sell and buy items.

    Table: Orders

    +---------------+---------+
| Column Name   | Type    |
+---------------+---------+
| order_id      | int     |
| order_date    | date    |
| item_id       | int     |
| buyer_id      | int     |
| seller_id     | int     |
+---------------+---------+
order_id is the primary key of this table.
item_id is a foreign key to the Items table.
buyer_id and seller_id are foreign keys to the Users table.

    Table: Items

    +---------------+---------+
| Column Name   | Type    |
+---------------+---------+
| item_id       | int     |
| item_brand    | varchar |
+---------------+---------+
item_id is the primary key of this table.

     

    Write an SQL query to find for each user, the join date and the number of orders they made as
        a buyer in 2019.

    The query result format is in the following example:

    Users table:
+---------+------------+----------------+
| user_id | join_date  | favorite_brand |
+---------+------------+----------------+
| 1       | 2018-01-01 | Lenovo         |
| 2       | 2018-02-09 | Samsung        |
| 3       | 2018-01-19 | LG             |
| 4       | 2018-05-21 | HP             |
+---------+------------+----------------+

Orders table:
+----------+------------+---------+----------+-----------+
| order_id | order_date | item_id | buyer_id | seller_id |
+----------+------------+---------+----------+-----------+
| 1        | 2019-08-01 | 4       | 1        | 2         |
| 2        | 2018-08-02 | 2       | 1        | 3         |
| 3        | 2019-08-03 | 3       | 2        | 3         |
| 4        | 2018-08-04 | 1       | 4        | 2         |
| 5        | 2018-08-04 | 1       | 3        | 4         |
| 6        | 2019-08-05 | 2       | 2        | 4         |
+----------+------------+---------+----------+-----------+

Items table:
+---------+------------+
| item_id | item_brand |
+---------+------------+
| 1       | Samsung    |
| 2       | Lenovo     |
| 3       | LG         |
| 4       | HP         |
+---------+------------+

Result table:
+-----------+------------+----------------+
| buyer_id  | join_date  | orders_in_2019 |
+-----------+------------+----------------+
| 1         | 2018-01-01 | 1              |
| 2         | 2018-02-09 | 2              |
| 3         | 2018-01-19 | 0              |
| 4         | 2018-05-21 | 0              |
+-----------+------------+----------------+
-----------------

# 1267_Count_Servers_that_Communicate
# 1267. Count Servers that Communicate


-----------------

# 431_Encode_N-ary_Tree_to_Binary_Tree
# 431. Encode N-ary Tree to Binary Tree

Design an algorithm to encode an N-ary tree into a binary tree and decode the binary tree to
        get the original N-ary tree. An N-ary tree is a rooted tree in which each node has no more
        than N children. Similarly, a binary tree is a rooted tree in which each node has no more
        than 2 children. There is no restriction on how your encode/decode algorithm should work.
        You just need to ensure that an N-ary tree can be encoded to a binary tree and this binary
        tree can be decoded to the original N-nary tree structure.

    For example, you may encode the following 3-ary tree to a binary tree in this
        way:

     

    
        

     

    Note that the above is just an example which might or might not work. You do not
        necessarily need to follow this format, so please be creative and come up with different
        approaches yourself.

     

    Note:

    
        N is in the range of  [1, 1000]
        Do not use class member/global/static variables to store states. Your encode and decode
            algorithms should be stateless.
-----------------

# 935_Knight_Dialer
# 935. Knight Dialer

A chess knight can move as indicated in the chess diagram below:

     .         
         

     

    This time, we place our chess knight on any numbered key of a phone pad (indicated above),
        and the knight makes N-1 hops.  Each hop must be from one key to another
        numbered key.

    Each time it lands on a key (including the initial placement of the knight), it presses the
        number of that key, pressing N digits total.

    How many distinct numbers can you dial in this manner?

    Since the answer may be large, output the answer modulo 10^9 +
        7.
-----------------

# 245_Shortest_Word_Distance_III
# 245. Shortest Word Distance III

Given a list of words and two words word1 and word2, return the shortest
        distance between these two words in the list.

    word1 and word2 may be the same and they represent two individual words in
        the list.

    Example:
        Assume that words = ["practice", "makes", "perfect",
            "coding", "makes"].

    Input: word1 = “makes”, word2 = “coding”
Output: 1

    Input: word1 = "makes", word2 = "makes"
Output: 3

    Note:
        You may assume word1 and word2 are both in the list.
-----------------

# 264_Ugly_Number_II
# 264. Ugly Number II

Write a program to find the n-th ugly number.

    Ugly numbers are positive numbers whose prime factors only include 2,
        3, 5. 

    Example:

    Input: n = 10
Output: 12
Explanation: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 is the sequence of the first 10 ugly numbers.

    Note:  

    
        1 is typically treated as an ugly number.
        n does not exceed 1690.
-----------------

# 1365_How_Many_Numbers_Are_Smaller_Than_the_Current_Number
# 1365. How Many Numbers Are Smaller Than the Current Number


-----------------

# 519_Random_Flip_Matrix
# 519. Random Flip Matrix

You are given the number of rows n_rows and number of columns
        n_cols of a 2D binary matrix where all values are initially
        0. Write a function flip which chooses a 0 value uniformly
            at random, changes it to 1, and then returns the position [row.id,
            col.id] of that value. Also, write a function reset which sets all
        values back to 0. Try to minimize the number of calls to system's
            Math.random() and optimize the time and space complexity.

    Note:

    
        1 <= n_rows, n_cols <= 10000
        0 <= row.id < n_rows and 0 <= col.id < n_cols
        flip will not be called when the matrix has no 0 values left.
        
        the total number of calls to flip and reset will
            not exceed 1000.
        
    

    Example 1:

    Input:
["Solution","flip","flip","flip","flip"]
[[2,3],[],[],[],[]]
Output: [null,[0,1],[1,2],[1,0],[1,1]]
-----------------

# 1659_Maximize_Grid_Happiness
# 1659. Maximize Grid Happiness


-----------------

# 340_Longest_Substring_with_At_Most_K_Distinct_Characters
# 340. Longest Substring with At Most K Distinct Characters

Given a string, find the length of the longest substring T that contains at most k
        distinct characters.

    Example 1:
-----------------

# 1563_Stone_Game_V
# 1563. Stone Game V


-----------------

# 891_Sum_of_Subsequence_Widths
# 891. Sum of Subsequence Widths

Given an array of integers A, consider all non-empty subsequences of
        A.

    For any sequence S, let the width of S be the difference between the
        maximum and minimum element of S.

    Return the sum of the widths of all subsequences of A. 

    As the answer may be very large, return the answer modulo 10^9 + 7.
-----------------

# 1207_Unique_Number_of_Occurrences
# 1207. Unique Number of Occurrences

Given an array of integers arr, write a function that returns
        true if and only if the number of occurrences of each value in the array is
        unique.

     
    Example 1:

    Input: arr = [1,2,2,1,1,3]
Output: true
Explanation: The value 1 has 3 occurrences, 2 has 2 and 3 has 1. No two values have the same number of occurrences.

    Example 2:

    Input: arr = [1,2]
Output: false

    Example 3:

    Input: arr = [-3,0,1,-3,1,1,1,-3,10,0]
Output: true

     
    Constraints:

    
        1 <= arr.length <= 1000
        -1000 <= arr[i] <= 1000
-----------------

# 550_Game_Play_Analysis_IV
# 550. Game Play Analysis IV

Table: Activity

    +--------------+---------+
| Column Name  | Type    |
+--------------+---------+
| player_id    | int     |
| device_id    | int     |
| event_date   | date    |
| games_played | int     |
+--------------+---------+
(player_id, event_date) is the primary key of this table.
This table shows the activity of players of some game.
Each row is a record of a player who logged in and played a number of games (possibly 0) before logging out on some day using some device.

     

    Write an SQL query that reports the fraction of players that logged in again
        on the day after the day they first logged in, rounded to 2 decimal
            places. In other words, you need to count the number of players that
        logged in for at least two consecutive days starting from their first login date, then
        divide that number by the total number of players.

    The query result format is in the following example:

    Activity table:
+-----------+-----------+------------+--------------+
| player_id | device_id | event_date | games_played |
+-----------+-----------+------------+--------------+
| 1         | 2         | 2016-03-01 | 5            |
| 1         | 2         | 2016-03-02 | 6            |
| 2         | 3         | 2017-06-25 | 1            |
| 3         | 1         | 2016-03-02 | 0            |
| 3         | 4         | 2018-07-03 | 5            |
+-----------+-----------+------------+--------------+

Result table:
+-----------+
| fraction  |
+-----------+
| 0.33      |
+-----------+
Only the player with id 1 logged back in after the first day he had logged in so the answer is 1/3 = 0.33
-----------------

# 1469_Find_All_the_Lonely_Nodes
# 1469. Find All the Lonely Nodes


-----------------

# 780_Reaching_Points
# 780. Reaching Points

A move consists of taking a point (x, y) and transforming it to either (x,
        x+y) or (x+y, y).

    Given a starting point (sx, sy) and a target point (tx, ty), return
        True if and only if a sequence of moves exists to transform the point (sx,
            sy) to (tx, ty). Otherwise, return False.

    Examples:
Input: sx = 1, sy = 1, tx = 3, ty = 5
Output: True
Explanation:
One series of moves that transforms the starting point to the target is:
(1, 1) -> (1, 2)
(1, 2) -> (3, 2)
(3, 2) -> (3, 5)

Input: sx = 1, sy = 1, tx = 2, ty = 2
Output: False

Input: sx = 1, sy = 1, tx = 1, ty = 1
Output: True

    Note:

    
        sx, sy, tx, ty will all be integers in the range [1, 10^9].
-----------------

# 455_Assign_Cookies
# 455. Assign Cookies

Assume you are an awesome parent and want to give your children some cookies. But, you
        should give each child at most one cookie. Each child i has a greed factor gi,
        which is the minimum size of a cookie that the child will be content with; and each cookie j
        has a size sj. If sj >= gi, we can assign the cookie j to
        the child i, and the child i will be content. Your goal is to maximize the number of your
        content children and output the maximum number.
    

    Note:
        You may assume the greed factor is always positive. 
        You cannot assign more than one cookie to one child.
    

    Example 1:
    Input: [1,2,3], [1,1]

Output: 1

Explanation: You have 3 children and 2 cookies. The greed factors of 3 children are 1, 2, 3.
And even though you have 2 cookies, since their size is both 1, you could only make the child whose greed factor is 1 content.
You need to output 1.

    

    Example 2:
    Input: [1,2], [1,2,3]

Output: 2

Explanation: You have 2 children and 3 cookies. The greed factors of 2 children are 1, 2.
You have 3 cookies and their sizes are big enough to gratify all of the children,
You need to output 2.
-----------------

# 978_Longest_Turbulent_Subarray
# 978. Longest Turbulent Subarray

A subarray A[i], A[i+1], ..., A[j] of A is said to be turbulent
        if and only if:

    
        For i <= k < j, A[k] > A[k+1] when k is
            odd, and A[k] < A[k+1] when k is even;
        
        OR, for i <= k < j, A[k] > A[k+1]
            when k is even, and A[k] < A[k+1] when k is
            odd.
        
    

    That is, the subarray is turbulent if the comparison sign flips between each adjacent pair of
        elements in the subarray.

    Return the length of a maximum size turbulent subarray of A.
-----------------

# 1736_Latest_Time_by_Replacing_Hidden_Digits
# 1736. Latest Time by Replacing Hidden Digits


-----------------

# 275_H-Index_II
# 275. H-Index II

Given an array of citations sorted in ascending order (each citation is
        a non-negative integer) of a researcher, write a function to compute the researcher's
        h-index.

    According to the definition
        of h-index on Wikipedia: "A scientist has index h if h of
        his/her N papers have at least h citations
        each, and the other N − h papers have no more
            than h citations each."

    Example:

    Input: citations = [0,1,3,5,6]
Output: 3
Explanation: [0,1,3,5,6] means the researcher has 5 papers in total and each of them had
             received 0, 1, 3, 5, 6 citations respectively.
             Since the researcher has 3 papers with at least 3 citations each and the remaining
             two with no more than 3 citations each, her h-index is 3.

    Note:

    If there are several possible values for h, the maximum one is taken as the
        h-index.

    Follow up:

    
        This is a follow up problem to H-Index, where citations
            is now guaranteed to be sorted in ascending order.
        
        Could you solve it in logarithmic time complexity?
-----------------

# 1235_Maximum_Profit_in_Job_Scheduling
# 1235. Maximum Profit in Job Scheduling

We have n jobs, where every job is scheduled to be done from startTime[i]
        to endTime[i], obtaining a profit of profit[i].

    You're given the startTime , endTime and
        profit arrays, you need to output the maximum profit you can take
        such that there are no 2 jobs in the subset with overlapping time range.

    If you choose a job that ends at time X you will be able to start
        another job that starts at time X.

     
    Example 1:

    

    Input: startTime = [1,2,3,3], endTime = [3,4,5,6], profit = [50,10,40,70]
Output: 120
Explanation: The subset chosen is the first and fourth job.
Time range [1-3]+[3-6] , we get profit of 120 = 50 + 70.

    Example 2:

     

    
Input: startTime = [1,2,3,4,6], endTime = [3,5,10,6,9], profit = [20,20,100,70,60]
Output: 150
Explanation: The subset chosen is the first, fourth and fifth job.
Profit obtained 150 = 20 + 70 + 60.

    Example 3:

    

    Input: startTime = [1,1,1], endTime = [2,3,4], profit = [5,6,4]
Output: 6

     
    Constraints:

    
        1 <= startTime.length == endTime.length == profit.length <= 5 *
            10^4
        1 <= startTime[i] < endTime[i] <= 10^9
        1 <= profit[i] <= 10^4
-----------------

# 1404_Number_of_Steps_to_Reduce_a_Number_in_Binary_Representation_to_One
# 1404. Number of Steps to Reduce a Number in Binary Representation to One


-----------------

# 1020_Number_of_Enclaves
# 1020. Number of Enclaves

Given a 2D array A, each cell is 0 (representing sea) or 1 (representing land)
    

    A move consists of walking from one land square 4-directionally to another land square, or
        off the boundary of the grid.

    Return the number of land squares in the grid for which we cannot walk off
        the boundary of the grid in any number of moves.

     

    Example 1:

    Input: [[0,0,0,0],[1,0,1,0],[0,1,1,0],[0,0,0,0]]
Output: 3
Explanation: 
There are three 1s that are enclosed by 0s, and one 1 that isn't enclosed because its on the boundary.

    Example 2:

    Input: [[0,1,1,0],[0,0,1,0],[0,0,1,0],[0,0,0,0]]
Output: 0
Explanation: 
All 1s are either on the boundary or can reach the boundary.

     

    Note:

    
        1 <= A.length <= 500
        1 <= A[i].length <= 500
        0 <= A[i][j] <= 1
        All rows have the same size.
-----------------

# 1303_Find_the_Team_Size
# 1303. Find the Team Size


-----------------

# 459_Repeated_Substring_Pattern
# 459. Repeated Substring Pattern

Given a non-empty string check if it can be constructed by taking a substring of it and
        appending multiple copies of the substring together. You may assume the given string
        consists of lowercase English letters only and its length will not exceed 10000.

     

    Example 1:

    Input: "abab"
Output: True
Explanation: It's the substring "ab" twice.

    Example 2:

    Input: "aba"
Output: False

    Example 3:

    Input: "abcabcabcabc"
Output: True
Explanation: It's the substring "abc" four times. (And the substring "abcabc" twice.)
-----------------

# 1547_Minimum_Cost_to_Cut_a_Stick
# 1547. Minimum Cost to Cut a Stick


-----------------

# 1341_Movie_Rating
# 1341. Movie Rating


-----------------

# 1042_Flower_Planting_With_No_Adjacent
# 1042. Flower Planting With No Adjacent

You have N gardens, labelled 1 to N.  In each
        garden, you want to plant one of 4 types of flowers.

    paths[i] = [x, y] describes the existence of a bidirectional path from garden
        x to garden y.

    Also, there is no garden that has more than 3 paths coming into or leaving it.

    Your task is to choose a flower type for each garden such that, for any two gardens
        connected by a path, they have different types of flowers.

    Return any such a choice as an array answer, where answer[i]
        is the type of flower planted in the (i+1)-th garden.  The flower
        types are denoted 1, 2,
        3, or 4.  It is guaranteed
        an answer exists.
-----------------

# 87_Scramble_String
# 87. Scramble String

Given a string s1, we may represent it as a binary tree by partitioning it to two
        non-empty substrings recursively.

    Below is one possible representation of s1 = "great":

        great
   /    \
  gr    eat
 / \    /  \
g   r  e   at
           / \
          a   t

    To scramble the string, we may choose any non-leaf node and swap its two children.

    For example, if we choose the node "gr" and swap its two children, it
        produces a scrambled string "rgeat".

        rgeat
   /    \
  rg    eat
 / \    /  \
r   g  e   at
           / \
          a   t

    We say that "rgeat" is a scrambled string of
        "great".

    Similarly, if we continue to swap the children of nodes "eat" and
        "at", it produces a scrambled string "rgtae".
    

        rgtae
   /    \
  rg    tae
 / \    /  \
r   g  ta  e
       / \
      t   a

    We say that "rgtae" is a scrambled string of
        "great".

    Given two strings s1 and s2 of the same length, determine if s2 is
        a scrambled string of s1.

    Example 1:

    Input: s1 = "great", s2 = "rgeat"
Output: true

    Example 2:

    Input: s1 = "abcde", s2 = "caebd"
Output: false
-----------------

# 1677_Product's_Worth_Over_Invoices
# 1677. Product's Worth Over Invoices


-----------------

# 969_Pancake_Sorting
# 969. Pancake Sorting

Given an array A, we can perform a pancake flip: We choose
        some positive integer k <= A.length, then reverse the
        order of the first k elements of A.  We want to perform
        zero or more pancake flips (doing them one after another in succession) to sort the array
        A.

    Return the k-values corresponding to a sequence of pancake flips that sort A. 
        Any valid answer that sorts the array within 10 * A.length flips will be
        judged as correct.

     

    Example 1:

    Input: [3,2,4,1]
Output: [4,2,4,3]
Explanation: 
We perform 4 pancake flips, with k values 4, 2, 4, and 3.
Starting state: A = [3, 2, 4, 1]
After 1st flip (k=4): A = [1, 4, 2, 3]
After 2nd flip (k=2): A = [4, 1, 2, 3]
After 3rd flip (k=4): A = [3, 2, 1, 4]
After 4th flip (k=3): A = [1, 2, 3, 4], which is sorted.
-----------------

# 998_Maximum_Binary_Tree_II
# 998. Maximum Binary Tree II

We are given the root node of a maximum tree: a tree where every
        node has a value greater than any other value in its subtree.

    Just as in the previous
        problem, the given tree was constructed from an
        list A (root = Construct(A)) recursively with the
        following Construct(A) routine:

    
        If A is empty, return null.
        Otherwise, let A[i] be the largest element of A.  Create
            a root node with value A[i].
        
        The left child of root will be Construct([A[0], A[1], ...,
            A[i-1]])
        The right child of root will be Construct([A[i+1], A[i+2], ...,
            A[A.length - 1]])
        Return root.
    

    Note that we were not given A directly, only a root node root = Construct(A).
    

    Suppose B is a copy of A with the value val appended
        to it.  It is guaranteed that B has unique values.

    Return Construct(B).

     

    Example 1:

    
    

    Input: root = [4,1,3,null,null,2], val = 5
Output: [5,4,null,1,3,null,null,2]
Explanation: A = [1,4,2,3], B = [1,4,2,3,5]
-----------------

# 547_Friend_Circles
# 547. Friend Circles

There are N students in a class. Some of them are friends, while some are not. Their
        friendship is transitive in nature. For example, if A is a direct friend of B, and B
        is a direct friend of C, then A is an indirect friend of C. And we defined a
        friend circle is a group of students who are direct or indirect friends.
    

    
        Given a N*N matrix M representing the friend relationship between students in
        the class. If M[i][j] = 1, then the ith and jth students are
        direct friends with each other, otherwise not. And you have to output the total
        number of friend circles among all the students.
    

    Example 1:
    Input:
[[1,1,0],
 [1,1,0],
 [0,0,1]]
Output: 2
Explanation:The 0th and 1st students are direct friends, so they are in a friend circle. The 2nd student himself is in a friend circle. So return 2.

    

    Example 2:
    Input:
[[1,1,0],
 [1,1,1],
 [0,1,1]]
Output: 1
Explanation:The 0th and 1st students are direct friends, the 1st and 2nd students are direct friends, so the 0th and 2nd students are indirect friends. All of them are in the same friend circle, so return 1.

    

    Note:
    
        N is in range [1,200].
        M[i][i] = 1 for all students.
        If M[i][j] = 1, then M[j][i] = 1.
-----------------

# 494_Target_Sum
# 494. Target Sum

You are given a list of non-negative integers, a1, a2, ..., an, and a target, S. Now you
        have 2 symbols + and -. For each integer, you should choose one
        from + and - as its new symbol.
    

    Find out how many ways to assign symbols to make sum of integers equal to target S.
    

    Example 1:
    Input: nums is [1, 1, 1, 1, 1], S is 3.
Output: 5
Explanation:

-1+1+1+1+1 = 3
+1-1+1+1+1 = 3
+1+1-1+1+1 = 3
+1+1+1-1+1 = 3
+1+1+1+1-1 = 3

There are 5 ways to assign symbols to make the sum of nums be target 3.

    

    Note:
    
        The length of the given array is positive and will not exceed 20.
        The sum of elements in the given array will not exceed 1000.
        Your output answer is guaranteed to be fitted in a 32-bit integer.
-----------------

# 1262_Greatest_Sum_Divisible_by_Three
# 1262. Greatest Sum Divisible by Three


-----------------

# 823_Binary_Trees_With_Factors
# 823. Binary Trees With Factors

Given an array of unique integers, each integer is strictly greater than 1.

    We make a binary tree using these integers and each number may be used for any number of
        times.

    Each non-leaf node's value should be equal to the product of the values of it's
        children.

    How many binary trees can we make?  Return the answer modulo 10 ** 9 +
        7.

    Example 1:

    Input: A = [2, 4]
Output: 3
Explanation: We can make these trees: [2], [4], [4, 2, 2]

    Example 2:

    Input: A = [2, 4, 5, 10]
Output: 7
Explanation: We can make these trees: [2], [4], [5], [10], [4, 2, 2], [10, 2, 5], [10, 5, 2].

     

    Note:

    
        1 <= A.length <= 1000.
        2 <= A[i] <= 10 ^ 9.
-----------------

# 1799_Maximize_Score_After_N_Operations
# 1799. Maximize Score After N Operations


-----------------

# 607_Sales_Person
# 607. Sales Person

Description

    Given three tables: salesperson, company, orders.
        Output all the names in the table salesperson, who didn’t have
        sales to company 'RED'.

    Example
        Input

    Table: salesperson

    +----------+------+--------+-----------------+-----------+
| sales_id | name | salary | commission_rate | hire_date |
+----------+------+--------+-----------------+-----------+
|   1      | John | 100000 |     6           | 4/1/2006  |
|   2      | Amy  | 120000 |     5           | 5/1/2010  |
|   3      | Mark | 65000  |     12          | 12/25/2008|
|   4      | Pam  | 25000  |     25          | 1/1/2005  |
|   5      | Alex | 50000  |     10          | 2/3/2007  |
+----------+------+--------+-----------------+-----------+

    The table salesperson holds the salesperson information. Every salesperson has a
    sales_id and a name.

    Table: company

    +---------+--------+------------+
| com_id  |  name  |    city    |
+---------+--------+------------+
|   1     |  RED   |   Boston   |
|   2     | ORANGE |   New York |
|   3     | YELLOW |   Boston   |
|   4     | GREEN  |   Austin   |
+---------+--------+------------+

    The table company holds the company information. Every company has a com_id
    and a name.

    Table: orders

    +----------+------------+---------+----------+--------+
| order_id | order_date | com_id  | sales_id | amount |
+----------+------------+---------+----------+--------+
| 1        |   1/1/2014 |    3    |    4     | 100000 |
| 2        |   2/1/2014 |    4    |    5     | 5000   |
| 3        |   3/1/2014 |    1    |    1     | 50000  |
| 4        |   4/1/2014 |    1    |    4     | 25000  |
+----------+----------+---------+----------+--------+

    The table orders holds the sales record information, salesperson and customer
    company are represented by sales_id and com_id.

    output

    +------+
| name |
+------+
| Amy  |
| Mark |
| Alex |
+------+

    Explanation

    According to order '3' and '4' in table orders, it is easy to
        tell only salesperson 'John' and 'Alex' have sales to company 'RED',
        so we need to output all the other names in table salesperson.
-----------------

# 227_Basic_Calculator_II
# 227. Basic Calculator II

Implement a basic calculator to evaluate a simple expression string.

    The expression string contains only non-negative integers, +,
        -, *, / operators and empty spaces  .
        The integer division should truncate toward zero.

    Example 1:

    Input: "3+2*2"
Output: 7

    Example 2:

    Input: " 3/2 "
Output: 1

    Example 3:

    Input: " 3+5 / 2 "
Output: 5

    Note:

    
        You may assume that the given expression is always valid.
        Do not use the eval built-in library function.
-----------------

# 1349_Maximum_Students_Taking_Exam
# 1349. Maximum Students Taking Exam


-----------------

# 1371_Find_the_Longest_Substring_Containing_Vowels_in_Even_Counts
# 1371. Find the Longest Substring Containing Vowels in Even Counts


-----------------

# 78_Subsets
# 78. Subsets

Given a set of distinct integers, nums, return all possible subsets
        (the power set).

    Note: The solution set must not contain duplicate subsets.

    Example:

    Input: nums = [1,2,3]
Output:
[
  [3],
  [1],
  [2],
  [1,2,3],
  [1,3],
  [2,3],
  [1,2],
  []
]
-----------------

# 577_Employee_Bonus
# 577. Employee Bonus

Select all employee's name and bonus whose bonus is < 1000.

    Table:Employee 

    +-------+--------+-----------+--------+
| empId |  name  | supervisor| salary |
+-------+--------+-----------+--------+
|   1   | John   |  3        | 1000   |
|   2   | Dan    |  3        | 2000   |
|   3   | Brad   |  null     | 4000   |
|   4   | Thomas |  3        | 4000   |
+-------+--------+-----------+--------+
empId is the primary key column for this table.

    Table: Bonus

    +-------+-------+
| empId | bonus |
+-------+-------+
| 2     | 500   |
| 4     | 2000  |
+-------+-------+
empId is the primary key column for this table.

    Example ouput:

    +-------+-------+
| name  | bonus |
+-------+-------+
| John  | null  |
| Dan   | 500   |
| Brad  | null  |
+-------+-------+
-----------------

# 1205_Monthly_Transactions_II
# 1205. Monthly Transactions II

Table: Transactions

    +----------------+---------+
| Column Name    | Type    |
+----------------+---------+
| id             | int     |
| country        | varchar |
| state          | enum    |
| amount         | int     |
| trans_date     | date    |
+----------------+---------+
id is the primary key of this table.
The table has information about incoming transactions.
The state column is an enum of type ["approved", "declined"].

    Table: Chargebacks

    +----------------+---------+
| Column Name    | Type    |
+----------------+---------+
| trans_id       | int     |
| charge_date    | date    |
+----------------+---------+
Chargebacks contains basic information regarding incoming chargebacks from some transactions placed in Transactions table.
trans_id is a foreign key to the id column of Transactions table.
Each chargeback corresponds to a transaction made previously even if they were not approved.

     

    Write an SQL query to find for each month and country, the number of approved transactions
        and their total amount, the number of chargebacks and their total amount.

    Note: In your query, given the month and country, ignore rows with
        all zeros.

    The query result format is in the following example:

    Transactions table:
+------+---------+----------+--------+------------+
| id   | country | state    | amount | trans_date |
+------+---------+----------+--------+------------+
| 101  | US      | approved | 1000   | 2019-05-18 |
| 102  | US      | declined | 2000   | 2019-05-19 |
| 103  | US      | approved | 3000   | 2019-06-10 |
| 104  | US      | approved | 4000   | 2019-06-13 |
| 105  | US      | approved | 5000   | 2019-06-15 |
+------+---------+----------+--------+------------+

Chargebacks table:
+------------+------------+
| trans_id   | trans_date |
+------------+------------+
| 102        | 2019-05-29 |
| 101        | 2019-06-30 |
| 105        | 2019-09-18 |
+------------+------------+

Result table:
+----------+---------+----------------+-----------------+-------------------+--------------------+
| month    | country | approved_count | approved_amount | chargeback_count  | chargeback_amount  |
+----------+---------+----------------+-----------------+-------------------+--------------------+
| 2019-05  | US      | 1              | 1000            | 1                 | 2000               |
| 2019-06  | US      | 3              | 12000           | 1                 | 1000               |
| 2019-09  | US      | 0              | 0               | 1                 | 5000               |
+----------+---------+----------------+-----------------+-------------------+--------------------+
-----------------

# 1318_Minimum_Flips_to_Make_a_OR_b_Equal_to_c
# 1318. Minimum Flips to Make a OR b Equal to c


-----------------

# 1435_Create_a_Session_Bar_Chart
# 1435. Create a Session Bar Chart


-----------------

# 1299_Replace_Elements_with_Greatest_Element_on_Right_Side
# 1299. Replace Elements with Greatest Element on Right Side


-----------------

# 522_Longest_Uncommon_Subsequence_II
# 522. Longest Uncommon Subsequence II

Given a list of strings, you need to find the longest uncommon subsequence among them. The
        longest uncommon subsequence is defined as the longest subsequence of one of these strings
        and this subsequence should not be any subsequence of the other strings.
    

    
        A subsequence is a sequence that can be derived from one sequence by deleting some
        characters without changing the order of the remaining elements. Trivially, any string is a
        subsequence of itself and an empty string is a subsequence of any string.
    

    
        The input will be a list of strings, and the output needs to be the length of the longest
        uncommon subsequence. If the longest uncommon subsequence doesn't exist, return -1.
    

    Example 1:
    Input: "aba", "cdc", "eae"
Output: 3

    

    Note:
    
        All the given strings' lengths will not exceed 10.
        The length of the given list will be in the range of [2, 50].
-----------------

# 1754_Largest_Merge_Of_Two_Strings
# 1754. Largest Merge Of Two Strings


-----------------

# 1422_Maximum_Score_After_Splitting_a_String
# 1422. Maximum Score After Splitting a String


-----------------

# 899_Orderly_Queue
# 899. Orderly Queue

A string S of lowercase letters is given.  Then, we may make any number of
        moves.

    In each move, we choose one of the first K letters (starting from the
        left), remove it, and place it at the end of the string.

    Return the lexicographically smallest string we could have after any number of moves.
-----------------

# 1307_Verbal_Arithmetic_Puzzle
# 1307. Verbal Arithmetic Puzzle


-----------------

# 1649_Create_Sorted_Array_through_Instructions
# 1649. Create Sorted Array through Instructions


-----------------

# 1664_Ways_to_Make_a_Fair_Array
# 1664. Ways to Make a Fair Array


-----------------

# 1720_Decode_XORed_Array
# 1720. Decode XORed Array


-----------------

# 1482_Minimum_Number_of_Days_to_Make_m_Bouquets
# 1482. Minimum Number of Days to Make m Bouquets


-----------------

# 1646_Get_Maximum_in_Generated_Array
# 1646. Get Maximum in Generated Array


-----------------

# 265_Paint_House_II
# 265. Paint House II

There are a row of n houses, each house can be painted with one of the k
        colors. The cost of painting each house with a certain color is different. You have to paint
        all the houses such that no two adjacent houses have the same color.

    The cost of painting each house with a certain color is represented by a n x k
        cost matrix. For example, costs[0][0] is the cost of painting house 0 with
        color 0; costs[1][2] is the cost of painting house 1 with color 2, and so on...
        Find the minimum cost to paint all houses.

    Note:
        All costs are positive integers.

    Example:

    Input: [[1,5,3],[2,9,4]]
Output: 5
Explanation: Paint house 0 into color 0, paint house 1 into color 2. Minimum cost: 1 + 4 = 5;
             Or paint house 0 into color 2, paint house 1 into color 0. Minimum cost: 3 + 2 = 5.

    Follow up:
        Could you solve it in O(nk) runtime?
-----------------

# 330_Patching_Array
# 330. Patching Array

Given a sorted positive integer array nums and an integer n, add/patch elements
        to the array such that any number in range [1, n] inclusive can be formed by
        the sum of some elements in the array. Return the minimum number of patches required.

    Example 1:

    Input: nums = [1,3], n = 6
Output: 1
Explanation:
Combinations of nums are [1], [3], [1,3], which form possible sums of: 1, 3, 4.
Now if we add/patch 2 to nums, the combinations are: [1], [2], [3], [1,3], [2,3], [1,2,3].
Possible sums are 1, 2, 3, 4, 5, 6, which now covers the range [1, 6].
So we only need 1 patch.

    Example 2:

    Input: nums = [1,5,10], n = 20
Output: 2
Explanation: The two patches can be [2, 4].

    Example 3:

    Input: nums = [1,2,2], n = 5
Output: 0
-----------------

# 1152_Analyze_User_Website_Visit_Pattern
# 1152. Analyze User Website Visit Pattern

We are given some website visits: the user with name username[i] visited
        the website website[i] at time timestamp[i].

    A 3-sequence is a list of websites of length 3 sorted in ascending order by
        the time of their visits.  (The websites in a 3-sequence are not necessarily distinct.)
    

    Find the 3-sequence visited by the largest number of users. If there is more than one
        solution, return the lexicographically smallest such 3-sequence.

     

    Example 1:

    Input: username = ["joe","joe","joe","james","james","james","james","mary","mary","mary"], timestamp = [1,2,3,4,5,6,7,8,9,10], website = ["home","about","career","home","cart","maps","home","home","about","career"]
Output: ["home","about","career"]
Explanation: 
The tuples in this example are:
["joe", 1, "home"]
["joe", 2, "about"]
["joe", 3, "career"]
["james", 4, "home"]
["james", 5, "cart"]
["james", 6, "maps"]
["james", 7, "home"]
["mary", 8, "home"]
["mary", 9, "about"]
["mary", 10, "career"]
The 3-sequence ("home", "about", "career") was visited at least once by 2 users.
The 3-sequence ("home", "cart", "maps") was visited at least once by 1 user.
The 3-sequence ("home", "cart", "home") was visited at least once by 1 user.
The 3-sequence ("home", "maps", "home") was visited at least once by 1 user.
The 3-sequence ("cart", "maps", "home") was visited at least once by 1 user.

     

    Note:

    
        3 <= N = username.length = timestamp.length = website.length <= 50
        
        1 <= username[i].length <= 10
        0 <= timestamp[i] <= 10^9
        1 <= website[i].length <= 10
        Both username[i] and website[i] contain only lowercase
            characters.
        
        It is guaranteed that there is at least one user who visited at least 3 websites.
        No user visits two websites at the same time.
-----------------

# 495_Teemo_Attacking
# 495. Teemo Attacking

In LOL world, there is a hero called Teemo and his attacking can make his enemy Ashe be in
        poisoned condition. Now, given the Teemo's attacking ascending time series
        towards Ashe and the poisoning time duration per Teemo's attacking, you need to output
        the total time that Ashe is in poisoned condition.

    You may assume that Teemo attacks at the very beginning of a specific time point, and makes
        Ashe be in poisoned condition immediately.

    Example 1:

    Input: [1,4], 2
Output: 4
Explanation: At time point 1, Teemo starts attacking Ashe and makes Ashe be poisoned immediately.
This poisoned status will last 2 seconds until the end of time point 2.
And at time point 4, Teemo attacks Ashe again, and causes Ashe to be in poisoned status for another 2 seconds.
So you finally need to output 4.

     

    Example 2:

    Input: [1,2], 2
Output: 3
Explanation: At time point 1, Teemo starts attacking Ashe and makes Ashe be poisoned.
This poisoned status will last 2 seconds until the end of time point 2.
However, at the beginning of time point 2, Teemo attacks Ashe again who is already in poisoned status.
Since the poisoned status won't add up together, though the second poisoning attack will still work at time point 2, it will stop at the end of time point 3.
So you finally need to output 3.

     

    Note:

    
        You may assume the length of given time series array won't exceed 10000.
        You may assume the numbers in the Teemo's attacking time series and his poisoning
            time duration per attacking are non-negative integers, which won't exceed
            10,000,000.
-----------------

# 492_Construct_the_Rectangle
# 492. Construct the Rectangle

For a web developer, it is very important to know how to design a web page's size. So, given
        a specific rectangular web page’s area, your job by now is to design a rectangular web page,
        whose length L and width W satisfy the following requirements:
    1. The area of the rectangular web page you designed must equal to the given target area.
2. The width W should not be larger than the length L, which means L >= W.
3. The difference between length L and width W should be as small as possible.

    You need to output the length L and the width W of the web page you designed in sequence.
    

    Example:
    Input: 4
Output: [2, 2]
Explanation: The target area is 4, and all the possible ways to construct it are [1,4], [2,2], [4,1].
But according to requirement 2, [1,4] is illegal; according to requirement 3,  [4,1] is not optimal compared to [2,2]. So the length L is 2, and the width W is 2.

    

    Note:
    
        The given area won't exceed 10,000,000 and is a positive integer
        The web page's width and length you designed must be positive integers.
-----------------

# 1293_Shortest_Path_in_a_Grid_with_Obstacles_Elimination
# 1293. Shortest Path in a Grid with Obstacles Elimination


-----------------

# 1792_Maximum_Average_Pass_Ratio
# 1792. Maximum Average Pass Ratio


-----------------

# 1019_Next_Greater_Node_In_Linked_List
# 1019. Next Greater Node In Linked List

We are given a linked list with head as the first node.  Let's
        number the nodes in the list: node_1, node_2, node_3, ... etc.

    Each node may have a next larger value: for node_i, next_larger(node_i) is
        the node_j.val such that j > i, node_j.val >
            node_i.val, and j is the smallest possible choice.  If such a
        j does not exist, the next larger value is 0.

    Return an array of integers answer, where answer[i] =
        next_larger(node_{i+1}).

    Note that in the example inputs (not outputs) below, arrays such as
        [2,1,5] represent the serialization of a linked list with a head node
        value of 2, second node value of 1, and third node value of 5.
-----------------

# 1201_Ugly_Number_III
# 1201. Ugly Number III

Write a program to find the n-th ugly number.

    Ugly numbers are positive integers which are divisible
        by a or b or
        c.

     
    Example 1:

    Input: n = 3, a = 2, b = 3, c = 5
Output: 4
Explanation: The ugly numbers are 2, 3, 4, 5, 6, 8, 9, 10... The 3rd is 4.

    Example 2:

    Input: n = 4, a = 2, b = 3, c = 4
Output: 6
Explanation: The ugly numbers are 2, 3, 4, 6, 8, 9, 10, 12... The 4th is 6.

    Example 3:

    Input: n = 5, a = 2, b = 11, c = 13
Output: 10
Explanation: The ugly numbers are 2, 4, 6, 8, 10, 11, 12, 13... The 5th is 10.

    Example 4:

    Input: n = 1000000000, a = 2, b = 217983653, c = 336916467
Output: 1999999984

     
    Constraints:

    
        1 <= n, a, b, c <= 10^9
        1 <= a * b * c <= 10^18
        It's guaranteed that the result will be in range [1, 2 *
            10^9]
-----------------

# 1269_Number_of_Ways_to_Stay_in_the_Same_Place_After_Some_Steps
# 1269. Number of Ways to Stay in the Same Place After Some Steps


-----------------

# 1515_Best_Position_for_a_Service_Centre
# 1515. Best Position for a Service Centre


-----------------

# 1047_Remove_All_Adjacent_Duplicates_In_String
# 1047. Remove All Adjacent Duplicates In String

Given a string S of lowercase letters, a duplicate removal consists of
        choosing two adjacent and equal letters, and removing them.

    We repeatedly make duplicate removals on S until we no longer can.

    Return the final string after all such duplicate removals have been made.  It is
        guaranteed the answer is unique.

     

    Example 1:

    Input: "abbaca"
Output: "ca"
Explanation: 
For example, in "abbaca" we could remove "bb" since the letters are adjacent and equal, and this is the only possible move.  The result of this move is that the string is "aaca", of which only "aa" is possible, so the final string is "ca".

     

    Note:

    
        1 <= S.length <= 20000
        S consists only of English lowercase letters.
-----------------

# 789_Escape_The_Ghosts
# 789. Escape The Ghosts

You are playing a simplified Pacman game. You start at the point (0, 0),
        and your destination is (target[0], target[1]). There are several ghosts on the
        map, the i-th ghost starts at (ghosts[i][0], ghosts[i][1]).

    Each turn, you and all ghosts simultaneously *may* move in one of 4 cardinal directions:
        north, east, west, or south, going from the previous point to a new point 1 unit of distance
        away.

    You escape if and only if you can reach the target before any ghost reaches you (for any
        given moves the ghosts may take.)  If you reach any square (including the target) at
        the same time as a ghost, it doesn't count as an escape.

    Return True if and only if it is possible to escape.

    Example 1:
Input:
ghosts = [[1, 0], [0, 3]]
target = [0, 1]
Output: true
Explanation:
You can directly reach the destination (0, 1) at time 1, while the ghosts located at (1, 0) or (0, 3) have no way to catch up with you.

    Example 2:
Input:
ghosts = [[1, 0]]
target = [2, 0]
Output: false
Explanation:
You need to reach the destination (2, 0), but the ghost at (1, 0) lies between you and the destination.

    Example 3:
Input:
ghosts = [[2, 0]]
target = [1, 0]
Output: false
Explanation:
The ghost can reach the target at the same time as you.

    Note:

    
        All points have coordinates with absolute value <= 10000.
        The number of ghosts will not exceed 100.
-----------------

# 962_Maximum_Width_Ramp
# 962. Maximum Width Ramp

Given an array A of integers, a ramp is a tuple (i,
        j) for which i < j and A[i] <= A[j]. 
        The width of such a ramp is j - i.

    Find the maximum width of a ramp in A.  If one doesn't exist, return 0.
    

     

    Example 1:

    Input: [6,0,8,2,1,5]
Output: 4
Explanation: 
The maximum width ramp is achieved at (i, j) = (1, 5): A[1] = 0 and A[5] = 5.
-----------------

# 327_Count_of_Range_Sum
# 327. Count of Range Sum

Given an integer array nums, return the number of range sums that lie in [lower,
        upper] inclusive.
        Range sum S(i, j) is defined as the sum of the elements in nums
        between indices i and j (i ≤ j),
        inclusive.

    Note:
        A naive algorithm of O(n2) is trivial. You MUST do better than
        that.

    Example:

    Input: nums = [-2,5,-1], lower = -2, upper = 2,
Output: 3
Explanation: The three ranges are : [0,0], [2,2], [0,2] and their respective sums are: -2, -1, 2.
-----------------

# 1676_Lowest_Common_Ancestor_of_a_Binary_Tree_IV
# 1676. Lowest Common Ancestor of a Binary Tree IV


-----------------

# 1218_Longest_Arithmetic_Subsequence_of_Given_Difference
# 1218. Longest Arithmetic Subsequence of Given Difference

Given an integer array arr and an integer difference,
        return the length of the longest subsequence in arr which
        is an arithmetic sequence such that the difference between adjacent elements in the
        subsequence equals difference.

     
    Example 1:

    Input: arr = [1,2,3,4], difference = 1
Output: 4
Explanation: The longest arithmetic subsequence is [1,2,3,4].

    Example 2:

    Input: arr = [1,3,5,7], difference = 1
Output: 1
Explanation: The longest arithmetic subsequence is any single element.

    Example 3:

    Input: arr = [1,5,7,8,5,3,4,2,1], difference = -2
Output: 4
Explanation: The longest arithmetic subsequence is [7,5,3,1].

     
    Constraints:

    
        1 <= arr.length <= 10^5
        -10^4 <= arr[i], difference <= 10^4
-----------------

# 427_Construct_Quad_Tree
# 427. Construct Quad Tree

We want to use quad trees to store an N x N boolean grid. Each cell in the grid
        can only be true or false. The root node represents the whole grid. For each node, it will
        be subdivided into four children nodes until the values in the region it represents
            are all the same.

    Each node has another two boolean attributes : isLeaf and val.
        isLeaf is true if and only if the node is a leaf node. The val
        attribute for a leaf node contains the value of the region it represents.

    Your task is to use a quad tree to represent a given grid. The following example may help you
        understand the problem better:

    Given the 8 x 8 grid below, we want to construct the corresponding quad tree:
    

    

    It can be divided according to the definition above:

    

     

    The corresponding quad tree should be as following, where each node is represented as a
        (isLeaf, val) pair.

    For the non-leaf nodes, val can be arbitrary, so it is represented as
        *.

    

    Note:

    
        N is less than 1000 and guaranteened to be a power of 2.
        If you want to know more about the quad tree, you can refer to its wiki.
-----------------

# 1695_Maximum_Erasure_Value
# 1695. Maximum Erasure Value


-----------------

# 1035_Uncrossed_Lines
# 1035. Uncrossed Lines

We write the integers of A and B (in the order they are given)
        on two separate horizontal lines.

    Now, we may draw connecting lines: a straight line connecting two numbers
        A[i] and B[j] such that:

    
        A[i] == B[j];
        The line we draw does not intersect any other connecting (non-horizontal) line.
    

    Note that a connecting lines cannot intersect even at the endpoints: each number can
        only belong to one connecting line.

    Return the maximum number of connecting lines we can draw in this way.

     

    Example 1:
    
    Input: A = [1,4,2], B = [1,2,4]
Output: 2
Explanation: We can draw 2 uncrossed lines as in the diagram.
We cannot draw 3 uncrossed lines, because the line from A[1]=4 to B[2]=4 will intersect the line from A[2]=2 to B[1]=2.
-----------------

# 1749_Maximum_Absolute_Sum_of_Any_Subarray
# 1749. Maximum Absolute Sum of Any Subarray


-----------------

# 1485_Clone_Binary_Tree_With_Random_Pointer
# 1485. Clone Binary Tree With Random Pointer


-----------------

# 533_Lonely_Pixel_II
# 533. Lonely Pixel II

Given a picture consisting of black and white pixels, and a positive integer N, find the
        number of black pixels located at some specific row R and column C that align
        with all the following rules:

    
         Row R and column C both contain exactly N black pixels.
         For all rows that have a black pixel at column C, they should be exactly the same as
            row R
        
    

    The picture is represented by a 2D char array consisting of 'B' and 'W', which means black
        and white pixels respectively. 

    Example:
    Input:
[['W', 'B', 'W', 'B', 'B', 'W'],
 ['W', 'B', 'W', 'B', 'B', 'W'],
 ['W', 'B', 'W', 'B', 'B', 'W'],
 ['W', 'W', 'B', 'W', 'B', 'W']]

N = 3
Output: 6
Explanation: All the bold 'B' are the black pixels we need (all 'B's at column 1 and 3).
        0    1    2    3    4    5         column index
0    [['W', 'B', 'W', 'B', 'B', 'W'],
1     ['W', 'B', 'W', 'B', 'B', 'W'],
2     ['W', 'B', 'W', 'B', 'B', 'W'],
3     ['W', 'W', 'B', 'W', 'B', 'W']]
row index

Take 'B' at row R = 0 and column C = 1 as an example:
Rule 1, row R = 0 and column C = 1 both have exactly N = 3 black pixels.
Rule 2, the rows have black pixel at column C = 1 are row 0, row 1 and row 2. They are exactly the same as row R = 0.

    

    Note:
    
        The range of width and height of the input 2D array is [1,200].
-----------------

# 121_Best_Time_to_Buy_and_Sell_Stock
# 121. Best Time to Buy and Sell Stock

Say you have an array for which the ith element is the price of a given
        stock on day i.

    If you were only permitted to complete at most one transaction (i.e., buy one and sell one
        share of the stock), design an algorithm to find the maximum profit.

    Note that you cannot sell a stock before you buy one.

    Example 1:

    Input: [7,1,5,3,6,4]
Output: 5
Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.
             Not 7-1 = 6, as selling price needs to be larger than buying price.

    Example 2:

    Input: [7,6,4,3,1]
Output: 0
Explanation: In this case, no transaction is done, i.e. max profit = 0.
-----------------

# 1800_Maximum_Ascending_Subarray_Sum
# 1800. Maximum Ascending Subarray Sum


-----------------

# 720_Longest_Word_in_Dictionary
# 720. Longest Word in Dictionary

Given a list of strings words representing an English Dictionary, find the
        longest word in words that can be built one character at a time by other words
        in words. If there is more than one possible answer, return the longest word
        with the smallest lexicographical order. If there is no answer, return the empty string.

    Example 1:
    Input:
words = ["w","wo","wor","worl", "world"]
Output: "world"
Explanation:
The word "world" can be built one character at a time by "w", "wo", "wor", and "worl".

    

    Example 2:
    Input:
words = ["a", "banana", "app", "appl", "ap", "apply", "apple"]
Output: "apple"
Explanation:
Both "apply" and "apple" can be built from other words in the dictionary. However, "apple" is lexicographically smaller than "apply".

    

    Note:
    All the strings in the input will only contain lowercase letters.
    The length of words will be in the range [1, 1000].
    The length of words[i] will be in the range [1, 30].
-----------------

# 1333_Filter_Restaurants_by_Vegan-Friendly,_Price_and_Distance
# 1333. Filter Restaurants by Vegan-Friendly, Price and Distance


-----------------

# 1610_Maximum_Number_of_Visible_Points
# 1610. Maximum Number of Visible Points


-----------------

# 655_Print_Binary_Tree
# 655. Print Binary Tree

Print a binary tree in an m*n 2D string array following these rules: 

    
        The row number m should be equal to the height of the given binary tree.
        
        The column number n should always be an odd number.
        The root node's value (in string format) should be put in the exactly middle of the
            first row it can be put. The column and the row where the root node belongs will
            separate the rest space into two parts (left-bottom part and right-bottom part).
            You should print the left subtree in the left-bottom part and print the right subtree in
            the right-bottom part. The left-bottom part and the right-bottom part should have the
            same size. Even if one subtree is none while the other is not, you don't need to print
            anything for the none subtree but still need to leave the space as large as that for the
            other subtree. However, if two subtrees are none, then you don't need to leave space for
            both of them.
        
        Each unused space should contain an empty string "".
        Print the subtrees following the same rules.
    

    Example 1:
    Input:
     1
    /
   2
Output:
[["", "1", ""],
 ["2", "", ""]]

    

    Example 2:
    Input:
     1
    / \
   2   3
    \
     4
Output:
[["", "", "", "1", "", "", ""],
 ["", "2", "", "", "", "3", ""],
 ["", "", "4", "", "", "", ""]]

    

    Example 3:
    Input:
      1
     / \
    2   5
   /
  3
 /
4
Output:

[["",  "",  "", "",  "", "", "", "1", "",  "",  "",  "",  "", "", ""]
 ["",  "",  "", "2", "", "", "", "",  "",  "",  "",  "5", "", "", ""]
 ["",  "3", "", "",  "", "", "", "",  "",  "",  "",  "",  "", "", ""]
 ["4", "",  "", "",  "", "", "", "",  "",  "",  "",  "",  "", "", ""]]

    

    Note:
        The height of binary tree is in the range of [1, 10].
-----------------

# 481_Magical_String
# 481. Magical String

A magical string S consists of only '1' and '2' and obeys the following rules:
    
    
        The string S is magical because concatenating the number of contiguous occurrences of
        characters '1' and '2' generates the string S itself.
    

    
        The first few elements of string S is the following:
        S = "1221121221221121122……"
    

    
        If we group the consecutive '1's and '2's in S, it will be:
    
    
        1 22 11 2 1 22 1 22 11 2 11 22 ......
    
    
        and the occurrences of '1's or '2's in each group are:
    
    
        1 2 2 1 1 2 1 2 2 1 2 2 ......
    

    
        You can see that the occurrence sequence above is the S itself.
    

    
        Given an integer N as input, return the number of '1's in the first N number in the magical
        string S.
    

    Note:
        N will not exceed 100,000.
    

    Example 1:
    Input: 6
Output: 3
Explanation: The first 6 elements of magical string S is "12211" and it contains three 1's, so return 3.
-----------------

# 909_Snakes_and_Ladders
# 909. Snakes and Ladders

On an N x N board, the numbers from 1 to N*N are
        written boustrophedonically starting from the bottom left of
            the board, and alternating direction each row.  For example, for a 6 x 6
        board, the numbers are written as follows:

    

    You start on square 1 of the board (which is always in the last row and first
        column).  Each move, starting from square x, consists of the following:
    

    
        You choose a destination square S with number x+1, x+2,
            x+3, x+4, x+5, or x+6, provided this number
            is <= N*N.

            
                (This choice simulates the result of a standard 6-sided die roll: ie., there are
                    always at most 6 destinations, regardless of the size of the
                        board.)
                
            
        
        If S has a snake or ladder, you move to the destination of that snake
            or ladder.  Otherwise, you move to S.
        
    

    A board square on row r and column c has a "snake or
        ladder" if board[r][c] != -1.  The destination of that snake or
        ladder is board[r][c].

    Note that you only take a snake or ladder at most once per move: if the destination to a
        snake or ladder is the start of another snake or ladder, you do not
        continue moving.  (For example, if the board is `[[4,-1],[-1,3]]`, and on the first
        move your destination square is `2`, then you finish your first move at `3`, because
        you do not continue moving to `4`.)

    Return the least number of moves required to reach square N*N. 
        If it is not possible, return -1.

    Example 1:

    Input: [
[-1,-1,-1,-1,-1,-1],
[-1,-1,-1,-1,-1,-1],
[-1,-1,-1,-1,-1,-1],
[-1,35,-1,-1,13,-1],
[-1,-1,-1,-1,-1,-1],
[-1,15,-1,-1,-1,-1]]
Output: 4
Explanation: 
At the beginning, you start at square 1 [at row 5, column 0].
You decide to move to square 2, and must take the ladder to square 15.
You then decide to move to square 17 (row 3, column 5), and must take the snake to square 13.
You then decide to move to square 14, and must take the ladder to square 35.
You then decide to move to square 36, ending the game.
It can be shown that you need at least 4 moves to reach the N*N-th square, so the answer is 4.

    Note:

    
        2 <= board.length = board[0].length <= 20
        board[i][j] is between 1 and N*N or is equal
            to -1.
        
        The board square with number 1 has no snake or ladder.
        The board square with number N*N has no snake or ladder.
-----------------

# 1457_Pseudo-Palindromic_Paths_in_a_Binary_Tree
# 1457. Pseudo-Palindromic Paths in a Binary Tree


-----------------

# 1241_Number_of_Comments_per_Post
# 1241. Number of Comments per Post

Table: Submissions

    +---------------+----------+
| Column Name   | Type     |
+---------------+----------+
| sub_id        | int      |
| parent_id     | int      |
+---------------+----------+
There is no primary key for this table, it may have duplicate rows.
Each row can be a post or comment on the post.
parent_id is null for posts.
parent_id for comments is sub_id for another post in the table.

     

    Write an SQL query to find number of comments per each post.

    Result table should contain post_id and its corresponding number_of_comments,
        and must be sorted by post_id in ascending order.

    Submissions may contain duplicate comments. You should count the number of
        unique comments per post.

    Submissions may contain duplicate posts. You should treat them as one post.

    The query result format is in the following example:

    Submissions table:
+---------+------------+
| sub_id  | parent_id  |
+---------+------------+
| 1       | Null       |
| 2       | Null       |
| 1       | Null       |
| 12      | Null       |
| 3       | 1          |
| 5       | 2          |
| 3       | 1          |
| 4       | 1          |
| 9       | 1          |
| 10      | 2          |
| 6       | 7          |
+---------+------------+

Result table:
+---------+--------------------+
| post_id | number_of_comments |
+---------+--------------------+
| 1       | 3                  |
| 2       | 2                  |
| 12      | 0                  |
+---------+--------------------+

The post with id 1 has three comments in the table with id 3, 4 and 9. The comment with id 3 is repeated in the table, we counted it only once.
The post with id 2 has two comments in the table with id 5 and 10.
The post with id 12 has no comments in the table.
The comment with id 6 is a comment on a deleted post with id 7 so we ignored it.
-----------------

# 1778_Shortest_Path_in_a_Hidden_Grid
# 1778. Shortest Path in a Hidden Grid


-----------------

# 774_Minimize_Max_Distance_to_Gas_Station
# 774. Minimize Max Distance to Gas Station

On a horizontal number line, we have gas stations at positions stations[0],
        stations[1], ..., stations[N-1], where N = stations.length.

    Now, we add K more gas stations so that D, the maximum distance
        between adjacent gas stations, is minimized.

    Return the smallest possible value of D.

    Example:

    Input: stations = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], K = 9
Output: 0.500000

    Note:

    
        stations.length will be an integer in range [10, 2000].
        stations[i] will be an integer in range [0, 10^8].
        K will be an integer in range [1, 10^6].
        Answers within 10^-6 of the true value will be accepted as correct.
-----------------

# 896_Monotonic_Array
# 896. Monotonic Array

An array is monotonic if it is either monotone increasing or monotone decreasing.
    

    An array A is monotone increasing if for all i <= j, A[i]
        <= A[j].  An array A is monotone decreasing if for all i
        <= j, A[i] >= A[j].

    Return true if and only if the given array A is monotonic.
-----------------

# 1311_Get_Watched_Videos_by_Your_Friends
# 1311. Get Watched Videos by Your Friends


-----------------

# 1667_Fix_Names_in_a_Table
# 1667. Fix Names in a Table


-----------------

# 802_Find_Eventual_Safe_States
# 802. Find Eventual Safe States

In a directed graph, we start at some node and every turn, walk along a directed edge of the
        graph.  If we reach a node that is terminal (that is, it has no outgoing directed
        edges), we stop.

    Now, say our starting node is eventually safe if and only if we must eventually
        walk to a terminal node.  More specifically, there exists a natural number
        K so that for any choice of where to walk, we must have stopped at a terminal
        node in less than K steps.

    Which nodes are eventually safe?  Return them as an array in sorted order.

    The directed graph has N nodes with labels 0, 1, ..., N-1, where
        N is the length of graph.  The graph is given in the
        following form: graph[i] is a list of labels j such that (i,
            j) is a directed edge of the graph.

    Example:
Input: graph = [[1,2],[2,3],[5],[0],[5],[],[]]
Output: [2,4,5,6]
Here is a diagram of the above graph.

    

    Note:

    
        graph will have length at most 10000.
        The number of edges in the graph will not exceed 32000.
        Each graph[i] will be a sorted list of different integers, chosen within
            the range [0, graph.length - 1].
-----------------

# 758_Bold_Words_in_String
# 758. Bold Words in String

Given a set of keywords words and a string S, make all appearances
        of all keywords in S bold. Any letters between <b> and
        </b> tags become bold.
    
    
        The returned string should use the least number of tags possible, and of course the tags
        should form a valid combination.
    
    
        For example, given that words = ["ab", "bc"] and S = "aabcd", we
        should return "a<b>abc</b>d". Note that returning "a<b>a<b>b</b>c</b>d"
        would use more tags, so it is incorrect.
    

    Note:
    
        words has length in range [0, 50].
        words[i] has length in range [1, 10].
        S has length in range [0, 500].
        All characters in words[i] and S are lowercase letters.
-----------------

# 1106_Parsing_A_Boolean_Expression
# 1106. Parsing A Boolean Expression

Return the result of evaluating a given boolean expression, represented as a
        string.

    An expression can either be:

    
        "t", evaluating to True;
        "f", evaluating to False;
        "!(expr)", evaluating to the logical NOT of the inner expression
            expr;
        
        "&(expr1,expr2,...)", evaluating to the logical AND of 2 or
            more inner expressions expr1, expr2, ...;
        
        "|(expr1,expr2,...)", evaluating to the logical OR of 2 or more
            inner expressions expr1, expr2, ...
    

     
    Example 1:

    Input: expression = "!(f)"
Output: true

    Example 2:

    Input: expression = "|(f,t)"
Output: true

    Example 3:

    Input: expression = "&(t,f)"
Output: false

    Example 4:

    Input: expression = "|(&(t,f,t),!(t))"
Output: false

     
    Constraints:

    
        1 <= expression.length <= 20000
        expression[i] consists of characters in {'(', ')',
            '&', '|', '!', 't', 'f', ','}.
        
        expression is a valid expression representing a boolean, as given in the
            description.
-----------------

# 714_Best_Time_to_Buy_and_Sell_Stock_with_Transaction_Fee
# 714. Best Time to Buy and Sell Stock with Transaction Fee

Your are given an array of integers prices, for which the i-th
        element is the price of a given stock on day i; and a non-negative integer
        fee representing a transaction fee.
    You may complete as many transactions as you like, but you need to pay the transaction fee
        for each transaction. You may not buy more than 1 share of a stock at a time (ie. you must
        sell the stock share before you buy again.)
    Return the maximum profit you can make.

    Example 1:
    Input: prices = [1, 3, 2, 8, 4, 9], fee = 2
Output: 8
Explanation: The maximum profit can be achieved by:
Buying at prices[0] = 1Selling at prices[3] = 8Buying at prices[4] = 4Selling at prices[5] = 9The total profit is ((8 - 1) - 2) + ((9 - 4) - 2) = 8.

    

    Note:
    0 < prices.length <= 50000.
    0 < prices[i] < 50000.
    0 <= fee < 50000.
-----------------

# 1612_Check_If_Two_Expression_Trees_are_Equivalent
# 1612. Check If Two Expression Trees are Equivalent


-----------------

# 1809_Ad-Free_Sessions
# 1809. Ad-Free Sessions


-----------------

# 1206_Design_Skiplist
# 1206. Design Skiplist

Design a Skiplist without using any built-in libraries.

    A Skiplist is a data structure that takes O(log(n)) time to add,
        erase and search. Comparing with treap and red-black tree which
        has the same function and performance, the code length of Skiplist can be comparatively
        short and the idea behind Skiplists are just simple linked lists.

    For example: we have a Skiplist containing [30,40,50,60,70,90] and we
        want to add 80 and 45 into it. The Skiplist works this
        way:

    
        Artyom Kalinin [CC BY-SA 3.0], via Wikimedia
            Commons
    

    You can see there are many layers in the Skiplist. Each layer is a sorted linked list.
        With the help of the top layers, add , erase and
        search can be faster than O(n). It can be proven that the
        average time complexity for each operation is O(log(n)) and space complexity is O(n).
    

    To be specific, your design should include these functions:

    
        bool search(int target) : Return whether the target
            exists in the Skiplist or not.
        
        void add(int num): Insert a value into the SkipList. 
        bool erase(int num): Remove a value in the Skiplist. If
            num does not exist in the Skiplist, do nothing and return false. If
            there exists multiple num values, removing any one of them is fine.
        
    

    See more about Skiplist : https://en.wikipedia.org/wiki/Skip_list
    

    Note that duplicates may exist in the Skiplist, your code needs to handle this situation.

     

    Example:

    Skiplist skiplist = new Skiplist();

skiplist.add(1);
skiplist.add(2);
skiplist.add(3);
skiplist.search(0);   // return false.
skiplist.add(4);
skiplist.search(1);   // return true.
skiplist.erase(0);    // return false, 0 is not in skiplist.
skiplist.erase(1);    // return true.
skiplist.search(1);   // return false, 1 has already been erased.

     
    Constraints:

    
        0 <= num, target <= 20000
        At most 50000 calls will be made to search,
            add, and erase.
-----------------

# 750_Number_Of_Corner_Rectangles
# 750. Number Of Corner Rectangles

Given a grid where each entry is only 0 or 1, find the number of corner rectangles.

    A corner rectangle is 4 distinct 1s on the grid that form an axis-aligned rectangle.
        Note that only the corners need to have the value 1. Also, all four 1s used must be
        distinct.

     

    Example 1:

    Input: grid =
[[1, 0, 0, 1, 0],
 [0, 0, 1, 0, 1],
 [0, 0, 0, 1, 0],
 [1, 0, 1, 0, 1]]
Output: 1
Explanation: There is only one corner rectangle, with corners grid[1][2], grid[1][4], grid[3][2], grid[3][4].

     

    Example 2:

    Input: grid =
[[1, 1, 1],
 [1, 1, 1],
 [1, 1, 1]]
Output: 9
Explanation: There are four 2x2 rectangles, four 2x3 and 3x2 rectangles, and one 3x3 rectangle.

     

    Example 3:

    Input: grid =
[[1, 1, 1, 1]]
Output: 0
Explanation: Rectangles must have four distinct corners.

     

    Note:

    
        The number of rows and columns of grid will each be in the range [1,
            200].
        
        Each grid[i][j] will be either 0 or 1.
        The number of 1s in the grid will be at most 6000.
-----------------

# 1104_Path_In_Zigzag_Labelled_Binary_Tree
# 1104. Path In Zigzag Labelled Binary Tree

In an infinite binary tree where every node has two children, the nodes are labelled in row
        order.

    In the odd numbered rows (ie., the first, third, fifth,...), the labelling is left to right,
        while in the even numbered rows (second, fourth, sixth,...), the labelling is right to
        left.

    

    Given the label of a node in this tree, return the labels in the path from the
        root of the tree to the node with that label.

     
    Example 1:

    Input: label = 14
Output: [1,3,4,14]

    Example 2:

    Input: label = 26
Output: [1,2,6,10,26]

     
    Constraints:

    
        1 <= label <= 10^6
-----------------

# 1417_Reformat_The_String
# 1417. Reformat The String


-----------------

# 342_Power_of_Four
# 342. Power of Four

Given an integer (signed 32 bits), write a function to check whether it is a power of 4.

    Example 1:

    Input: 16
Output: true
-----------------

# 509_Fibonacci_Number
# 509. Fibonacci Number

The Fibonacci numbers, commonly denoted F(n) form a
        sequence, called the Fibonacci sequence, such that each number is the sum of the
        two preceding ones, starting from 0 and 1. That is,

    F(0) = 0,   F(1) = 1
F(N) = F(N - 1) + F(N - 2), for N > 1.

    Given N, calculate F(N).

     

    Example 1:

    Input: 2
Output: 1
Explanation: F(2) = F(1) + F(0) = 1 + 0 = 1.

    Example 2:

    Input: 3
Output: 2
Explanation: F(3) = F(2) + F(1) = 1 + 1 = 2.

    Example 3:

    Input: 4
Output: 3
Explanation: F(4) = F(3) + F(2) = 2 + 1 = 3.

     

    Note:

    0 ≤ N ≤ 30.
-----------------

# 1763_Longest_Nice_Substring
# 1763. Longest Nice Substring


-----------------

# 278_First_Bad_Version
# 278. First Bad Version

You are a product manager and currently leading a team to develop a new product.
        Unfortunately, the latest version of your product fails the quality check. Since each
        version is developed based on the previous version, all the versions after a bad version are
        also bad.

    Suppose you have n versions [1, 2, ..., n] and you want to find out
        the first bad one, which causes all the following ones to be bad.

    You are given an API bool isBadVersion(version) which will return whether version
        is bad. Implement a function to find the first bad version. You should minimize the number
        of calls to the API.

    Example:

    Given n = 5, and version = 4 is the first bad version.

call isBadVersion(3) -> false
call isBadVersion(5) -> true
call isBadVersion(4) -> true

Then 4 is the first bad version.
-----------------

# 811_Subdomain_Visit_Count
# 811. Subdomain Visit Count

A website domain like "discuss.leetcode.com" consists of various subdomains. At the
        top level, we have "com", at the next level, we have "leetcode.com", and
        at the lowest level, "discuss.leetcode.com". When we visit a domain like "discuss.leetcode.com",
        we will also visit the parent domains "leetcode.com" and "com"
        implicitly.

    Now, call a "count-paired domain" to be a count (representing the number of visits
        this domain received), followed by a space, followed by the address. An example of a
        count-paired domain might be "9001 discuss.leetcode.com".

    We are given a list cpdomains of count-paired domains. We would like a list of
        count-paired domains, (in the same format as the input, and in any order), that explicitly
        counts the number of visits to each subdomain.

    Example 1:
Input:
["9001 discuss.leetcode.com"]
Output:
["9001 discuss.leetcode.com", "9001 leetcode.com", "9001 com"]
Explanation:
We only have one website domain: "discuss.leetcode.com". As discussed above, the subdomain "leetcode.com" and "com" will also be visited. So they will all be visited 9001 times.

    Example 2:
Input:
["900 google.mail.com", "50 yahoo.com", "1 intel.mail.com", "5 wiki.org"]
Output:
["901 mail.com","50 yahoo.com","900 google.mail.com","5 wiki.org","5 org","1 intel.mail.com","951 com"]
Explanation:
We will visit "google.mail.com" 900 times, "yahoo.com" 50 times, "intel.mail.com" once and "wiki.org" 5 times. For the subdomains, we will visit "mail.com" 900 + 1 = 901 times, "com" 900 + 50 + 1 = 951 times, and "org" 5 times.

    Notes: 

    
        The length of cpdomains will not exceed 100. 
        The length of each domain name will not exceed 100.
        Each address will have either 1 or 2 "." characters.
        The input count in any count-paired domain will not exceed 10000.
        The answer output can be returned in any order.
-----------------

# 1070_Product_Sales_Analysis_III
# 1070. Product Sales Analysis III

Table: Sales

    +-------------+-------+
| Column Name | Type  |
+-------------+-------+
| sale_id     | int   |
| product_id  | int   |
| year        | int   |
| quantity    | int   |
| price       | int   |
+-------------+-------+
sale_id is the primary key of this table.
product_id is a foreign key to Product table.
Note that the price is per unit.

    Table: Product

    +--------------+---------+
| Column Name  | Type    |
+--------------+---------+
| product_id   | int     |
| product_name | varchar |
+--------------+---------+
product_id is the primary key of this table.

     

    Write an SQL query that selects the product id,
        year, quantity, and price for the
        first year of every product sold.

    The query result format is in the following example:

    Sales table:
+---------+------------+------+----------+-------+
| sale_id | product_id | year | quantity | price |
+---------+------------+------+----------+-------+
| 1       | 100        | 2008 | 10       | 5000  |
| 2       | 100        | 2009 | 12       | 5000  |
| 7       | 200        | 2011 | 15       | 9000  |
+---------+------------+------+----------+-------+

Product table:
+------------+--------------+
| product_id | product_name |
+------------+--------------+
| 100        | Nokia        |
| 200        | Apple        |
| 300        | Samsung      |
+------------+--------------+

Result table:
+------------+------------+----------+-------+
| product_id | first_year | quantity | price |
+------------+------------+----------+-------+
| 100        | 2008       | 10       | 5000  |
| 200        | 2011       | 15       | 9000  |
+------------+------------+----------+-------+
-----------------

# 41_First_Missing_Positive
# 41. First Missing Positive

Given an unsorted integer array, find the smallest missing positive integer.

    Example 1:

    Input: [1,2,0]
Output: 3

    Example 2:

    Input: [3,4,-1,1]
Output: 2

    Example 3:

    Input: [7,8,9,11,12]
Output: 1

    Note:

    Your algorithm should run in O(n) time and uses constant extra space.
-----------------

# 1672_Richest_Customer_Wealth
# 1672. Richest Customer Wealth


-----------------

# 1434_Number_of_Ways_to_Wear_Different_Hats_to_Each_Other
# 1434. Number of Ways to Wear Different Hats to Each Other


-----------------

# 217_Contains_Duplicate
# 217. Contains Duplicate

Given an array of integers, find if the array contains any duplicates.

    Your function should return true if any value appears at least twice in the array, and it
        should return false if every element is distinct.

    Example 1:

    Input: [1,2,3,1]
Output: true

    Example 2:

    Input: [1,2,3,4]
Output: false

    Example 3:

    Input: [1,1,1,3,3,4,3,2,4,2]
Output: true
-----------------

# 442_Find_All_Duplicates_in_an_Array
# 442. Find All Duplicates in an Array

Given an array of integers, 1 ≤ a[i] ≤ n (n = size of array), some
        elements appear twice and others appear once.

    Find all the elements that appear twice in this array.

    Could you do it without extra space and in O(n) runtime?
    
    Example:
    Input:
[4,3,2,7,8,2,3,1]

Output:
[2,3]
-----------------

# 180_Consecutive_Numbers
# 180. Consecutive Numbers

Write a SQL query to find all numbers that appear at least three times consecutively.

    +----+-----+
| Id | Num |
+----+-----+
| 1  |  1  |
| 2  |  1  |
| 3  |  1  |
| 4  |  2  |
| 5  |  1  |
| 6  |  2  |
| 7  |  2  |
+----+-----+

    For example, given the above Logs table, 1 is the only number that
        appears consecutively for at least three times.

    +-----------------+
| ConsecutiveNums |
+-----------------+
| 1               |
+-----------------+
-----------------

# 150_Evaluate_Reverse_Polish_Notation
# 150. Evaluate Reverse Polish Notation

Evaluate the value of an arithmetic expression in Reverse
        Polish Notation.

    Valid operators are +, -, *, /. Each
        operand may be an integer or another expression.

    Note:

    
        Division between two integers should truncate toward zero.
        The given RPN expression is always valid. That means the expression would always
            evaluate to a result and there won't be any divide by zero operation.
        
    

    Example 1:

    Input: ["2", "1", "+", "3", "*"]
Output: 9
Explanation: ((2 + 1) * 3) = 9

    Example 2:

    Input: ["4", "13", "5", "/", "+"]
Output: 6
Explanation: (4 + (13 / 5)) = 6

    Example 3:

    Input: ["10", "6", "9", "3", "+", "-11", "*", "/", "*", "17", "+", "5", "+"]
Output: 22
Explanation:
  ((10 * (6 / ((9 + 3) * -11))) + 17) + 5
= ((10 * (6 / (12 * -11))) + 17) + 5
= ((10 * (6 / -132)) + 17) + 5
= ((10 * 0) + 17) + 5
= (0 + 17) + 5
= 17 + 5
= 22
-----------------

# 1021_Remove_Outermost_Parentheses
# 1021. Remove Outermost Parentheses

A valid parentheses string is either empty (""), "(" +
        A + ")", or A + B, where A and B are
        valid parentheses strings, and + represents string concatenation.  For
        example, "", "()",
        "(())()", and "(()(()))" are all valid
        parentheses strings.

    A valid parentheses string S is primitive if it is nonempty,
        and there does not exist a way to split it into S = A+B, with A
        and B nonempty valid parentheses strings.

    Given a valid parentheses string S, consider its primitive decomposition: S
        = P_1 + P_2 + ... + P_k, where P_i are primitive valid parentheses
        strings.

    Return S after removing the outermost parentheses of every primitive string in
        the primitive decomposition of S.

     

    Example 1:

    Input: "(()())(())"
Output: "()()()"
Explanation: 
The input string is "(()())(())", with primitive decomposition "(()())" + "(())".
After removing outer parentheses of each part, this is "()()" + "()" = "()()()".
-----------------

# 186_Reverse_Words_in_a_String_II
# 186. Reverse Words in a String II

Given an input string , reverse the string word by word. 
    

    Example:

    Input:  ["t","h","e"," ","s","k","y"," ","i","s"," ","b","l","u","e"]
Output: ["b","l","u","e"," ","i","s"," ","s","k","y"," ","t","h","e"]

    Note: 

    
        A word is defined as a sequence of non-space characters.
        The input string does not contain leading or trailing spaces.
        The words are always separated by a single space.
    

    Follow up: Could you do it in-place without allocating extra
        space?
-----------------

